<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Jira Execution Planner</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #f8f7f4;
            --bg-secondary: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --accent: #d4380d;
            --good: #389e0d;
            --warn: #cf1322;
            --muted: #bfbfbf;
            --alert-missing: #fa8c16;
            --alert-blocked: #d4380d;
            --border: #e0ddd7;
            --shadow: rgba(0, 0, 0, 0.04);
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 1040px;
            margin: 0 auto;
            padding: 0.9rem 1.5rem 3rem;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        header {
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.4rem;
        }

        h1 {
            font-size: 2.4rem;
            font-weight: 300;
            letter-spacing: -0.02em;
            margin-bottom: 0.2rem;
            animation: slideDown 0.8s ease-out 0.2s both;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .subtitle {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            animation: slideDown 0.8s ease-out 0.4s both;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .subtitle-secondary {
            font-size: 0.4375rem;
            letter-spacing: 0.12em;
            opacity: 0.85;
        }

        .search-input {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.875rem;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-primary);
            text-transform: none;
            letter-spacing: normal;
            width: 260px;
            transition: all 0.2s;
        }

        .header-actions {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: nowrap;
        }

        .secondary.compact {
            padding: 0.4rem 0.75rem;
            font-size: 0.7rem;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(212, 56, 13, 0.1);
        }

        .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }

        .search-wrap {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-clear {
            position: absolute;
            right: 0.35rem;
            background: transparent;
            border: none;
            font-size: 1rem;
            line-height: 1;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.1rem 0.3rem;
        }

        .search-clear:hover {
            color: var(--text-primary);
        }

        .view-selector {
            display: flex;
            align-items: center;
            margin-top: 0.6rem;
            position: relative;
        }

        .view-filters {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            flex-wrap: nowrap;
            width: 100%;
        }

        .view-actions {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            margin-left: 0.5rem;
        }

        .view-selector label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin: 0;
        }

        .view-selector button {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            margin: 0;
        }

        .sprint-dropdown {
            position: relative;
            min-width: 180px;
        }

        .sprint-dropdown-toggle {
            width: 180px;
            padding: 0.35rem 0.6rem;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            transition: all 0.2s;
            text-transform: none;
            letter-spacing: normal;
            margin-right: 0;
            box-shadow: none;
        }

        .sprint-dropdown-toggle svg {
            width: 0.55rem;
            height: 0.55rem;
            flex-shrink: 0;
            transition: transform 0.2s ease;
        }

        .sprint-dropdown-toggle:hover {
            border-color: var(--border);
            transform: none;
            box-shadow: 0 6px 14px rgba(22, 22, 22, 0.12);
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .sprint-dropdown-toggle.open {
            border-color: var(--border);
            box-shadow: 0 6px 14px rgba(22, 22, 22, 0.12);
        }

        .sprint-dropdown-toggle.open svg {
            transform: rotate(180deg);
        }

        .sprint-dropdown-panel {
            position: absolute;
            top: calc(100% + 0.4rem);
            left: 0;
            width: 180px;
            background: #fff;
            border: 1px solid var(--border);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.08);
            padding: 0.5rem;
            z-index: 20;
        }

        .sprint-dropdown-search {
            width: 100%;
            padding: 0.4rem 0.5rem;
            border: 1px solid var(--border);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            margin-bottom: 0.4rem;
        }

        .sprint-dropdown-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .sprint-dropdown-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.4rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .sprint-dropdown-option:hover {
            background: #f5f5f5;
            box-shadow: inset 0 0 0 1px #e6e1da;
        }

        .group-dropdown {
            position: relative;
            min-width: 200px;
        }

        .group-dropdown-toggle {
            width: 200px;
            padding: 0.35rem 0.6rem;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            transition: all 0.2s;
            text-transform: none;
            letter-spacing: normal;
            margin-right: 0;
            box-shadow: none;
        }

        .group-dropdown-toggle span {
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .group-dropdown-toggle svg {
            width: 0.55rem;
            height: 0.55rem;
            flex-shrink: 0;
            transition: transform 0.2s ease;
        }

        .group-dropdown-toggle:hover {
            border-color: var(--border);
            transform: none;
            box-shadow: 0 6px 14px rgba(22, 22, 22, 0.12);
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .group-dropdown-toggle.open {
            border-color: var(--border);
            box-shadow: 0 6px 14px rgba(22, 22, 22, 0.12);
        }

        .group-dropdown-toggle.open svg {
            transform: rotate(180deg);
        }

        .group-dropdown-panel {
            position: absolute;
            top: calc(100% + 0.4rem);
            left: 0;
            width: 240px;
            background: #fff;
            border: 1px solid var(--border);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.08);
            padding: 0.5rem;
            z-index: 22;
        }

        .group-dropdown-option {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 0.5rem;
            padding: 0.35rem 0.4rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .group-dropdown-option:hover {
            background: #f5f5f5;
            box-shadow: inset 0 0 0 1px #e6e1da;
        }

        .group-option-meta {
            font-size: 0.65rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .group-option-default {
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--accent);
            letter-spacing: 0.08em;
        }

        .group-option-tags {
            margin-left: auto;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .group-manage-button {
            padding: 0.35rem 0.6rem;
            font-size: 0.7rem;
        }

        .group-modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(19, 16, 12, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 80;
        }

        .group-modal {
            background: #fff;
            width: min(920px, 95vw);
            max-height: 85vh;
            border: 1px solid var(--border);
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.16);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .group-modal-header {
            padding: 0.9rem 1.2rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }

        .group-modal-title {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--text-secondary);
        }

        .group-modal-body {
            padding: 1rem 1.2rem 1.2rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.9rem;
        }

        .group-modal-row {
            display: grid;
            grid-template-columns: minmax(160px, 1fr) minmax(240px, 2fr) auto;
            gap: 0.6rem;
            align-items: center;
        }

        .group-modal-row input,
        .group-modal-row textarea {
            width: 100%;
            padding: 0.4rem 0.6rem;
            border: 1px solid var(--border);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
        }

        .group-modal-row textarea {
            min-height: 3.5rem;
            resize: vertical;
        }

        .group-modal-body textarea {
            width: 100%;
            padding: 0.4rem 0.6rem;
            border: 1px solid var(--border);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            min-height: 4rem;
            resize: vertical;
        }

        .group-modal-actions {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .group-modal-meta {
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .group-modal-warning {
            padding: 0.5rem 0.7rem;
            border: 1px dashed #f59e0b;
            background: #fff6df;
            color: #8a5a00;
            font-size: 0.7rem;
        }

        .group-modal-footer {
            padding: 0.8rem 1.2rem;
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.8rem;
            background: #faf8f4;
        }

        .group-modal-button-row {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            flex-wrap: wrap;
        }

        .group-modal-button-row button.compact {
            min-width: 96px;
        }

        .group-star-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 26px;
            height: 26px;
            border: 1px solid var(--border);
            background: #fff;
            cursor: pointer;
            padding: 0;
        }

        .group-star-button.active {
            border-color: var(--accent);
            color: var(--accent);
        }

        .group-star-button svg {
            width: 14px;
            height: 14px;
        }

        select {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
        }

        select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(212, 56, 13, 0.1);
        }

        select:hover {
            border-color: var(--text-secondary);
        }

        select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .team-dropdown {
            position: relative;
            display: inline-block;
            align-items: center;
        }

        .team-dropdown-toggle {
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-primary);
            padding: 0.35rem 0.6rem;
            width: 180px;
            display: inline-flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: none;
            letter-spacing: normal;
        }

        .team-dropdown-toggle span {
            flex: 1;
            text-align: left;
        }

        .team-dropdown-toggle:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--border);
            box-shadow: 0 6px 14px rgba(22, 22, 22, 0.12);
        }

        .team-dropdown-toggle:focus {
            outline: none;
            border-color: var(--border);
            box-shadow: none;
        }

        .team-dropdown-toggle svg {
            width: 0.55rem;
            height: 0.55rem;
            transition: transform 0.2s ease;
            flex-shrink: 0;
        }

        .team-dropdown-toggle.open svg {
            transform: rotate(180deg);
        }

        .team-dropdown-panel {
            position: absolute;
            top: calc(100% + 0.35rem);
            left: 0;
            width: 180px;
            max-height: 220px;
            overflow-y: auto;
            background: #fff;
            border: 1px solid var(--border);
            box-shadow: 0 12px 28px rgba(22, 22, 22, 0.12);
            padding: 0.5rem 0.6rem;
            z-index: 20;
            text-align: left;
            box-sizing: border-box;
        }

        .view-selector .team-dropdown-panel label.team-dropdown-option {
            display: grid;
            grid-template-columns: 14px 1fr;
            align-items: center;
            column-gap: 0.5rem;
            padding: 0.25rem 0.2rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.55rem;
            color: var(--text-primary);
            text-align: left;
            text-transform: none;
            letter-spacing: normal;
            line-height: 1.2;
            cursor: pointer;
            width: 100%;
            box-sizing: border-box;
            margin: 0;
        }

        .view-selector .team-dropdown-panel label.team-dropdown-option:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .view-selector .team-dropdown-panel label.team-dropdown-option input {
            margin: 0;
        }

        .view-selector .team-dropdown-panel label.team-dropdown-option span {
            text-align: left;
        }

        .team-dropdown-option + .team-dropdown-option {
            border-top: 1px dashed var(--border);
        }

        .config-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 2rem;
            margin-bottom: 3rem;
            animation: slideUp 0.6s ease-out 0.4s both;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        input {
            width: 100%;
            padding: 0.875rem;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            transition: all 0.2s;
        }

        input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(212, 56, 13, 0.1);
        }

        button {
            background: var(--text-primary);
            color: var(--bg-primary);
            border: none;
            padding: 0.875rem 2rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 1rem;
        }

        button:hover {
            background: #2f2f2f;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        button.secondary:hover {
            background: var(--bg-primary);
            transform: none;
        }

        button.compact {
            padding: 0.4rem 0.75rem;
            font-size: 0.7rem;
            letter-spacing: 0.06em;
        }

        button.toggle {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            margin: 0 0.5rem;
        }

        button.toggle:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
            transform: none;
        }

        button.toggle.active {
            background: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
        }

        .toggle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.25rem;
            flex-wrap: wrap;
        }

	        .alert-panels {
	            display: grid;
	            grid-template-columns: 1fr;
	            gap: 0.6rem;
	            margin: 0.6rem 0 0.85rem;
	        }

        .alert-panels.collapsed {
            gap: 0.6rem;
            margin: 0.6rem 0 0.85rem;
        }

	        .alert-card {
	            background: var(--bg-secondary);
	            border: 1px solid var(--border);
	            border-left: 6px solid var(--accent);
	            padding: 0.9rem 1.1rem;
	            box-shadow: 0 10px 30px var(--shadow);
                overflow-anchor: none;
	        }

        .alert-card.missing {
            border-left-color: var(--alert-missing);
        }

        .alert-card.blocked {
            border-left-color: var(--alert-blocked);
        }

        .alert-card.no-epic {
            border-left-color: #722ed1;
        }

	        .alert-card.empty-epic {
	            border-left-color: #fa8c16;
	        }

	        .alert-card.done-epic {
	            border-left-color: #52c41a;
	        }

	        .alert-card-header {
	            display: flex;
	            align-items: center;
	            justify-content: space-between;
	            gap: 0.75rem;
	            margin-bottom: 0;
	            flex-wrap: wrap;
	        }

        .alert-title {
            font-weight: 700;
            font-size: 1.05rem;
            display: flex;
            align-items: center;
            gap: 0.45rem;
        }

        .alert-subtitle {
            flex: 1;
            color: var(--text-secondary);
            font-size: 0.9rem;
            min-width: 220px;
        }

        .alert-chip {
            background: #1a1a1a;
            color: #fff;
            padding: 0.2rem 0.65rem;
            border-radius: 999px;
            font-size: 0.8rem;
            font-family: 'IBM Plex Mono', monospace;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            cursor: pointer;
        }

        .alert-chip:hover {
            background: #2a2a2a;
        }

        .alert-toggle {
            background: transparent;
            border: none;
            color: var(--text-primary);
            padding: 0;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
        }

        .alert-toggle:hover {
            background: transparent;
            transform: none;
            box-shadow: none;
        }

        .alert-toggle-icon {
            width: 1.15rem;
            height: 1.15rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 999px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #444;
        }

        .alert-toggle-chevron {
            width: 0.7rem;
            height: 0.7rem;
            display: block;
            transition: transform 0.2s ease;
        }

        .alert-toggle-chevron.collapsed {
            transform: rotate(-90deg);
        }

        .alert-toggle-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 0.02em;
        }

        .alert-card-body {
            margin-top: 0;
            padding-top: 0.35rem;
            max-height: 1200px;
            opacity: 1;
            overflow: hidden;
            transition: max-height 0.35s ease, opacity 0.25s ease;
        }

        .alert-card-body.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .alert-epic {
            border: 1px solid var(--border);
            padding: 0.85rem;
            margin-bottom: 0.6rem;
            background: #faf9f7;
        }

        .alert-epic-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            margin-bottom: 0.55rem;
            flex-wrap: wrap;
        }

        .alert-epic-title {
            display: flex;
            align-items: center;
            gap: 0.45rem;
            font-weight: 600;
        }

        .alert-epic-link {
            font-size: 0.85rem;
            color: var(--accent);
            text-decoration: none;
        }

        .alert-team-group {
            border: 1px solid var(--border);
            padding: 0.75rem;
            margin-bottom: 0.6rem;
            background: #faf9f7;
        }

        .alert-team-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.6rem;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
        }

        .alert-team-title {
            display: flex;
            align-items: center;
            gap: 0.45rem;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .alert-team-link {
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            font-size: 0.8rem;
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 600;
        }

        .alert-team-link:hover {
            color: var(--accent);
        }

        .alert-stories {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .alert-story {
            display: flex;
            align-items: flex-start;
            gap: 0.55rem;
            padding: 0.5rem 0.4rem;
            border-radius: 6px;
            border: 1px dashed var(--border);
            background: #fff;
            position: relative;
        }

        .alert-story:hover {
            border-color: var(--accent);
            transform: translateY(-1px);
            transition: all 0.2s ease;
        }

        .alert-pill {
            padding: 0.25rem 0.55rem;
            border-radius: 999px;
            background: #f0f0f0;
            font-size: 0.75rem;
            font-family: 'IBM Plex Mono', monospace;
            color: #444;
            white-space: nowrap;
        }

        .alert-pill.team {
            background: #e6f4ff;
            color: #0958d9;
        }

        .alert-pill.status {
            background: #fff1f0;
            color: #d4380d;
        }

        .alert-story-main {
            flex: 1;
            min-width: 0;
            cursor: pointer;
        }

        .alert-story-link {
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 600;
        }

        .alert-story-note {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-top: 0.2rem;
        }

        .alert-action {
            color: var(--accent);
            font-weight: 600;
            text-decoration: none;
            font-size: 0.85rem;
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
            white-space: nowrap;
        }

        .alert-celebration {
            position: fixed;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }

        .alert-confetti {
            position: absolute;
            top: -12px;
            border-radius: 2px;
            opacity: 0;
            animation: confettiFall 2.2s ease-out forwards;
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-10px) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            100% {
                transform: translateY(110vh) rotate(360deg);
                opacity: 0;
            }
        }

        .alert-remove {
            position: static;
            width: 1.3rem;
            height: 1.3rem;
            opacity: 1;
            border-radius: 999px;
            margin-left: 0.2rem;
        }

        .alert-story .alert-remove {
            border-color: var(--border);
        }

        .alert-story .alert-remove:hover {
            transform: none;
        }

        .task-list {
            animation: fadeIn 0.8s ease-out 0.6s both;
        }

        .task-item {
            background: var(--bg-secondary);
            border-left: 4px solid var(--border);
            padding: 1.25rem 1.5rem;
            margin-bottom: 0.9rem;
            transition: transform 0.3s, box-shadow 0.3s, opacity 0.14s ease, background-color 0.14s ease, outline 0.14s ease, outline-offset 0.14s ease;
            animation: slideUp 0.6s ease-out both;
            position: relative;
        }

        .task-item::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(239, 68, 68, 0.12);
            opacity: 0;
            pointer-events: none;
        }

        .task-item:nth-child(1) { animation-delay: 0.7s; }
        .task-item:nth-child(2) { animation-delay: 0.8s; }
        .task-item:nth-child(3) { animation-delay: 0.9s; }
        .task-item:nth-child(4) { animation-delay: 1s; }
        .task-item:nth-child(5) { animation-delay: 1.1s; }

        .task-item:hover {
            transform: translateX(4px);
            box-shadow: -6px 0 18px var(--shadow);
        }

        .task-item.task-highlight::after {
            animation: taskHighlightPulse 1.8s ease-in-out;
        }

        @keyframes taskHighlightPulse {
            0% { opacity: 0; }
            20% { opacity: 1; }
            40% { opacity: 0; }
            60% { opacity: 1; }
            80% { opacity: 0; }
            100% { opacity: 0; }
        }

        /* Standard Jira priorities */
        .task-item.priority-blocker,
        .task-item.priority-highest {
            border-left-color: #a8071a;
        }

        .task-item.priority-critical,
        .task-item.priority-high {
            border-left-color: #d4380d;
        }

        .task-item.priority-major,
        .task-item.priority-medium {
            border-left-color: #faad14;
        }

        .task-item.priority-minor,
        .task-item.priority-low {
            border-left-color: #bfbfbf;
        }

        .task-item.priority-trivial,
        .task-item.priority-lowest {
            border-left-color: #d9d9d9;
        }

        .task-item.status-done {
            background: #f6ffed;
            border-left-color: #52c41a;
        }

        .task-item.status-killed {
            background: #f5f5f5;
            border-left-color: #d9d9d9;
            opacity: 0.6;
        }

        .task-item.status-killed .task-title,
        .task-item.status-killed .task-inline-meta,
        .task-item.status-killed .task-meta {
            color: #8c8c8c;
        }

        .task-item.status-killed .task-priority {
            color: #8c8c8c;
            border-color: #d9d9d9;
        }

        .task-item.status-killed:hover {
            opacity: 0.75;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            position: relative;
        }

        .task-remove {
            position: absolute;
            top: -1.1rem;
            right: -1.1rem;
            width: 1.5rem;
            height: 1.5rem;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.2s;
            padding: 0;
            margin: 0;
            border-radius: 2px;
            letter-spacing: 0;
            text-transform: none;
        }

        .task-item:hover .task-remove {
            opacity: 1;
        }

        .task-remove:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            transform: none;
        }

        .alert-story .alert-remove {
            position: static;
            opacity: 1;
            width: 1.3rem;
            height: 1.3rem;
            border-radius: 999px;
            margin-left: 0.2rem;
            display: grid;
            place-items: center;
            font-size: 0.85rem;
            line-height: 1;
            transform: translateY(-1px);
        }

        .task-headline {
            display: flex;
            align-items: baseline;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .task-title {
            font-size: 1.05rem;
            font-weight: 400;
            line-height: 1.25;
        }

        .task-title a {
            color: inherit;
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .task-title a:hover {
            border-bottom-color: var(--text-primary);
        }

        .task-inline-meta {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.68rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-key-link {
            color: inherit;
            text-decoration: none;
            border-bottom: 1px solid transparent;
        }

        .task-key-link:hover {
            border-bottom-color: var(--text-primary);
        }

        .task-inline-sp {
            color: #d48806;
            font-weight: 600;
        }

        .task-headline .task-checkbox {
            margin-left: 0.2rem;
        }

        .task-priority {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.7rem;
            padding: 0.2rem 0.6rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        /* Standard Jira priorities */
        .task-priority.blocker,
        .task-priority.highest {
            color: #a8071a;
            border-color: #a8071a;
            background: #fff1f0;
        }

        .task-priority.critical,
        .task-priority.high {
            color: #d4380d;
            border-color: #d4380d;
            background: #fff2e8;
        }

        .task-priority.major,
        .task-priority.medium {
            color: #d48806;
            border-color: #d48806;
            background: #fffbe6;
        }

        .task-priority.minor,
        .task-priority.low {
            color: #8c8c8c;
            border-color: #bfbfbf;
            background: #fafafa;
        }

        .task-priority.trivial,
        .task-priority.lowest {
            color: #bfbfbf;
            border-color: #d9d9d9;
            background: #fafafa;
        }

        .task-meta {
            display: flex;
            gap: 1rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            flex-wrap: wrap;
        }

        .task-team {
            background: #f6f4ff;
            color: #4b3fb0;
            padding: 0.18rem 0.45rem;
            border-radius: 2px;
            border: 1px solid #c7b8ff;
        }

        .task-assignee {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            color: var(--text-secondary);
        }

        .task-assignee-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            color: #8c8c8c;
        }

        .task-assignee-icon svg {
            width: 14px;
            height: 14px;
        }

        .epic-block {
            border: 1px solid var(--border);
            margin-bottom: 1.1rem;
            background: var(--bg-secondary);
            padding: 0.75rem;
            position: relative;
        }

        .dependency-strip {
            margin-top: 0.55rem;
            padding-top: 0.45rem;
            border-top: 1px dashed var(--border);
            display: flex;
            flex-wrap: nowrap;
            gap: 0.65rem;
            align-items: center;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.65rem;
            overflow-x: auto;
            white-space: nowrap;
        }

        .dependency-count {
            border: 1px solid var(--border);
            padding: 0.1rem 0.45rem;
            border-radius: 999px;
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-primary);
            background: #f4f5f7;
            cursor: pointer;
            transition: background-color 0.15s ease, border-color 0.15s ease, color 0.15s ease;
        }

        .dependency-count.active {
            background: #111;
            color: #fff;
            border-color: #111;
        }

        .dependency-count[data-dep-chip="depends-on"]:hover,
        .dependency-count[data-dep-chip="blocked-by"]:hover {
            background: rgba(239, 68, 68, 0.12);
            border-color: rgba(239, 68, 68, 0.4);
            color: #7f1d1d;
        }

        .dependency-count[data-dep-chip="dependents"]:hover,
        .dependency-count[data-dep-chip="blocks"]:hover {
            background: rgba(59, 130, 246, 0.12);
            border-color: rgba(59, 130, 246, 0.4);
            color: #1d4ed8;
        }

        .dependency-count.active[data-dep-chip="depends-on"],
        .dependency-count.active[data-dep-chip="blocked-by"] {
            background: rgba(239, 68, 68, 0.16);
            border-color: rgba(239, 68, 68, 0.55);
            color: #7f1d1d;
        }

        .dependency-count.active[data-dep-chip="dependents"],
        .dependency-count.active[data-dep-chip="blocks"] {
            background: rgba(59, 130, 246, 0.16);
            border-color: rgba(59, 130, 246, 0.55);
            color: #1d4ed8;
        }

        .focus-mode .task-item {
            transition: opacity 160ms ease, background 160ms ease, outline 160ms ease;
        }

        .focus-mode .task-item.is-dimmed {
            opacity: 0.18;
            pointer-events: none;
        }

        .task-item.is-focused {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
            background: rgba(59, 130, 246, 0.06);
        }

        .task-item.is-upstream {
            background: rgba(239, 68, 68, 0.06);
        }

        .task-item.is-downstream {
            background: rgba(59, 130, 246, 0.06);
        }

        .task-header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.35rem;
        }

        .dependency-pill-stack {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.25rem;
        }

        .dependency-pill {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.55rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            padding: 0.1rem 0.35rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            background: #f4f5f7;
        }

        .dependency-pill.blocked {
            color: #b91c1c;
            border-color: rgba(239, 68, 68, 0.4);
            background: rgba(239, 68, 68, 0.08);
        }

        .dependency-pill.blocker {
            color: #2563eb;
            border-color: rgba(59, 130, 246, 0.4);
            background: rgba(59, 130, 246, 0.08);
        }

        .dependency-missing {
            margin-top: 0.45rem;
            padding-top: 0.35rem;
            border-top: 1px dashed var(--border);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .dependency-missing-label {
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-size: 0.55rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .dependency-missing-label.hidden {
            color: #b45309;
        }

        .dependency-missing-item {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
        }

        .dependency-missing-sep {
            margin: 0 0.35rem;
            color: var(--text-secondary);
        }

        .dependency-missing-status.done {
            color: #15803d;
            font-weight: 600;
        }


        .epic-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            padding: 0.5rem 0;
            margin-bottom: 0.75rem;
            position: sticky;
            top: calc(var(--planning-offset, 0px) + 0.5rem);
            background: var(--bg-secondary);
            z-index: 3;
            box-shadow: 0 1px 0 var(--border);
        }

        .epic-flash {
            animation: epicFlash 1.1s ease;
        }

        @keyframes epicFlash {
            0% { background: rgba(255, 255, 0, 0.45); }
            100% { background: transparent; }
        }

        .epic-excluded {
            opacity: 0.55;
            transition: opacity 0.2s ease;
        }

        .clickable-number {
            cursor: pointer;
        }

        .clickable-number:hover {
            text-decoration: underline;
        }

        .back-to-top {
            position: fixed;
            right: 1.25rem;
            bottom: 1.25rem;
            border: 1px solid var(--border);
            background: #fff;
            color: var(--text-secondary);
            padding: 0.45rem 0.7rem;
            font-size: 0.7rem;
            cursor: pointer;
            box-shadow: 0 6px 16px var(--shadow);
            z-index: 20;
            transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
        }

        .back-to-top:hover {
            background: #2f2f2f;
            color: #fff;
            border-color: #2f2f2f;
        }

        .epic-title {
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
        }

        .epic-title-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .epic-link {
            display: inline-flex;
            align-items: baseline;
            gap: 0.45rem;
            color: inherit;
            text-decoration: none;
        }

        .epic-link:hover {
            text-decoration: underline;
            text-decoration-thickness: 1px;
            text-underline-offset: 3px;
        }

        .epic-name {
            font-weight: 600;
        }

        .epic-key {
            font-family: 'IBM Plex Mono', monospace;
            color: var(--text-secondary);
            font-size: 0.9rem;
            letter-spacing: 0.02em;
        }

        .epic-icon,
        .story-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .epic-icon svg {
            width: 18px;
            height: 18px;
        }

        .story-icon svg {
            width: 16px;
            height: 16px;
        }

        .epic-title small {
            font-family: 'IBM Plex Mono', monospace;
            color: var(--text-secondary);
            letter-spacing: 0.05em;
        }

	        .epic-meta {
	            font-family: 'IBM Plex Mono', monospace;
	            color: var(--text-secondary);
	            text-transform: uppercase;
	            letter-spacing: 0.05em;
	            display: flex;
	            align-items: center;
	            gap: 0.65rem;
	        }

	        .epic-assignee {
	            text-transform: none;
	            letter-spacing: 0;
	        }

        .team-group {
            margin-bottom: 1rem;
        }

        .team-heading {
            font-family: 'IBM Plex Mono', monospace;
            color: #2f54eb;
            margin-bottom: 0.5rem;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .task-meta > span:not(.task-status) {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }


        .task-updated {
            color: var(--text-secondary);
        }

        .task-status {
            padding: 0.2rem 0.6rem;
            border-radius: 2px;
            font-weight: 500;
        }

        .task-status.killed {
            background: #595959;
            color: white;
        }

        .task-status.done {
            background: #52c41a;
            color: white;
        }

        .task-status.in-progress {
            background: #69c0ff;
            color: white;
        }

        .task-status.to-do {
            background: #597ef7;
            color: white;
        }

        .task-status.blocked {
            background: #ff4d4f;
            color: white;
        }

        .task-status.accepted {
            background: #597ef7;
            color: white;
        }

        .task-status.pending {
            background: #597ef7;
            color: white;
        }

        .task-status.postponed {
            background: #fa8c16;
            color: white;
        }

        .loading {
            text-align: center;
            padding: 4rem 0;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--text-secondary);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        .error {
            background: #fff2e8;
            border: 1px solid #ffbb96;
            padding: 1.5rem;
            margin-bottom: 2rem;
            color: var(--accent);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.875rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 0.6rem;
            text-align: center;
            animation: slideUp 0.6s ease-out both;
            cursor: pointer;
            transition: all 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(89, 126, 247, 0.2);
            background: #f6f8ff;
            border-color: #91a7ff;
        }

        .stat-card.active {
            border-color: #597ef7;
            box-shadow: 0 0 0 2px rgba(89, 126, 247, 0.25);
            background: #f0f5ff;
        }

        .stat-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
            pointer-events: none;
        }

        .stat-card:nth-child(1) { animation-delay: 0.5s; }
        .stat-card:nth-child(2) { animation-delay: 0.6s; }
        .stat-card:nth-child(3) { animation-delay: 0.7s; }
        .stat-card:nth-child(4) { animation-delay: 0.8s; }
        .stat-card:nth-child(5) { animation-delay: 0.9s; }
        .stat-card:nth-child(6) { animation-delay: 1s; }

        .stat-value {
            font-size: 1.35rem;
            font-weight: 300;
            color: var(--accent);
            line-height: 1;
            margin-bottom: 0.25rem;
        }

        .stat-card.total .stat-value {
            color: var(--text-primary);
        }

        .stat-card.done .stat-value {
            color: #52c41a;
        }

        .stat-card.in-progress .stat-value {
            color: #597ef7;
        }

        .stat-card.todo-accepted .stat-value {
            color: #9254de;
        }

        .stat-card.high-priority .stat-value {
            color: #d4380d;
        }

        .stat-card.minor .stat-value {
            color: #64748b;
        }

        .stat-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state h2 {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 1rem;
        }

        /* Planning Styles */
        .planning-button {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: 0;
        }

        .planning-button:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--border);
            box-shadow: 0 6px 14px rgba(22, 22, 22, 0.12);
            transform: none;
        }

        .planning-button.active {
            background: var(--text-primary);
            color: var(--bg-primary);
        }

        .planning-button svg {
            width: 0.75rem;
            height: 0.75rem;
            transition: transform 0.3s;
        }

        .planning-button.active svg {
            transform: rotate(180deg);
        }

        .planning-panel {
            background: transparent;
            border: 1px solid transparent;
            margin-top: 0;
            margin-bottom: 0;
            overflow: hidden;
            max-height: 0;
            padding: 0;
            opacity: 0;
            transition: max-height 0.6s ease, opacity 0.6s ease, padding 0.6s ease, margin 0.6s ease, border-color 0.6s ease, background 0.6s ease;
        }

        .planning-panel.open {
            background: var(--bg-secondary);
            border-color: var(--border);
            max-height: 1600px;
            padding: 0.75rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
            opacity: 1;
            overflow: visible;
            position: sticky;
            top: 0.5rem;
            z-index: 4;
            box-shadow: 0 8px 24px rgba(26, 26, 26, 0.08);
        }

        .stats-panel {
            background: transparent;
            border: 1px solid transparent;
            margin-top: 0;
            margin-bottom: 0;
            overflow: hidden;
            max-height: 0;
            padding: 0;
            opacity: 0;
            transition: max-height 0.6s ease, opacity 0.6s ease, padding 0.6s ease, margin 0.6s ease, border-color 0.6s ease, background 0.6s ease;
        }

        .stats-panel.open {
            background: var(--bg-secondary);
            border-color: var(--border);
            max-height: 2000px;
            padding: 0.75rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
            opacity: 1;
            overflow: visible;
            box-shadow: 0 8px 24px rgba(26, 26, 26, 0.08);
        }

        .scenario-panel {
            background: transparent;
            border: 1px solid transparent;
            margin-top: 0;
            margin-bottom: 0;
            overflow: hidden;
            max-height: 0;
            padding: 0;
            opacity: 0;
            transition: max-height 0.6s ease, opacity 0.6s ease, padding 0.6s ease, margin 0.6s ease, border-color 0.6s ease, background 0.6s ease;
        }

        .scenario-panel.open {
            background: var(--bg-secondary);
            border-color: var(--border);
            max-height: 2400px;
            padding: 0;
            margin-top: 1rem;
            margin-bottom: 1rem;
            opacity: 1;
            overflow: visible;
            box-shadow: 0 8px 24px rgba(26, 26, 26, 0.08);
            border-radius: 0;
            box-sizing: border-box;
            width: 100%;
            max-width: none;
        }

        .scenario-fullbleed {
            width: 100vw;
            margin-left: calc(50% - 50vw);
            margin-right: calc(50% - 50vw);
            background: var(--bg-secondary);
            overflow-x: hidden;
        }

        .scenario-inner {
            max-width: none;
            padding: 1rem 1.5rem 1.25rem;
            box-sizing: border-box;
            width: 100%;
        }

        .scenario-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 0.8rem;
        }

        .scenario-title {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .scenario-beta {
            font-size: 0.6rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #b45309;
            background: rgba(251, 191, 36, 0.2);
            border: 1px solid rgba(251, 191, 36, 0.35);
            border-radius: 999px;
            padding: 0.05rem 0.35rem;
        }

        .scenario-subtitle {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .scenario-controls {
            display: flex;
            align-items: flex-end;
            gap: 0.6rem;
            margin-left: auto;
            flex-wrap: wrap;
        }

        .scenario-control label {
            display: block;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
            margin-bottom: 0.35rem;
            font-family: 'IBM Plex Mono', monospace;
        }

        .scenario-input {
            width: 100%;
            padding: 0.45rem 0.6rem;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-primary);
        }

        .scenario-toggle-group {
            display: flex;
            gap: 0.4rem;
        }

        .scenario-toggle {
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.7rem;
            padding: 0.35rem 0.6rem;
        }

        .scenario-toggle.active {
            background: var(--text-primary);
            color: var(--bg-primary);
        }

        .scenario-team-config,
        .scenario-team-header,
        .scenario-team-title,
        .scenario-team-defaults,
        .scenario-team-default-label,
        .scenario-team-grid,
        .scenario-team-grid-header,
        .scenario-team-name {
            display: none;
        }

        .scenario-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 0.75rem;
            margin-bottom: 0.9rem;
            width: 100%;
        }

        .scenario-card {
            border: 1px solid var(--border);
            border-radius: 0.6rem;
            padding: 0.7rem;
            background: #fff;
            box-shadow: 0 6px 16px rgba(26, 26, 26, 0.06);
        }

        .scenario-card h4 {
            margin: 0 0 0.35rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--text-secondary);
        }

        .scenario-card .scenario-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .scenario-timeline {
            --scenario-label-width: 190px;
            --scenario-axis-height: 26px;
            border: 1px solid var(--border);
            border-radius: 0.6rem;
            background: #fff;
            padding: 0.6rem;
            position: relative;
            max-height: 70vh;
            overflow: auto;
            width: 100%;
            margin: 0;
            box-sizing: border-box;
        }

        .scenario-axis {
            display: flex;
            justify-content: space-between;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            padding-left: var(--scenario-label-width);
            min-height: var(--scenario-axis-height);
            position: sticky;
            top: 0;
            background: #fff;
            z-index: 4;
            padding-top: 0.2rem;
            width: 100%;
            min-width: 0;
        }

        .scenario-lanes {
            position: relative;
            min-height: 120px;
            width: 100%;
            min-width: 0;
        }

        .scenario-lane {
            position: absolute;
            left: 0;
            right: 0;
            display: grid;
            grid-template-columns: var(--scenario-label-width) 1fr;
            align-items: stretch;
            gap: 0.6rem;
            min-width: 0;
            width: 100%;
        }

        .scenario-lane-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-primary);
            background: transparent;
            border: none;
            padding: 0.1rem 0;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
            cursor: pointer;
            min-width: 0;
            text-transform: none;
            letter-spacing: normal;
            margin-right: 0;
            border-radius: 0.45rem;
            transition: color 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
        }

        .scenario-lane-label:disabled {
            cursor: default;
            opacity: 0.7;
        }

        .scenario-lane-label:hover,
        .scenario-lane-label:focus-visible {
            background: rgba(59, 130, 246, 0.08);
            color: #0f172a;
            transform: none;
            box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.18);
        }

        .scenario-lane-title {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.7rem;
            min-width: 0;
        }

        .scenario-lane-title-text {
            flex: 1 1 auto;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .scenario-lane-key {
            font-size: 0.58rem;
            color: var(--text-secondary);
        }

        .scenario-lane-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.2rem;
            font-size: 0.58rem;
            color: var(--text-secondary);
        }

        .scenario-lane-capacity {
            border: none;
            border-radius: 0;
            padding: 0;
        }

        .scenario-lane-status.ok {
            color: var(--good);
            font-weight: 600;
        }

        .scenario-lane-status.risk,
        .scenario-lane-risk {
            color: #d4380d;
            font-weight: 600;
        }

        .scenario-lane-sp {
            color: var(--text-secondary);
        }

        .scenario-lane-more {
            color: var(--text-secondary);
            font-style: italic;
        }

        .scenario-lane-track {
            position: relative;
            min-height: 44px;
            background: rgba(26, 26, 26, 0.02);
            border-radius: 0.5rem;
            overflow: hidden;
            min-width: 0;
        }

        .scenario-bar {
            position: absolute;
            top: 6px;
            height: 32px;
            border-radius: 0.5rem;
            background: rgba(59, 130, 246, 0.16);
            border: 1px solid rgba(59, 130, 246, 0.4);
            display: flex;
            align-items: center;
            padding: 0.25rem 0.4rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.62rem;
            color: var(--text-primary);
            overflow: hidden;
            cursor: pointer;
            z-index: 2;
            text-decoration: none;
            min-width: 0;
        }

        .scenario-bar.critical {
            border-color: #cf1322;
            background: rgba(207, 19, 34, 0.16);
        }

        .scenario-bar.late {
            border-color: #d4380d;
            background: rgba(212, 56, 13, 0.16);
        }

        .scenario-bar.blocked {
            border-style: dashed;
            background: repeating-linear-gradient(
                135deg,
                rgba(212, 56, 13, 0.12),
                rgba(212, 56, 13, 0.12) 6px,
                rgba(212, 56, 13, 0.02) 6px,
                rgba(212, 56, 13, 0.02) 12px
            );
            padding-right: 0.75rem;
        }

        .scenario-bar.blocked::after {
            content: '';
            position: absolute;
            top: 4px;
            bottom: 4px;
            right: 4px;
            border-right: 2px dashed rgba(239, 68, 68, 0.85);
            pointer-events: none;
        }

        .scenario-bar.context {
            border-style: dashed;
            border-color: rgba(148, 163, 184, 0.6);
            background: rgba(148, 163, 184, 0.08);
            color: var(--text-secondary);
        }

        .scenario-bar.is-focused {
            outline: 2px solid rgba(59, 130, 246, 0.8);
            outline-offset: 2px;
        }

        .scenario-bar.is-upstream {
            background: rgba(239, 68, 68, 0.12);
            border-color: rgba(239, 68, 68, 0.5);
        }

        .scenario-bar.is-downstream {
            background: rgba(59, 130, 246, 0.12);
            border-color: rgba(59, 130, 246, 0.5);
        }

        .scenario-bar.flash {
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.35);
        }

        .scenario-bar.dimmed {
            opacity: 0.25;
            pointer-events: none;
        }

        .scenario-bar.search-match {
            box-shadow: 0 0 0 1px rgba(20, 184, 166, 0.5);
        }

        .scenario-bar.unscheduled {
            border-style: dotted;
            background: rgba(148, 163, 184, 0.12);
            color: var(--text-secondary);
        }

        .scenario-bar.excluded {
            border-style: dashed;
            border-color: rgba(148, 163, 184, 0.55);
            background: repeating-linear-gradient(
                135deg,
                rgba(148, 163, 184, 0.16),
                rgba(148, 163, 184, 0.16) 6px,
                rgba(148, 163, 184, 0.04) 6px,
                rgba(148, 163, 184, 0.04) 12px
            );
            color: var(--text-secondary);
        }

        .scenario-bar-inner {
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
            overflow: hidden;
            width: 100%;
            min-width: 0;
        }

        .scenario-bar-summary {
            font-size: 0.62rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .scenario-bar-meta {
            display: flex;
            gap: 0.35rem;
            align-items: center;
            color: var(--text-secondary);
            font-size: 0.58rem;
            white-space: nowrap;
        }

        .scenario-bar-key {
            font-weight: 600;
        }

        .scenario-badge {
            border: 1px solid rgba(148, 163, 184, 0.5);
            border-radius: 999px;
            padding: 0 0.3rem;
            font-size: 0.55rem;
            color: var(--text-secondary);
        }

        .scenario-epic-bar {
            position: absolute;
            border-radius: 0.6rem;
            background: rgba(20, 184, 166, 0.08);
            border: 1px solid rgba(20, 184, 166, 0.35);
            pointer-events: auto;
            overflow: hidden;
            padding: 0.2rem 0.4rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.58rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.3rem;
            z-index: 1;
            cursor: pointer;
            min-width: 0;
        }

        .scenario-epic-bar.excluded {
            border-style: dashed;
            border-color: rgba(148, 163, 184, 0.55);
            background: rgba(148, 163, 184, 0.08);
            color: var(--text-secondary);
        }

        .scenario-epic-bar-label {
            flex: 1 1 auto;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .scenario-quarter-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(239, 68, 68, 0.65);
            pointer-events: none;
            z-index: 1;
        }

        .scenario-deadline {
            position: absolute;
            top: 24px;
            bottom: 16px;
            width: 2px;
            background: rgba(212, 56, 13, 0.6);
            pointer-events: none;
            z-index: 2;
        }

        .scenario-deps {
            position: absolute;
            left: 0;
            top: 0;
            pointer-events: none;
            overflow: visible;
            z-index: 3;
        }

        .scenario-edge {
            stroke: rgba(148, 163, 184, 0.5);
            stroke-width: 1.4;
            fill: none;
        }

        .scenario-edge.active {
            stroke: rgba(59, 130, 246, 0.8);
            stroke-width: 2;
            opacity: 1;
        }

        .scenario-edge.context {
            opacity: 0.35;
        }

        .scenario-edge.faded {
            opacity: 0.15;
        }

        .scenario-edge.block {
            stroke: rgba(239, 68, 68, 0.7);
            stroke-dasharray: 4 3;
        }

        .scenario-epic-edge {
            stroke: rgba(20, 184, 166, 0.45);
            stroke-width: 2;
            fill: none;
        }

        .scenario-epic-edge-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.55rem;
            fill: var(--text-secondary);
        }

        .scenario-error {
            font-size: 0.75rem;
            color: #cf1322;
            margin-bottom: 0.6rem;
        }

        .scenario-loading {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.6rem;
        }

        .scenario-issues-list {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 0.4rem;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .scenario-link {
            color: var(--text-secondary);
            text-decoration: none;
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
            background: none;
            border: none;
            padding: 0.1rem 0.2rem;
            text-align: left;
            cursor: pointer;
            border-radius: 0.4rem;
            transition: color 0.15s ease, background 0.15s ease;
            text-transform: none;
            letter-spacing: normal;
            margin-right: 0;
        }

        .scenario-link:hover {
            text-decoration: none;
            color: #0f172a;
            background: rgba(16, 185, 129, 0.1);
            box-shadow: inset 0 0 0 1px rgba(16, 185, 129, 0.18);
            transform: none;
        }

        .scenario-link:focus-visible {
            text-decoration: none;
            color: #0f172a;
            background: rgba(16, 185, 129, 0.14);
            box-shadow: inset 0 0 0 1px rgba(16, 185, 129, 0.24);
            outline: none;
        }

        .scenario-link-key {
            font-size: 0.6rem;
            color: var(--text-secondary);
        }

        .scenario-focus-indicator {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-bottom: 0.4rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .scenario-focus-exit {
            background: none;
            border: none;
            padding: 0;
            font: inherit;
            color: inherit;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            min-width: 0;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .scenario-focus-exit span {
            flex: 1 1 auto;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
        }

        .scenario-tooltip {
            position: fixed;
            padding: 0.35rem 0.5rem;
            background: #2a2a2a;
            color: #f6f3ee;
            font-size: 0.6rem;
            line-height: 1.3;
            border-radius: 0.35rem;
            max-width: 280px;
            box-shadow: 0 12px 26px rgba(0, 0, 0, 0.22);
            border: 1px solid rgba(255, 255, 255, 0.12);
            opacity: 0;
            transform: translate(6px, 6px);
            transition: opacity 0.05s ease, transform 0.05s ease;
            pointer-events: none;
            z-index: 60;
            white-space: normal;
        }

        .scenario-tooltip.visible {
            opacity: 1;
            transform: translate(0, 0);
        }

        .scenario-tooltip-key {
            font-family: 'IBM Plex Mono', monospace;
            color: rgba(255, 255, 255, 0.75);
        }

        .scenario-tooltip-note {
            color: rgba(255, 255, 255, 0.7);
        }

        .stats-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 0.6rem;
            align-items: end;
            margin-bottom: 0.8rem;
        }

        .stats-control-group label {
            display: block;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
            margin-bottom: 0.3rem;
            font-family: 'IBM Plex Mono', monospace;
        }

        .stats-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 0.35rem;
        }

        .stats-actions button {
            width: 100%;
            min-height: 32px;
            padding: 0.4rem 0.6rem;
            font-size: 0.7rem;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .stats-card {
            background: #ffffff;
            border: 1px solid var(--border);
            border-radius: 0.6rem;
            padding: 0.75rem;
            box-shadow: 0 8px 18px rgba(29, 29, 29, 0.06);
        }

        .stats-card h4 {
            margin: 0 0 0.35rem;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--text-secondary);
            font-family: 'IBM Plex Mono', monospace;
        }

        .stats-card .stat-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .stats-note {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 0.4rem;
        }

        .stats-bars {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            gap: 0.75rem;
            align-items: start;
            margin-bottom: 0.5rem;
        }

        .stats-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.35rem;
        }

        .stats-bar-value {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .stats-bar-track {
            width: 100%;
            height: 140px;
            background: rgba(29, 122, 252, 0.08);
            border-radius: 0.6rem;
            position: relative;
            overflow: hidden;
        }

        .stats-bar-fill {
            width: 100%;
            background: linear-gradient(180deg, #1d7afc, #0bb5ff);
            border-radius: 0.6rem;
            position: absolute;
            left: 0;
            bottom: 0;
        }

        .stats-bar-fill.good {
            background: linear-gradient(180deg, #1d9a6c, #2cb67d);
        }

        .stats-bar-fill.warn {
            background: linear-gradient(180deg, #f59e0b, #f06b3b);
        }

        .stats-bar-fill.bad {
            background: linear-gradient(180deg, #ef4444, #f87171);
        }

        .stats-bar-fill.secondary {
            background: linear-gradient(180deg, #f06b3b, #f59e0b);
        }

        .stats-bar-fill.tech {
            background: linear-gradient(180deg, #2cb67d, #1d9a6c);
        }

        .stats-bar-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-align: center;
            max-width: 100%;
            line-height: 1.1;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stats-category {
            margin-top: 0.8rem;
        }

        .stats-category-title {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
            margin-bottom: 0.4rem;
        }

        .stats-view-toggle {
            display: inline-flex;
            gap: 0.4rem;
            margin: 0.6rem 0 0.8rem;
            flex-wrap: wrap;
        }

        .stats-view {
            opacity: 0;
            transform: translateY(6px);
            max-height: 0;
            overflow: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease, max-height 0.2s ease;
        }

        .stats-view.open {
            opacity: 1;
            transform: translateY(0);
            max-height: 2400px;
            pointer-events: auto;
        }

        .priority-radar {
            width: 100%;
            max-width: 500px;
            height: auto;
            margin: 0.2rem auto 0.6rem;
            display: block;
        }

        .priority-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem 1rem;
            justify-content: center;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 0.45rem;
        }

        .priority-axis-note {
            text-align: center;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-bottom: 0.8rem;
        }

        .priority-legend span {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            cursor: pointer;
        }

        .priority-legend i {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            display: inline-block;
        }

        .epic-stat-toggle {
            margin-left: 0.5rem;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            padding: 0.25rem 0.45rem;
            background: #fff;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .epic-stat-toggle.active {
            background: #111;
            color: #fff;
            border-color: #111;
        }

        .epic-stat-toggle svg {
            width: 0.75rem;
            height: 0.75rem;
        }

        .stats-toggle {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            padding: 0.3rem 0.7rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-family: 'IBM Plex Mono', monospace;
            transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
        }

        .stats-toggle.active {
            background: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
        }

        .stats-toggle:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--border);
            box-shadow: 0 6px 14px rgba(22, 22, 22, 0.12);
            transform: none;
        }

        .stats-card.selectable {
            cursor: pointer;
            transition: border-color 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease;
        }

        .stats-card.selectable:hover {
            border-color: var(--border);
            box-shadow: 0 6px 14px rgba(22, 22, 22, 0.12);
            transform: none;
        }

        .stats-card.active {
            border-color: #111;
            box-shadow: 0 10px 22px rgba(26, 26, 26, 0.12);
        }

        @media (min-width: 1200px) {
            .stats-bars {
                grid-template-columns: repeat(8, minmax(90px, 1fr));
            }
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7rem;
            font-family: 'IBM Plex Mono', monospace;
            border-top: 1px solid var(--border);
            margin-top: 0.6rem;
        }

        .stats-table th,
        .stats-table td {
            padding: 0.35rem 0.5rem;
            border-bottom: 1px dashed var(--border);
        }

        .stats-table th {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
        }

        .stats-table th.metric,
        .stats-table td.metric {
            text-align: right;
        }

        .stats-table th.dimension,
        .stats-table td.dimension {
            text-align: left;
        }

        .stats-table .stats-group-row th {
            border-bottom: 1px solid var(--border);
            font-size: 0.58rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
            text-align: center;
            padding-top: 0.5rem;
            padding-bottom: 0.4rem;
        }

        .stats-col.product {
            background: #fff7e6;
        }

        .stats-col.tech {
            background: #e6f7ff;
        }

        .stats-col.total {
            background: #f6ffed;
        }

        .capacity-panel {
            background: transparent;
            border: 1px solid transparent;
            padding: 0;
            margin: 0;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.6s ease, opacity 0.6s ease, padding 0.6s ease, margin 0.6s ease, border-color 0.6s ease, background 0.6s ease;
        }

        .capacity-panel.open {
            background: var(--bg-secondary);
            border-color: var(--border);
            padding: 0.75rem;
            margin: 1rem 0;
            max-height: 1600px;
            opacity: 1;
            overflow: visible;
            box-shadow: 0 8px 24px rgba(26, 26, 26, 0.08);
        }

        .capacity-grid-wrapper {
            max-height: 520px;
            overflow-y: auto;
            overflow-x: auto;
            padding-right: 0.25rem;
            padding-bottom: 0.25rem;
            -webkit-overflow-scrolling: touch;
        }

        .capacity-header {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .capacity-title {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
        }

        .capacity-subtitle {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .capacity-grid {
            display: grid;
            gap: 0.2rem;
            min-width: 860px;
        }

        .capacity-row {
            display: grid;
            grid-template-columns:
                minmax(160px, 1.4fr)
                minmax(112px, 0.6fr) minmax(70px, 0.5fr) minmax(70px, 0.5fr)
                minmax(112px, 0.6fr) minmax(70px, 0.5fr) minmax(70px, 0.5fr)
                minmax(112px, 0.6fr) minmax(70px, 0.5fr) minmax(70px, 0.5fr);
            align-items: center;
            padding: 0.08rem 0;
        }

        .capacity-group-row {
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.25rem;
            margin-bottom: 0.1rem;
        }

        .capacity-group-cell {
            grid-column: span 3;
            text-align: center;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
        }

        .capacity-group-cell.product {
            grid-column: 2 / span 3;
        }

        .capacity-group-cell.tech {
            grid-column: 5 / span 3;
        }

        .capacity-group-cell.total {
            grid-column: 8 / span 3;
        }

        .capacity-cell {
            padding: 0.3rem 0.4rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-primary);
        }

        .capacity-cell.metric {
            border-left: 1px solid var(--border);
            text-align: right;
        }

        .capacity-cell.product-col {
            background: #fff7e6;
        }

        .capacity-cell.tech-col {
            background: #e6f7ff;
        }

        .capacity-cell.total-col {
            background: #f6ffed;
        }

        .capacity-cell.divider-right {
            border-right: 2px solid var(--border);
        }

        .capacity-header-row .capacity-cell {
            font-size: 0.58rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .capacity-divider {
            border-top: 1px dashed var(--border);
        }

        .capacity-team {
            font-family: 'IBM Plex Mono', monospace;
            color: var(--text-primary);
        }


        .capacity-total {
            font-weight: 500;
        }

        .capacity-empty {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            padding: 0.25rem 0;
        }

        .capacity-scroll-hint {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-secondary);
            margin-top: 0.3rem;
            text-align: right;
        }

        .metric-value {
            font-weight: 600;
        }

        .metric-muted {
            color: var(--muted);
        }

        .metric-accepted {
            color: var(--good);
        }

        .metric-warn {
            color: var(--warn);
        }

        .postponed-cell {
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
        }

        .postponed-link {
            opacity: 0.6;
            font-size: 0.85em;
            text-decoration: none;
            color: inherit;
            transition: opacity 0.2s ease, color 0.2s ease;
        }

        .postponed-cell:hover .postponed-link {
            opacity: 1;
            color: var(--accent);
        }

        .todo-link {
            opacity: 0.6;
            font-size: 0.85em;
            text-decoration: none;
            color: inherit;
            transition: opacity 0.2s ease, color 0.2s ease;
        }

        .postponed-cell:hover .todo-link {
            opacity: 1;
            color: var(--accent);
        }

        .accepted-link {
            opacity: 0.6;
            font-size: 0.85em;
            text-decoration: none;
            color: inherit;
            transition: opacity 0.2s ease, color 0.2s ease;
        }

        .postponed-cell:hover .accepted-link {
            opacity: 1;
            color: var(--accent);
        }

        .stats-link {
            opacity: 0.6;
            font-size: 0.85em;
            text-decoration: none;
            color: inherit;
            transition: opacity 0.2s ease, color 0.2s ease;
        }

        .postponed-cell:hover .stats-link {
            opacity: 1;
            color: var(--accent);
        }

        .planning-stats {
            display: flex;
            gap: 0.85rem;
            align-items: center;
            justify-content: flex-start;
            font-family: 'IBM Plex Mono', monospace;
            flex-wrap: wrap;
            overflow: visible;
        }

        .planning-stats.compact {
            gap: 0.6rem;
            font-size: 0.65rem;
            justify-content: flex-start;
        }

        .planning-stats.compact .planning-stat-label {
            font-size: 0.62rem;
            letter-spacing: 0.04em;
        }

        .planning-stats.compact .planning-stat-value {
            font-size: 0.62rem;
        }

        .planning-stat-separator {
            margin-left: 0.4rem;
            color: var(--text-secondary);
        }

        .team-stats-grid {
            display: grid;
            grid-template-columns: repeat(6, minmax(140px, 1fr));
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        @media (max-width: 1100px) {
            .team-stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            }
        }

        .team-stat-card {
            background: #fff;
            border: 1px solid var(--border);
            padding: 0.5rem 0.6rem;
            text-align: left;
            box-shadow: 0 6px 16px var(--shadow);
        }

        .team-stat-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .team-stat-label {
            margin-bottom: 0.2rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
        }

        .team-stat-line {
            display: flex;
            align-items: baseline;
            gap: 0.35rem;
            flex-wrap: nowrap;
        }

        .team-stat-line .team-stat-value {
            font-size: 0.62rem;
            white-space: nowrap;
        }

        .project-card .team-stat-value {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .team-stat-line .team-stat-meta {
            margin-top: 0;
            white-space: nowrap;
            line-height: 1;
        }

        .team-stat-meta {
            margin-top: 0.2rem;
            font-size: 0.6rem;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--text-secondary);
        }

        .team-stat-value.muted {
            font-size: 0.62rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .uncheck-button {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            padding: 0.4rem 1rem;
            font-size: 0.7rem;
            margin: 0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .uncheck-button:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--border);
            box-shadow: 0 6px 14px rgba(22, 22, 22, 0.12);
            transform: none;
        }

        .uncheck-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .uncheck-button:disabled:hover {
            background: transparent;
            color: var(--text-secondary);
            border-color: var(--border);
        }

        .planning-action-button {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            padding: 0.4rem 1rem;
            font-size: 0.7rem;
            margin: 0;
            cursor: pointer;
            transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .planning-action-button:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--border);
            box-shadow: 0 6px 14px rgba(22, 22, 22, 0.12);
            transform: none;
        }

        .planning-action-button.active {
            background: #f6ffed;
            border-color: #b7eb8f;
            color: #389e0d;
        }

        .planning-action-button.active:hover {
            background: #f6ffed;
            color: #389e0d;
            border-color: #b7eb8f;
        }

        .planning-action-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .planning-action-button:disabled:hover {
            background: transparent;
            color: var(--text-secondary);
            border-color: var(--border);
        }

        .planning-action-button svg {
            width: 1rem;
            height: 1rem;
        }

        .planning-icon-button {
            width: 2.05rem;
            height: 2.05rem;
            padding: 0;
            border-radius: 999px;
            justify-content: center;
            gap: 0;
        }

        .planning-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: nowrap;
            white-space: nowrap;
        }

        .planning-stat {
            display: flex;
            align-items: baseline;
            gap: 0.35rem;
        }

        .planning-stat-label {
            font-size: 0.62rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .planning-stat-label[data-tooltip] {
            position: relative;
            cursor: help;
        }

        .planning-stat-label[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 0;
            top: 1.1rem;
            background: #111;
            color: #fff;
            font-size: 0.6rem;
            line-height: 1.2;
            padding: 0.35rem 0.45rem;
            border-radius: 0.3rem;
            white-space: normal;
            width: max-content;
            max-width: 220px;
            z-index: 20;
            text-transform: none;
            letter-spacing: normal;
            pointer-events: none;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        .planning-stat-note {
            margin-top: 0.2rem;
            font-size: 0.6rem;
            color: var(--text-secondary);
        }

        .planning-stat-value {
            font-size: 0.65rem;
            font-weight: 500;
            color: var(--text-primary);
            line-height: 1;
        }

        .planning-stat-value.over {
            color: #d4380d;
        }

        .planning-stat-value.under {
            color: #d4380d;
        }

        .task-checkbox-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .task-checkbox {
            width: 0.75rem;
            height: 0.75rem;
            min-width: 0.75rem;
            min-height: 0.75rem;
            cursor: pointer;
            appearance: none;
            border: 1.5px solid var(--border);
            border-radius: 2px;
            background: var(--bg-secondary);
            transition: all 0.2s;
            position: relative;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .task-checkbox:hover {
            border-color: var(--text-secondary);
        }

        .task-checkbox:checked {
            background: #52c41a;
            border-color: #52c41a;
        }

        .task-checkbox:checked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 0.55rem;
            font-weight: bold;
            line-height: 1;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const EMPTY_ARRAY = Object.freeze([]);
        const EMPTY_OBJECT = Object.freeze({});

        // Backend server URL
        const DEFAULT_BACKEND_PORT = 5050;
        const BACKEND_URL = window.BACKEND_URL ||
            (window.location.protocol.startsWith('http')
                ? `${window.location.protocol}//${window.location.hostname}:${DEFAULT_BACKEND_PORT}`
                : `http://localhost:${DEFAULT_BACKEND_PORT}`);

        // Get current quarter in format "2025Q1"
        function getCurrentQuarter() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth() + 1; // 1-12
            const quarter = Math.ceil(month / 3);
            return `${year}Q${quarter}`;
        }

        // Cookie helper functions
        function setCookie(name, value, days = 365) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = `${name}=${JSON.stringify(value)};expires=${expires.toUTCString()};path=/`;
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) {
                    try {
                        return JSON.parse(c.substring(nameEQ.length, c.length));
                    } catch (e) {
                        return null;
                    }
                }
            }
            return null;
        }

        const UI_PREFS_KEY = 'jira_dashboard_ui_prefs_v1';

        function loadUiPrefs() {
            try {
                const raw = window.localStorage.getItem(UI_PREFS_KEY);
                if (!raw) return null;
                const prefs = JSON.parse(raw);
                if (prefs && typeof prefs === 'object') {
                    prefs.showScenario = false;
                }
                return prefs;
            } catch (e) {
                return null;
            }
        }

        function saveUiPrefs(prefs) {
	            try {
	                window.localStorage.setItem(UI_PREFS_KEY, JSON.stringify(prefs));
	            } catch (e) {
	                // ignore
	            }
	        }

        function App() {
            const savedPrefsRef = useRef(loadUiPrefs() || {});
            const perfEnabled = React.useMemo(
                () => new URLSearchParams(window.location.search).has('perf'),
                []
            );
            const perfCountersRef = useRef({
                renders: 0,
                edgeRequests: 0,
                edgeFrames: 0,
                edgeComputes: 0,
                layoutReads: 0,
                scrollReads: 0,
                laneStacking: 0,
                statsBuild: 0
            });
            const perfLastRef = useRef({ ...perfCountersRef.current });
            const perfStateRef = useRef(null);
            const perfStateCountsRef = useRef({});
            const perfStateLastRef = useRef({});
            if (perfEnabled) {
                perfCountersRef.current.renders += 1;
            }
            const [productTasks, setProductTasks] = useState([]);
            const [techTasks, setTechTasks] = useState([]);
            const [loadedProductTasks, setLoadedProductTasks] = useState([]);
            const [loadedTechTasks, setLoadedTechTasks] = useState([]);
            const [tasksFetched, setTasksFetched] = useState(false);
            const [readyToCloseProductTasks, setReadyToCloseProductTasks] = useState([]);
            const [readyToCloseTechTasks, setReadyToCloseTechTasks] = useState([]);
            const [missingPlanningInfoTasks, setMissingPlanningInfoTasks] = useState([]);
            const [productEpicsInScope, setProductEpicsInScope] = useState([]);
            const [techEpicsInScope, setTechEpicsInScope] = useState([]);
            const [readyToCloseProductEpicsInScope, setReadyToCloseProductEpicsInScope] = useState([]);
            const [readyToCloseTechEpicsInScope, setReadyToCloseTechEpicsInScope] = useState([]);
            const [techLoaded, setTechLoaded] = useState(false);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');
            const [showKilled, setShowKilled] = useState(savedPrefsRef.current.showKilled ?? false);
            const [showDone, setShowDone] = useState(savedPrefsRef.current.showDone ?? true);
            const [showTech, setShowTech] = useState(savedPrefsRef.current.showTech ?? true);
            const [showProduct, setShowProduct] = useState(savedPrefsRef.current.showProduct ?? true);
            const [sprintName, setSprintName] = useState('Sprint');
            const [statusFilter, setStatusFilter] = useState(savedPrefsRef.current.statusFilter ?? null); // null = show all, 'in-progress', 'todo-accepted', 'done', 'high-priority'
            const [selectedSprint, setSelectedSprint] = useState(savedPrefsRef.current.selectedSprint ?? null); // Sprint ID
            const [availableSprints, setAvailableSprints] = useState([]);
            const [sprintsLoading, setSprintsLoading] = useState(true);
            const [groupsConfig, setGroupsConfig] = useState({ version: 1, groups: [], defaultGroupId: '' });
            const [groupsLoading, setGroupsLoading] = useState(true);
            const [groupsError, setGroupsError] = useState('');
            const [groupWarnings, setGroupWarnings] = useState([]);
            const [groupConfigSource, setGroupConfigSource] = useState('');
            const [activeGroupId, setActiveGroupId] = useState(null);
            const [showGroupDropdown, setShowGroupDropdown] = useState(false);
            const groupDropdownRef = useRef(null);
            const [showGroupManage, setShowGroupManage] = useState(false);
            const [groupDraft, setGroupDraft] = useState(null);
            const [groupDraftError, setGroupDraftError] = useState('');
            const [groupImportText, setGroupImportText] = useState('');
            const [groupSaving, setGroupSaving] = useState(false);
            const [groupQueryTemplateEnabled, setGroupQueryTemplateEnabled] = useState(false);
            const [jiraUrl, setJiraUrl] = useState('');
            const [selectedTasks, setSelectedTasks] = useState({});
            const [showPlanning, setShowPlanning] = useState(savedPrefsRef.current.showPlanning ?? false);
            const [showStats, setShowStats] = useState(savedPrefsRef.current.showStats ?? false);
            const [showScenario, setShowScenario] = useState(savedPrefsRef.current.showScenario ?? false);
            const [showDependencies, setShowDependencies] = useState(savedPrefsRef.current.showDependencies ?? false);
            const [searchQuery, setSearchQuery] = useState(savedPrefsRef.current.searchQuery ?? '');
            const [searchInput, setSearchInput] = useState(savedPrefsRef.current.searchQuery ?? '');
            const normalizeSelectedTeams = (value) => {
                if (Array.isArray(value)) {
                    return value.length ? value : ['all'];
                }
                if (typeof value === 'string' && value.trim()) {
                    return [value];
                }
                return ['all'];
            };
            const [selectedTeams, setSelectedTeams] = useState(
                normalizeSelectedTeams(savedPrefsRef.current.selectedTeams ?? savedPrefsRef.current.selectedTeam ?? 'all')
            );
            const [epicDetails, setEpicDetails] = useState({});
            const [planningOffset, setPlanningOffset] = useState(0);
            const planningPanelRef = useRef(null);
            const resolveStatsView = (value) => (value === 'teams' || value === 'priority') ? value : 'teams';
            const resolveStatsGraphMode = (value) => (value === 'weighted' || value === 'absolute') ? value : 'weighted';
            const [statsView, setStatsView] = useState(resolveStatsView(savedPrefsRef.current.statsView));
            const [statsGraphMode, setStatsGraphMode] = useState(resolveStatsGraphMode(savedPrefsRef.current.statsGraphMode));
            const [priorityHoverIndex, setPriorityHoverIndex] = useState(null);
            const [showTeamDropdown, setShowTeamDropdown] = useState(false);
            const teamDropdownRef = useRef(null);
            const [sprintSearch, setSprintSearch] = useState('');
            const [showSprintDropdown, setShowSprintDropdown] = useState(false);
            const sprintDropdownRef = useRef(null);
            const [capacityEnabled, setCapacityEnabled] = useState(false);
            const [capacityByTeam, setCapacityByTeam] = useState({});
            const [capacityLoading, setCapacityLoading] = useState(false);
            const [scenarioLoading, setScenarioLoading] = useState(false);
            const [scenarioError, setScenarioError] = useState('');
            const [scenarioData, setScenarioData] = useState(null);
            const [scenarioLaneMode, setScenarioLaneMode] = useState(savedPrefsRef.current.scenarioLaneMode ?? 'team');
            const scenarioTimelineRef = useRef(null);
            const [scenarioLayout, setScenarioLayout] = useState({ width: 0, height: 0 });
            const [scenarioCollapsedLanes, setScenarioCollapsedLanes] = useState({});
            const [scenarioHoverKey, setScenarioHoverKey] = useState(null);
            const [scenarioFlashKey, setScenarioFlashKey] = useState(null);
            const [scenarioScrollTop, setScenarioScrollTop] = useState(0);
            const [scenarioViewportHeight, setScenarioViewportHeight] = useState(0);
            const [scenarioEpicFocus, setScenarioEpicFocus] = useState(null);
            const [scenarioRangeOverride, setScenarioRangeOverride] = useState(null);
            const scenarioFocusRestoreRef = useRef(null);
            const scenarioSkipAutoCollapseRef = useRef(false);
            const scenarioTeamCollapseInitRef = useRef(false);
            const scenarioEdgeUpdatePendingRef = useRef(false);
            const scenarioEdgeFrameRef = useRef(null);
            const scenarioScrollFrameRef = useRef(null);
            const scenarioResizeFrameRef = useRef(null);
            const scenarioPendingScrollRef = useRef(null);
            const [scenarioTooltip, setScenarioTooltip] = useState({
                visible: false,
                x: 0,
                y: 0,
                summary: '',
                key: '',
                sp: null,
                note: ''
            });
            const scenarioTooltipRef = useRef(null);
            const scenarioTooltipAnchorRef = useRef(null);
            const scenarioIssueRefMap = useRef(new Map());
            const [scenarioEdgeRender, setScenarioEdgeRender] = useState({ width: 0, height: 0, paths: [] });
            const [dependencyData, setDependencyData] = useState({});
            const [dependencyFocus, setDependencyFocus] = useState(null);
            const [dependencyLookupCache, setDependencyLookupCache] = useState({});
            const [dependencyLookupLoading, setDependencyLookupLoading] = useState(false);
            const [excludedStatsEpics, setExcludedStatsEpics] = useState(savedPrefsRef.current.excludedStatsEpics ?? []);
            const [hideExcludedStats, setHideExcludedStats] = useState(savedPrefsRef.current.hideExcludedStats ?? true);
            const [showMissingAlert, setShowMissingAlert] = useState(savedPrefsRef.current.showMissingAlert ?? true);
            const [showBlockedAlert, setShowBlockedAlert] = useState(savedPrefsRef.current.showBlockedAlert ?? true);
            const [showEmptyEpicAlert, setShowEmptyEpicAlert] = useState(savedPrefsRef.current.showEmptyEpicAlert ?? true);
            const [showDoneEpicAlert, setShowDoneEpicAlert] = useState(savedPrefsRef.current.showDoneEpicAlert ?? true);
            const [dismissedAlertKeys, setDismissedAlertKeys] = useState([]);
            const [alertCelebrationPieces, setAlertCelebrationPieces] = useState([]);
            const alertDismissedRef = useRef(false);
            const alertPrevCountRef = useRef(0);
            const alertCelebrationTimeoutRef = useRef(null);
            const alertHighlightRef = useRef(null);
            const alertHighlightTimeoutRef = useRef(null);
            const [showBackToTop, setShowBackToTop] = useState(false);
            const epicOrderRef = useRef({});
            const epicOrderCounterRef = useRef(0);
            const epicRefMap = useRef(new Map());
            const groupStateRef = useRef(new Map());
            const restoringGroupRef = useRef(false);
            const activeGroupRef = useRef(null);
            const sprintFetchControllersRef = useRef(new Set());

            useEffect(() => {
                // Load config and sprints on component mount
                loadConfig();
                loadGroupsConfig();
                loadSprints();
            }, []);

            useEffect(() => {
                return () => {
                    abortSprintFetches();
                };
            }, [abortSprintFetches]);

            useEffect(() => {
                if (!showGroupManage) return;
                setGroupDraft(normalizeGroupsConfig(groupsConfig));
                setGroupDraftError('');
                setGroupImportText('');
            }, [showGroupManage, groupsConfig]);

            useEffect(() => {
                if (!perfEnabled) return;
                const interval = window.setInterval(() => {
                    const current = perfCountersRef.current;
                    const last = perfLastRef.current;
                    const snapshot = {
                        renders: current.renders - last.renders,
                        edgeRequests: current.edgeRequests - last.edgeRequests,
                        edgeFrames: current.edgeFrames - last.edgeFrames,
                        edgeComputes: current.edgeComputes - last.edgeComputes,
                        layoutReads: current.layoutReads - last.layoutReads,
                        scrollReads: current.scrollReads - last.scrollReads,
                        laneStacking: current.laneStacking - last.laneStacking,
                        statsBuild: (current.statsBuild || 0) - (last.statsBuild || 0)
                    };
                    perfLastRef.current = { ...current };
                    const stateChanges = perfStateCountsRef.current || {};
                    const lastStateChanges = perfStateLastRef.current || {};
                    const stateDiff = {};
                    Object.keys(stateChanges).forEach((key) => {
                        const diff = (stateChanges[key] || 0) - (lastStateChanges[key] || 0);
                        if (diff > 0) {
                            stateDiff[key] = diff;
                        }
                    });
                    perfStateLastRef.current = { ...stateChanges };
                    console.log('[perf] 5s delta', snapshot);
                    if (Object.keys(stateDiff).length) {
                        console.log('[perf] state changes', stateDiff);
                    }
                }, 5000);
                return () => window.clearInterval(interval);
            }, [perfEnabled]);

            useEffect(() => {
                if (!perfEnabled) return;
                const snapshot = {
                    activeGroupId,
                    selectedSprint,
                    selectedTeams: (selectedTeams || []).join('|'),
                    selectedTasksCount: Object.keys(selectedTasks || {}).length,
                    searchQuery,
                    searchInput,
                    showPlanning,
                    showStats,
                    showScenario,
                    showDependencies,
                    statusFilter,
                    loading,
                    sprintsLoading,
                    groupsLoading,
                    tasksFetched,
                    techLoaded,
                    showBackToTop,
                    planningOffset,
                    showGroupDropdown,
                    showTeamDropdown,
                    showSprintDropdown,
                    showGroupManage,
                    groupSaving,
                    sprintSearch,
                    priorityHoverIndex
                };
                const prev = perfStateRef.current || {};
                const counts = perfStateCountsRef.current || {};
                Object.keys(snapshot).forEach((key) => {
                    if (prev[key] !== snapshot[key]) {
                        counts[key] = (counts[key] || 0) + 1;
                    }
                });
                perfStateCountsRef.current = counts;
                perfStateRef.current = snapshot;
            }, [
                perfEnabled,
                activeGroupId,
                selectedSprint,
                selectedTeams,
                selectedTasks,
                searchQuery,
                searchInput,
                showPlanning,
                showStats,
                showScenario,
                showDependencies,
                statusFilter,
                loading,
                sprintsLoading,
                groupsLoading,
                tasksFetched,
                techLoaded,
                showBackToTop,
                planningOffset,
                showGroupDropdown,
                showTeamDropdown,
                showSprintDropdown,
                showGroupManage,
                groupSaving,
                sprintSearch,
                priorityHoverIndex
            ]);


            const normalizeStatus = (status) => {
                return (status || '').toLowerCase().replace(/\s+/g, ' ').trim();
            };

            const normalizeScenarioSummary = (summary) => {
                const text = String(summary || '').trim();
                if (!text) return '';
                return text.replace(/^issue\.\s*/i, '');
            };

            const normalizeGroupsConfig = (config) => {
                const rawGroups = Array.isArray(config?.groups) ? config.groups : [];
                const groups = rawGroups
                    .map(group => ({
                        id: String(group?.id || '').trim(),
                        name: String(group?.name || '').trim(),
                        teamIds: Array.isArray(group?.teamIds)
                            ? group.teamIds.map(id => String(id || '').trim()).filter(Boolean)
                            : []
                    }))
                    .filter(group => group.id && group.name);
                return {
                    version: Number(config?.version) || 1,
                    groups,
                    defaultGroupId: String(config?.defaultGroupId || '').trim()
                };
            };

            const resolveInitialGroupId = (config) => {
                if (!config?.groups?.length) return null;
                if (config.defaultGroupId && config.groups.some(group => group.id === config.defaultGroupId)) {
                    return config.defaultGroupId;
                }
                const defaultGroup = config.groups.find(group => group.name.toLowerCase() === 'default');
                if (defaultGroup) return defaultGroup.id;
                return config.groups[0].id;
            };

            const loadGroupsConfig = async () => {
                setGroupsLoading(true);
                setGroupsError('');
                try {
                    const response = await fetch(`${BACKEND_URL}/api/groups-config`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        cache: 'no-cache'
                    });
                    if (!response.ok) {
                        throw new Error(`Groups config error ${response.status}`);
                    }
                    const payload = await response.json();
                    const normalized = normalizeGroupsConfig(payload);
                    setGroupsConfig(normalized);
                    setGroupWarnings(payload.warnings || []);
                    setGroupConfigSource(payload.source || '');
                    setActiveGroupId(prev => {
                        if (prev && normalized.groups.some(group => group.id === prev)) {
                            return prev;
                        }
                        return resolveInitialGroupId(normalized);
                    });
                } catch (err) {
                    setGroupsError(err.message || 'Failed to load groups config.');
                } finally {
                    setGroupsLoading(false);
                }
            };

            const buildGroupId = (name, existingIds) => {
                const base = String(name || 'group')
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/(^-|-$)/g, '') || 'group';
                let candidate = base;
                let index = 1;
                while (existingIds.has(candidate)) {
                    candidate = `${base}-${index}`;
                    index += 1;
                }
                return candidate;
            };

            const parseTeamIdList = (raw) => {
                return String(raw || '')
                    .split(',')
                    .map(value => value.trim())
                    .filter(Boolean);
            };

            const handleGroupDraftChange = (updater) => {
                setGroupDraft(prev => {
                    if (!prev) return prev;
                    return updater(prev);
                });
            };

            const openGroupManage = () => {
                setShowGroupManage(true);
            };

            const closeGroupManage = () => {
                setShowGroupManage(false);
                setGroupDraftError('');
                setGroupImportText('');
            };

            const addGroupDraftRow = () => {
                handleGroupDraftChange(prev => {
                    const existingIds = new Set((prev.groups || []).map(group => group.id));
                    const nextId = buildGroupId('New Group', existingIds);
                    const nextGroup = { id: nextId, name: 'New Group', teamIds: [] };
                    return {
                        ...prev,
                        groups: [...(prev.groups || []), nextGroup]
                    };
                });
            };

            const updateGroupDraftName = (groupId, name) => {
                handleGroupDraftChange(prev => ({
                    ...prev,
                    groups: (prev.groups || []).map(group =>
                        group.id === groupId ? { ...group, name } : group
                    )
                }));
            };

            const updateGroupDraftTeams = (groupId, rawTeams) => {
                const teamIds = parseTeamIdList(rawTeams);
                handleGroupDraftChange(prev => ({
                    ...prev,
                    groups: (prev.groups || []).map(group =>
                        group.id === groupId ? { ...group, teamIds } : group
                    )
                }));
            };

            const removeGroupDraft = (groupId) => {
                handleGroupDraftChange(prev => {
                    const nextGroups = (prev.groups || []).filter(group => group.id !== groupId);
                    const nextDefault = prev.defaultGroupId === groupId ? '' : prev.defaultGroupId;
                    return {
                        ...prev,
                        groups: nextGroups,
                        defaultGroupId: nextDefault
                    };
                });
            };

            const toggleDefaultGroupDraft = (groupId) => {
                handleGroupDraftChange(prev => ({
                    ...prev,
                    defaultGroupId: prev.defaultGroupId === groupId ? '' : groupId
                }));
            };

            const saveGroupsConfig = async () => {
                if (!groupDraft) return;
                setGroupSaving(true);
                setGroupDraftError('');
                try {
                    const response = await fetch(`${BACKEND_URL}/api/groups-config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            version: groupDraft.version || 1,
                            groups: groupDraft.groups || [],
                            defaultGroupId: groupDraft.defaultGroupId || ''
                        })
                    });
                    if (!response.ok) {
                        const errorPayload = await response.json().catch(() => ({}));
                        const errorMessage = (errorPayload.errors || []).join(' ') || errorPayload.error || `Save failed (${response.status})`;
                        throw new Error(errorMessage);
                    }
                    const payload = await response.json();
                    const normalized = normalizeGroupsConfig(payload);
                    setGroupsConfig(normalized);
                    setGroupWarnings(payload.warnings || []);
                    setGroupConfigSource(payload.source || '');
                    setActiveGroupId(prev => {
                        if (prev && normalized.groups.some(group => group.id === prev)) {
                            return prev;
                        }
                        return resolveInitialGroupId(normalized);
                    });
                    closeGroupManage();
                } catch (err) {
                    setGroupDraftError(err.message || 'Failed to save groups.');
                } finally {
                    setGroupSaving(false);
                }
            };

            const exportGroupsConfig = async () => {
                const payload = {
                    version: groupsConfig.version || 1,
                    groups: groupsConfig.groups || [],
                    defaultGroupId: groupsConfig.defaultGroupId || ''
                };
                const json = JSON.stringify(payload, null, 2);
                if (navigator.clipboard && window.isSecureContext) {
                    try {
                        await navigator.clipboard.writeText(json);
                        return;
                    } catch (err) {
                        // fallback below
                    }
                }
                const temp = document.createElement('textarea');
                temp.value = json;
                document.body.appendChild(temp);
                temp.select();
                document.execCommand('copy');
                document.body.removeChild(temp);
            };

            const importGroupsConfig = () => {
                if (!groupImportText.trim()) return;
                try {
                    const parsed = JSON.parse(groupImportText);
                    const normalized = normalizeGroupsConfig(parsed);
                    if (!normalized.groups.length) {
                        throw new Error('Imported config has no groups.');
                    }
                    setGroupDraft(normalized);
                    setGroupDraftError('');
                    setGroupImportText('');
                } catch (err) {
                    setGroupDraftError(err.message || 'Invalid JSON.');
                }
            };

            const matchesScenarioSearch = (issue, query) => {
                if (!query) return true;
                const assigneeValue = issue?.assignee?.displayName || issue?.assignee?.name || issue?.assignee;
                const teamValue = issue?.team?.name || issue?.team;
                const tokens = [
                    issue?.summary,
                    issue?.key,
                    issue?.epicKey,
                    issue?.epicSummary,
                    teamValue,
                    assigneeValue
                ]
                    .filter(Boolean)
                    .map(value => String(value).toLowerCase());
                return tokens.some(value => value.includes(query));
            };

            const registerScenarioIssueRef = (issueKey) => (node) => {
                const map = scenarioIssueRefMap.current;
                if (node) {
                    map.set(issueKey, node);
                } else {
                    map.delete(issueKey);
                }
            };

            const registerSprintFetch = () => {
                const controller = new AbortController();
                sprintFetchControllersRef.current.add(controller);
                return controller;
            };

            const cleanupSprintFetch = (controller) => {
                if (!controller) return;
                sprintFetchControllersRef.current.delete(controller);
            };

            const abortSprintFetches = React.useCallback(() => {
                sprintFetchControllersRef.current.forEach(controller => {
                    try {
                        controller.abort();
                    } catch (err) {
                        // ignore abort errors
                    }
                });
                sprintFetchControllersRef.current.clear();
            }, []);

            const activeGroup = React.useMemo(() => {
                return (groupsConfig.groups || []).find(group => group.id === activeGroupId) || null;
            }, [groupsConfig, activeGroupId]);

            const activeGroupTeamIds = React.useMemo(() => {
                const seen = new Set();
                const ids = [];
                (activeGroup?.teamIds || []).forEach(teamId => {
                    const value = String(teamId || '').trim();
                    if (!value || seen.has(value)) return;
                    seen.add(value);
                    ids.push(value);
                });
                return ids;
            }, [activeGroup]);

            const activeGroupTeamSet = React.useMemo(() => new Set(activeGroupTeamIds), [activeGroupTeamIds]);

            const buildDefaultGroupState = (groupId) => {
                const selectedTasksCookie = groupId ? (getCookie(`selectedTasks_${groupId}`) || {}) : {};
                return {
                    sprintId: selectedSprint,
                    teamIdsSignature: activeGroupTeamIds.join('|'),
                    productTasks: [],
                    techTasks: [],
                    loadedProductTasks: [],
                    loadedTechTasks: [],
                    tasksFetched: false,
                    readyToCloseProductTasks: [],
                    readyToCloseTechTasks: [],
                    missingPlanningInfoTasks: [],
                    productEpicsInScope: [],
                    techEpicsInScope: [],
                    readyToCloseProductEpicsInScope: [],
                    readyToCloseTechEpicsInScope: [],
                    techLoaded: false,
                    error: '',
                    showKilled: savedPrefsRef.current.showKilled ?? false,
                    showDone: savedPrefsRef.current.showDone ?? true,
                    showTech: savedPrefsRef.current.showTech ?? true,
                    showProduct: savedPrefsRef.current.showProduct ?? true,
                    statusFilter: savedPrefsRef.current.statusFilter ?? null,
                    searchQuery: savedPrefsRef.current.searchQuery ?? '',
                    selectedTeams: normalizeSelectedTeams(savedPrefsRef.current.selectedTeams ?? savedPrefsRef.current.selectedTeam ?? 'all'),
                    selectedTasks: selectedTasksCookie,
                    showPlanning: savedPrefsRef.current.showPlanning ?? false,
                    showStats: savedPrefsRef.current.showStats ?? false,
                    showScenario: false,
                    showDependencies: savedPrefsRef.current.showDependencies ?? false,
                    epicDetails: {},
                    statsView: resolveStatsView(savedPrefsRef.current.statsView),
                    statsGraphMode: resolveStatsGraphMode(savedPrefsRef.current.statsGraphMode),
                    scenarioData: null,
                    scenarioError: '',
                    scenarioLaneMode: savedPrefsRef.current.scenarioLaneMode ?? 'team',
                    scenarioCollapsedLanes: {},
                    scenarioEpicFocus: null,
                    scenarioRangeOverride: null,
                    scenarioScrollTop: 0,
                    scenarioViewportHeight: 0,
                    scenarioHoverKey: null,
                    scenarioFlashKey: null,
                    scenarioLayout: { width: 0, height: 0 },
                    scenarioEdgeRender: { width: 0, height: 0, paths: [] },
                    scenarioTooltip: {
                        visible: false,
                        x: 0,
                        y: 0,
                        summary: '',
                        key: '',
                        sp: null,
                        note: ''
                    },
                    excludedStatsEpics: savedPrefsRef.current.excludedStatsEpics ?? [],
                    hideExcludedStats: savedPrefsRef.current.hideExcludedStats ?? true,
                    showMissingAlert: savedPrefsRef.current.showMissingAlert ?? true,
                    showBlockedAlert: savedPrefsRef.current.showBlockedAlert ?? true,
                    showEmptyEpicAlert: savedPrefsRef.current.showEmptyEpicAlert ?? true,
                    showDoneEpicAlert: savedPrefsRef.current.showDoneEpicAlert ?? true,
                    dismissedAlertKeys: [],
                    dependencyData: {},
                    dependencyFocus: null,
                    dependencyLookupCache: {},
                    dependencyLookupLoading: false
                };
            };

            const buildGroupStateSnapshot = () => ({
                sprintId: selectedSprint,
                teamIdsSignature: activeGroupTeamIds.join('|'),
                productTasks,
                techTasks,
                loadedProductTasks,
                loadedTechTasks,
                tasksFetched,
                readyToCloseProductTasks,
                readyToCloseTechTasks,
                missingPlanningInfoTasks,
                productEpicsInScope,
                techEpicsInScope,
                readyToCloseProductEpicsInScope,
                readyToCloseTechEpicsInScope,
                techLoaded,
                error,
                showKilled,
                showDone,
                showTech,
                showProduct,
                statusFilter,
                searchQuery,
                selectedTeams,
                selectedTasks,
                showPlanning,
                showStats,
                showScenario,
                showDependencies,
                epicDetails,
                statsView,
                statsGraphMode,
                scenarioData,
                scenarioError,
                scenarioLaneMode,
                scenarioCollapsedLanes,
                scenarioEpicFocus,
                scenarioRangeOverride,
                scenarioScrollTop,
                scenarioViewportHeight,
                scenarioHoverKey,
                scenarioFlashKey,
                scenarioLayout,
                scenarioEdgeRender,
                scenarioTooltip,
                excludedStatsEpics,
                hideExcludedStats,
                showMissingAlert,
                showBlockedAlert,
                showEmptyEpicAlert,
                showDoneEpicAlert,
                dismissedAlertKeys,
                dependencyData,
                dependencyFocus,
                dependencyLookupCache,
                dependencyLookupLoading
            });

            const applyGroupState = (state) => {
                const nextState = state || buildDefaultGroupState(activeGroupId);
                restoringGroupRef.current = true;
                scenarioIssueRefMap.current.clear();
                scenarioEdgeUpdatePendingRef.current = false;
                scenarioFocusRestoreRef.current = null;
                scenarioSkipAutoCollapseRef.current = false;
                scenarioTeamCollapseInitRef.current = false;
                if (scenarioEdgeFrameRef.current) {
                    window.cancelAnimationFrame(scenarioEdgeFrameRef.current);
                    scenarioEdgeFrameRef.current = null;
                }
                alertDismissedRef.current = false;
                alertPrevCountRef.current = 0;
                if (scenarioScrollFrameRef.current) {
                    window.cancelAnimationFrame(scenarioScrollFrameRef.current);
                    scenarioScrollFrameRef.current = null;
                }
                if (scenarioResizeFrameRef.current) {
                    window.cancelAnimationFrame(scenarioResizeFrameRef.current);
                    scenarioResizeFrameRef.current = null;
                }
                scenarioPendingScrollRef.current = null;
                epicRefMap.current = new Map();
                setProductTasks(nextState.productTasks || []);
                setTechTasks(nextState.techTasks || []);
                setLoadedProductTasks(nextState.loadedProductTasks || []);
                setLoadedTechTasks(nextState.loadedTechTasks || []);
                setTasksFetched(Boolean(nextState.tasksFetched));
                setReadyToCloseProductTasks(nextState.readyToCloseProductTasks || []);
                setReadyToCloseTechTasks(nextState.readyToCloseTechTasks || []);
                setMissingPlanningInfoTasks(nextState.missingPlanningInfoTasks || []);
                setProductEpicsInScope(nextState.productEpicsInScope || []);
                setTechEpicsInScope(nextState.techEpicsInScope || []);
                setReadyToCloseProductEpicsInScope(nextState.readyToCloseProductEpicsInScope || []);
                setReadyToCloseTechEpicsInScope(nextState.readyToCloseTechEpicsInScope || []);
                setTechLoaded(Boolean(nextState.techLoaded));
                setError(nextState.error || '');
                setShowKilled(nextState.showKilled ?? false);
                setShowDone(nextState.showDone ?? true);
                setShowTech(nextState.showTech ?? true);
                setShowProduct(nextState.showProduct ?? true);
                setStatusFilter(nextState.statusFilter ?? null);
                setSearchQuery(nextState.searchQuery ?? '');
                setSelectedTeams(normalizeSelectedTeams(nextState.selectedTeams));
                setSelectedTasks(nextState.selectedTasks || {});
                setShowPlanning(nextState.showPlanning ?? false);
                setShowStats(nextState.showStats ?? false);
                setShowScenario(nextState.showScenario ?? false);
                setShowDependencies(nextState.showDependencies ?? false);
                setEpicDetails(nextState.epicDetails || {});
                setStatsView(resolveStatsView(nextState.statsView));
                setStatsGraphMode(resolveStatsGraphMode(nextState.statsGraphMode));
                setScenarioData(nextState.scenarioData || null);
                setScenarioError(nextState.scenarioError || '');
                setScenarioLaneMode(nextState.scenarioLaneMode || 'team');
                setScenarioCollapsedLanes(nextState.scenarioCollapsedLanes || {});
                setScenarioEpicFocus(nextState.scenarioEpicFocus || null);
                setScenarioRangeOverride(nextState.scenarioRangeOverride || null);
                setScenarioScrollTop(nextState.scenarioScrollTop || 0);
                setScenarioViewportHeight(nextState.scenarioViewportHeight || 0);
                setScenarioHoverKey(nextState.scenarioHoverKey || null);
                setScenarioFlashKey(nextState.scenarioFlashKey || null);
                setScenarioLayout(nextState.scenarioLayout || { width: 0, height: 0 });
                setScenarioEdgeRender(nextState.scenarioEdgeRender || { width: 0, height: 0, paths: [] });
                setScenarioTooltip(nextState.scenarioTooltip || {
                    visible: false,
                    x: 0,
                    y: 0,
                    summary: '',
                    key: '',
                    sp: null,
                    note: ''
                });
                setExcludedStatsEpics(nextState.excludedStatsEpics || []);
                setHideExcludedStats(nextState.hideExcludedStats ?? true);
                setShowMissingAlert(nextState.showMissingAlert ?? true);
                setShowBlockedAlert(nextState.showBlockedAlert ?? true);
                setShowEmptyEpicAlert(nextState.showEmptyEpicAlert ?? true);
                setShowDoneEpicAlert(nextState.showDoneEpicAlert ?? true);
                setDismissedAlertKeys(nextState.dismissedAlertKeys || []);
                setAlertCelebrationPieces([]);
                setDependencyData(nextState.dependencyData || {});
                setDependencyFocus(nextState.dependencyFocus || null);
                setDependencyLookupCache(nextState.dependencyLookupCache || {});
                setDependencyLookupLoading(false);
                setLoading(false);
                setScenarioLoading(false);
                window.setTimeout(() => {
                    restoringGroupRef.current = false;
                }, 0);
            };

            const groupStateSnapshot = React.useMemo(() => buildGroupStateSnapshot(), [
                selectedSprint,
                activeGroupTeamIds.join('|'),
                productTasks,
                techTasks,
                loadedProductTasks,
                loadedTechTasks,
                tasksFetched,
                readyToCloseProductTasks,
                readyToCloseTechTasks,
                missingPlanningInfoTasks,
                productEpicsInScope,
                techEpicsInScope,
                readyToCloseProductEpicsInScope,
                readyToCloseTechEpicsInScope,
                techLoaded,
                error,
                showKilled,
                showDone,
                showTech,
                showProduct,
                statusFilter,
                searchQuery,
                selectedTeams,
                selectedTasks,
                showPlanning,
                showStats,
                showScenario,
                showDependencies,
                epicDetails,
                statsView,
                statsGraphMode,
                scenarioData,
                scenarioError,
                scenarioLaneMode,
                scenarioCollapsedLanes,
                scenarioEpicFocus,
                scenarioRangeOverride,
                scenarioScrollTop,
                scenarioViewportHeight,
                scenarioHoverKey,
                scenarioFlashKey,
                scenarioLayout,
                scenarioEdgeRender,
                scenarioTooltip,
                excludedStatsEpics,
                hideExcludedStats,
                showMissingAlert,
                showBlockedAlert,
                showEmptyEpicAlert,
                showDoneEpicAlert,
                dismissedAlertKeys,
                dependencyData,
                dependencyFocus,
                dependencyLookupCache,
                dependencyLookupLoading
            ]);

            useEffect(() => {
                if (!activeGroupId) return;
                if (activeGroupRef.current !== activeGroupId) return;
                groupStateRef.current.set(activeGroupId, groupStateSnapshot);
            }, [activeGroupId, groupStateSnapshot]);

            useEffect(() => {
                if (!activeGroupId) return;
                if (activeGroupRef.current === activeGroupId) return;
                activeGroupRef.current = activeGroupId;
                const cached = groupStateRef.current.get(activeGroupId);
                if (cached) {
                    applyGroupState(cached);
                } else {
                    const fallback = buildDefaultGroupState(activeGroupId);
                    groupStateRef.current.set(activeGroupId, fallback);
                    applyGroupState(fallback);
                }
                setShowGroupDropdown(false);
            }, [activeGroupId]);


            useEffect(() => {
                if (!showPlanning) {
                    setPlanningOffset(0);
                }
            }, [showPlanning]);

            useEffect(() => {
                if (showPlanning) {
                    setShowStats(false);
                    setShowScenario(false);
                }
            }, [showPlanning]);

            useEffect(() => {
                if (showPlanning && !isCompletedSprintSelected) {
                    includePlanningTasksByStatus(['Accepted', 'In Progress']);
                }
            }, [showPlanning, isCompletedSprintSelected]);

            useEffect(() => {
                if (!selectedSprint) return;
                if (!showSprintDropdown) return;
                const optionEl = sprintDropdownRef.current?.querySelector(`[data-sprint-id="${selectedSprint}"]`);
                if (!optionEl) return;
                if (optionEl.scrollIntoView) {
                    optionEl.scrollIntoView({ block: 'center' });
                }
            }, [showSprintDropdown, selectedSprint, filteredSprints?.length]);

            const resetSprintScopedState = React.useCallback(() => {
                abortSprintFetches();
                setDependencyData({});
                setDependencyFocus(null);
                setDependencyLookupCache({});
                setDependencyLookupLoading(false);
                setMissingPlanningInfoTasks([]);
                setScenarioData(null);
                setScenarioError('');
                setScenarioRangeOverride(null);
                setScenarioEpicFocus(null);
                scenarioIssueRefMap.current.clear();
                scenarioPendingScrollRef.current = null;
                scenarioEdgeUpdatePendingRef.current = false;
                scenarioTooltipAnchorRef.current = null;
                if (scenarioEdgeFrameRef.current) {
                    window.cancelAnimationFrame(scenarioEdgeFrameRef.current);
                    scenarioEdgeFrameRef.current = null;
                }
                setScenarioEdgeRender({ width: 0, height: 0, paths: [] });
                setScenarioHoverKey(null);
                setScenarioFlashKey(null);
                setScenarioTooltip(prev => (prev.visible ? { ...prev, visible: false } : prev));
            }, [abortSprintFetches]);

            useEffect(() => {
                if (!selectedSprint) return;
                resetSprintScopedState();
            }, [selectedSprint, resetSprintScopedState]);

            useEffect(() => {
                if (!selectedSprint) return;
                setTasksFetched(false);
            }, [selectedSprint]);

            useEffect(() => {
                if (showStats) {
                    setShowPlanning(false);
                    setShowScenario(false);
                }
            }, [showStats]);

            useEffect(() => {
                if (showScenario) {
                    setShowPlanning(false);
                    setShowStats(false);
                }
            }, [showScenario]);

            useEffect(() => {
                if (showScenario && !restoringGroupRef.current) {
                    setScenarioData(null);
                    setScenarioError('');
                }
            }, [showScenario]);

            useEffect(() => {
                if (showScenario) return;
                scenarioIssueRefMap.current.clear();
                scenarioEdgeUpdatePendingRef.current = false;
                if (scenarioEdgeFrameRef.current) {
                    window.cancelAnimationFrame(scenarioEdgeFrameRef.current);
                    scenarioEdgeFrameRef.current = null;
                }
                if (scenarioScrollFrameRef.current) {
                    window.cancelAnimationFrame(scenarioScrollFrameRef.current);
                    scenarioScrollFrameRef.current = null;
                }
                if (scenarioResizeFrameRef.current) {
                    window.cancelAnimationFrame(scenarioResizeFrameRef.current);
                    scenarioResizeFrameRef.current = null;
                }
                scenarioPendingScrollRef.current = null;
                setScenarioEdgeRender({ width: 0, height: 0, paths: [] });
                setScenarioHoverKey(null);
                setScenarioFlashKey(null);
                setScenarioTooltip(prev => (prev.visible ? { ...prev, visible: false } : prev));
                setScenarioLayout({ width: 0, height: 0 });
            }, [showScenario]);

            useEffect(() => {
                if (!capacityEnabled) {
                    setCapacityByTeam({});
                }
            }, [capacityEnabled]);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (!teamDropdownRef.current) return;
                    if (!teamDropdownRef.current.contains(event.target)) {
                        setShowTeamDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (!sprintDropdownRef.current) return;
                    if (!sprintDropdownRef.current.contains(event.target)) {
                        setShowSprintDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (!groupDropdownRef.current) return;
                    if (!groupDropdownRef.current.contains(event.target)) {
                        setShowGroupDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            useEffect(() => {
                const handle = window.setTimeout(() => {
                    setSearchQuery(searchInput);
                }, 200);
                return () => window.clearTimeout(handle);
            }, [searchInput]);

            useEffect(() => {
                if (searchInput !== searchQuery) {
                    setSearchInput(searchQuery || '');
                }
            }, [searchQuery]);

            useEffect(() => {
                const handleScroll = () => {
                    setShowBackToTop(window.scrollY > 120);
                };
                handleScroll();
                window.addEventListener('scroll', handleScroll, { passive: true });
                return () => window.removeEventListener('scroll', handleScroll);
            }, []);

            useEffect(() => {
                // Save selected tasks to cookie whenever they change
                if (!activeGroupId) return;
                setCookie(`selectedTasks_${activeGroupId}`, selectedTasks);
            }, [selectedTasks, activeGroupId]);

            useEffect(() => {
                saveUiPrefs({
                    selectedSprint,
                    selectedTeams,
                    showPlanning,
                    showStats,
                    showScenario,
                    showDependencies,
                    showTech,
                    showProduct,
                    showDone,
                    showKilled,
                    statusFilter,
                    searchQuery,
                    statsView,
                    statsGraphMode,
                    scenarioLaneMode,
                    excludedStatsEpics,
                    hideExcludedStats,
                    showMissingAlert,
                    showBlockedAlert,
                    showEmptyEpicAlert,
                    showDoneEpicAlert
                });
            }, [
                selectedSprint,
                selectedTeams,
                showPlanning,
                showStats,
                showScenario,
                showDependencies,
                showTech,
                showProduct,
                showDone,
                showKilled,
                statusFilter,
                searchQuery,
                statsView,
                statsGraphMode,
                scenarioLaneMode,
                excludedStatsEpics,
                hideExcludedStats,
                showMissingAlert,
                showBlockedAlert,
                showEmptyEpicAlert,
                showDoneEpicAlert
            ]);

            const loadConfig = async () => {
                try {
                    const response = await fetch(`${BACKEND_URL}/api/config`);
                    if (response.ok) {
                        const config = await response.json();
                        setJiraUrl(config.jiraUrl || '');
                        setCapacityEnabled(Boolean(config.capacityProject));
                        setGroupQueryTemplateEnabled(Boolean(config.groupQueryTemplateEnabled));
                    }
                } catch (err) {
                    console.error('Failed to load config:', err);
                }
            };

            useEffect(() => {
                // Load tasks when sprint changes (team is filtered client-side)
                if (selectedSprint === null || !activeGroupId) {
                    return;
                }
                const cached = groupStateRef.current.get(activeGroupId);
                if (
                    cached &&
                    cached.sprintId === selectedSprint &&
                    cached.teamIdsSignature === activeGroupTeamIds.join('|') &&
                    cached.tasksFetched
                ) {
                    return;
                }
                setEpicDetails({});
                setProductEpicsInScope([]);
                setTechEpicsInScope([]);
                setMissingPlanningInfoTasks([]);
                loadProductTasks();
                loadTechTasks();
                fetchMissingPlanningInfo(selectedSprint);
            }, [selectedSprint, activeGroupId, activeGroupTeamIds.join('|')]);

            const fetchMissingPlanningInfo = async (sprintId) => {
                const controller = registerSprintFetch();
                try {
                    if (!sprintId) return;
                    if (activeGroupId && activeGroupTeamIds.length === 0) {
                        setMissingPlanningInfoTasks([]);
                        return;
                    }
                    const params = new URLSearchParams({ sprint: String(sprintId), t: Date.now().toString() });
                    if (activeGroupTeamIds.length) {
                        params.set('teamIds', activeGroupTeamIds.join(','));
                    }
                    const response = await fetch(`${BACKEND_URL}/api/missing-info?${params.toString()}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        cache: 'no-cache',
                        signal: controller.signal
                    });
	                    if (!response.ok) return;
	                    const data = await response.json();
	                    setMissingPlanningInfoTasks(data.issues || []);
	                } catch (e) {
                        if (e.name === 'AbortError') return;
	                    // ignore (alerts are best-effort)
	                } finally {
                        cleanupSprintFetch(controller);
                    }
	            };

            useEffect(() => {
                setTechLoaded(false);
            }, [selectedSprint]);

            useEffect(() => {
                epicOrderRef.current = {};
                epicOrderCounterRef.current = 0;
            }, [selectedSprint]);

            useEffect(() => {
                setScenarioData(null);
                setScenarioError('');
            }, [selectedSprint, selectedTeams]);


            const loadSprints = async (forceRefresh = false) => {
                setSprintsLoading(true);
                try {
                    const params = new URLSearchParams({
                        t: Date.now().toString()
                    });
                    if (forceRefresh) {
                        params.append('refresh', 'true');
                    }
                    const response = await fetch(`${BACKEND_URL}/api/sprints?${params}`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        cache: 'no-cache'
                    });

                    if (!response.ok) {
                        throw new Error(`Error ${response.status}`);
                    }

                    const data = await response.json();
                    const sprints = data.sprints || [];
                    setAvailableSprints(sprints);

                    const preferredSprintId = savedPrefsRef.current.selectedSprint;
                    const preferredSprint = preferredSprintId ? sprints.find(s => String(s.id) === String(preferredSprintId)) : null;

                    if (preferredSprint) {
                        setSelectedSprint(preferredSprint.id);
                        setSprintName(preferredSprint.name);
                    } else {
                        // Auto-select current quarter if available
                        const currentQuarter = getCurrentQuarter();
                        const currentSprint = sprints.find(s => s.name === currentQuarter);
                        if (currentSprint) {
                            setSelectedSprint(currentSprint.id);
                            setSprintName(currentSprint.name);
                        } else if (sprints.length > 0) {
                            // If current quarter not found, select the last sprint
                            const lastSprint = sprints[sprints.length - 1];
                            setSelectedSprint(lastSprint.id);
                            setSprintName(lastSprint.name);
                        }
                    }

                    console.log(' Loaded sprints:', sprints);
                } catch (err) {
                    console.error('Failed to load sprints:', err);
                    setError(`Failed to load sprints: ${err.message}`);
                } finally {
                    setSprintsLoading(false);
                }
            };

            const priorityOrder = {
                'Blocker': 1,
                'Highest': 1,
                'Critical': 2,
                'High': 2,
                'Major': 3,
                'Medium': 3,
                'Minor': 4,
                'Low': 4,
                'Trivial': 5,
                'Lowest': 5
            };

            const fetchCapacity = async (sprintName) => {
                if (!capacityEnabled || !sprintName) return;
                setCapacityLoading(true);
                try {
                    const teams = capacityTeamNames;
                    const params = new URLSearchParams({
                        sprint: sprintName,
                        t: Date.now().toString()
                    });
                    if (teams.length) {
                        params.append('teams', teams.join(','));
                    }
                    const response = await fetch(`${BACKEND_URL}/api/capacity?${params.toString()}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        cache: 'no-cache'
                    });
                    if (!response.ok) {
                        setCapacityByTeam({});
                        return;
                    }
                    const data = await response.json();
                    if (!data?.enabled) {
                        setCapacityByTeam({});
                        return;
                    }
                    const normalized = {};
                    Object.entries(data.capacities || {}).forEach(([name, value]) => {
                        const key = normalizeCapacityKey(name);
                        const numeric = Number(value);
                        if (!key || Number.isNaN(numeric)) return;
                        normalized[key] = numeric;
                    });
                    setCapacityByTeam(normalized);
                } catch (err) {
                    setCapacityByTeam({});
                } finally {
                    setCapacityLoading(false);
                }
            };

            const priorityAxis = ['Blocker', 'Critical', 'Major', 'Minor', 'Low', 'Trivial'];
            const priorityLabelByKey = {
                blocker: 'Blocker',
                critical: 'Critical',
                major: 'Major',
                minor: 'Minor',
                low: 'Low',
                trivial: 'Trivial'
            };
            const radarPalette = [
                '#2563eb',
                '#0ea5e9',
                '#14b8a6',
                '#10b981',
                '#22c55e',
                '#84cc16',
                '#eab308',
                '#f59e0b',
                '#f97316',
                '#a855f7',
                '#6366f1',
                '#64748b'
            ];

            const hashTeamId = (value) => {
                const str = String(value || '');
                let hash = 5381;
                for (let i = 0; i < str.length; i += 1) {
                    hash = ((hash << 5) + hash) + str.charCodeAt(i);
                }
                return Math.abs(hash);
            };

            const resolveTeamColor = (teamId) => {
                if (!radarPalette.length) return '#94a3b8';
                const index = hashTeamId(teamId) % radarPalette.length;
                return radarPalette[index];
            };

            const getTeamInfo = (task) => {
                const team = task.fields?.team;
                const teamName = task.fields?.teamName || team?.name || team?.displayName || team?.teamName || 'Unknown Team';
                const teamId = task.fields?.teamId || team?.id || team?.teamId || team?.key || teamName;
                return { id: teamId, name: teamName };
            };

            const getEpicTeamInfo = (epic) => {
                const teamName = epic?.teamName || epic?.team?.name || epic?.team?.displayName || 'Unknown Team';
                const teamId = epic?.teamId || epic?.team?.id || teamName;
                return { id: teamId, name: teamName };
            };

            const groupTasksByTeam = (tasks) => {
                const groups = new Map();
                (tasks || []).forEach(task => {
                    const teamName = getTeamInfo(task).name;
                    const items = groups.get(teamName) || [];
                    items.push(task);
                    groups.set(teamName, items);
                });
                return Array.from(groups.entries()).map(([teamName, items]) => ({ teamName, items }));
            };

            const filterTasksForActiveGroup = (items) => {
                if (!activeGroupTeamIds.length) return [];
                return (items || []).filter(task => activeGroupTeamSet.has(getTeamInfo(task).id));
            };

            const fetchTasks = async (project, options = {}) => {
                const useLoading = options.useLoading !== false;
                const setErrors = options.setErrorOnFailure !== false;
                if (useLoading) {
                    setLoading(true);
                }
                if (setErrors && options.clearError !== false) {
                    setError('');
                }

                const controller = registerSprintFetch();
                try {
                    const sprintParam = options.sprintOverride !== undefined ? options.sprintOverride : (selectedSprint || '');
                    const groupTeamIds = activeGroupTeamIds;
                    const useGroupTemplate = groupQueryTemplateEnabled && groupTeamIds.length > 0;
                    // Add cache busting parameter and sprint parameter
                    const params = new URLSearchParams({
                        t: Date.now().toString(),
                        sprint: sprintParam,
                        // always pull all teams; filtering happens client-side so capacity table can show every team
                        team: 'all',
                        project: project || 'all',
                        groupId: activeGroupId || ''
                    });
                    if (useGroupTemplate) {
                        params.set('teamIds', groupTeamIds.join(','));
                    }
                    const response = await fetch(`${BACKEND_URL}/api/tasks-with-team-name?${params}`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        cache: 'no-cache',
                        signal: controller.signal
                    });

                    console.log('Response status:', response.status);
                    console.log('Response ok:', response.ok);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ 
                            error: `HTTP ${response.status}` 
                        }));
                        console.error('Error data:', errorData);
                        throw new Error(errorData.error || `Error ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('Success! Received data:', data);

                    // Sort by priority
                    const sortedTasks = (data.issues || []).sort((a, b) => {
                        const priorityA = priorityOrder[a.fields.priority?.name] || 999;
                        const priorityB = priorityOrder[b.fields.priority?.name] || 999;
                        return priorityA - priorityB;
                    });

                    const filteredTasks = filterTasksForActiveGroup(sortedTasks);
                    const filteredEpicsInScope = activeGroupTeamIds.length
                        ? (data.epicsInScope || []).filter(epic => epic?.teamId && activeGroupTeamSet.has(epic.teamId))
                        : [];
                    const epicKeys = new Set(
                        filteredTasks
                            .map(task => task.fields?.epicKey)
                            .filter(Boolean)
                    );
                    const filteredEpics = {};
                    Object.entries(data.epics || {}).forEach(([key, epic]) => {
                        if (epicKeys.has(key)) {
                            filteredEpics[key] = epic;
                        }
                    });

	                    if (options.updateEpics !== false) {
	                        setEpicDetails(prev => ({ ...prev, ...filteredEpics }));
	                        if (project === 'product') {
	                            setProductEpicsInScope(filteredEpicsInScope);
	                        } else if (project === 'tech') {
	                            setTechEpicsInScope(filteredEpicsInScope);
	                        }
	                    }
	                    if (options.epicsInScopeSetter) {
	                        options.epicsInScopeSetter(filteredEpicsInScope);
	                    }
	                    return filteredTasks;
                } catch (err) {
                    if (err.name === 'AbortError') {
                        return [];
                    }
                    if (setErrors) {
                        const errorMsg = `Failed to load tasks: ${err.message}. Make sure the Python server is running on ${BACKEND_URL}`;
                        setError(errorMsg);
                    }
                    console.error('Full error details:', err);
                    return [];
                } finally {
                    cleanupSprintFetch(controller);
                    if (useLoading) {
                        setLoading(false);
                    }
                }
            };

            const loadProductTasks = async () => {
                if (activeGroupId && activeGroupTeamIds.length === 0) {
                    setProductTasks([]);
                    setLoadedProductTasks([]);
                    setTasksFetched(true);
                    return;
                }
                const data = await fetchTasks('product');
                setProductTasks(data);
                setLoadedProductTasks(data);
                setTasksFetched(true);
            };

            const loadTechTasks = async () => {
                if (activeGroupId && activeGroupTeamIds.length === 0) {
                    setTechTasks([]);
                    setLoadedTechTasks([]);
                    setTechLoaded(true);
                    setTasksFetched(true);
                    return;
                }
                const data = await fetchTasks('tech');
                setTechTasks(data);
                setLoadedTechTasks(data);
                setTechLoaded(true);
                setTasksFetched(true);
            };

            const fetchDependencies = async (keys) => {
                if (!keys.length) {
                    setDependencyData({});
                    return;
                }
                const controller = registerSprintFetch();
                try {
                    const response = await fetch(`${BACKEND_URL}/api/dependencies`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ keys }),
                        signal: controller.signal
                    });
                    if (!response.ok) {
                        console.error('Dependencies fetch failed:', response.status);
                        return;
                    }
                    const data = await response.json();
                    setDependencyData(data.dependencies || {});
                } catch (err) {
                    if (err.name === 'AbortError') return;
                    console.error('Dependencies fetch error:', err);
                } finally {
                    cleanupSprintFetch(controller);
                }
            };

            const parseScenarioDate = (value) => {
                if (!value) return null;
                return new Date(`${value}T00:00:00`);
            };

            const buildScenarioPayload = () => {
                return {
                    config: {
                        lane_mode: scenarioLaneMode
                    },
                    filters: {
                        sprint: selectedSprintInfo?.name || selectedSprint || null,
                        teams: scenarioTeamIds
                    }
                };
            };

            const runScenario = async () => {
                if (!selectedSprint) {
                    setScenarioError('Select a sprint to build a scenario.');
                    return;
                }
                setScenarioLoading(true);
                setScenarioError('');
                const controller = registerSprintFetch();
                try {
                    const response = await fetch(`${BACKEND_URL}/api/scenario`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(buildScenarioPayload()),
                        signal: controller.signal
                    });
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || `Scenario error ${response.status}`);
                    }
                    const data = await response.json();
                    setScenarioData(data);
                } catch (err) {
                    if (err.name === 'AbortError') {
                        return;
                    }
                    setScenarioError(err.message || 'Failed to run scenario.');
                } finally {
                    cleanupSprintFetch(controller);
                    setScenarioLoading(false);
                }
            };

            const loadReadyToCloseProductTasks = async () => {
                if (activeGroupId && activeGroupTeamIds.length === 0) {
                    setReadyToCloseProductTasks([]);
                    setReadyToCloseProductEpicsInScope([]);
                    return;
                }
                const data = await fetchTasks('product', {
                    sprintOverride: '',
                    updateEpics: false,
                    epicsInScopeSetter: setReadyToCloseProductEpicsInScope,
                    useLoading: false,
                    setErrorOnFailure: false
                });
                setReadyToCloseProductTasks(data);
            };

            const loadReadyToCloseTechTasks = async () => {
                if (activeGroupId && activeGroupTeamIds.length === 0) {
                    setReadyToCloseTechTasks([]);
                    setReadyToCloseTechEpicsInScope([]);
                    return;
                }
                const data = await fetchTasks('tech', {
                    sprintOverride: '',
                    updateEpics: false,
                    epicsInScopeSetter: setReadyToCloseTechEpicsInScope,
                    useLoading: false,
                    setErrorOnFailure: false
                });
                setReadyToCloseTechTasks(data);
            };


            useEffect(() => {
                if (!activeGroupId) return;
                loadReadyToCloseProductTasks();
                loadReadyToCloseTechTasks();
            }, [activeGroupId, activeGroupTeamIds.join('|')]);


            const formatPercent = (value) => `${(value * 100).toFixed(2)}%`;

            const priorityWeights = {
                blocker: 0.4,
                critical: 0.3,
                major: 0.2,
                minor: 0.06,
                low: 0.03,
                trivial: 0.01
            };

            const priorityAliases = {
                highest: 'blocker',
                high: 'major',
                medium: 'minor',
                lowest: 'trivial'
            };

            const normalizePriority = (name) => {
                const key = String(name || '').toLowerCase().trim();
                return priorityAliases[key] || key;
            };

            const getPriorityLabel = (name) => {
                const key = normalizePriority(name);
                return priorityLabelByKey[key] || name;
            };

            const computePriorityWeighted = (priorities) => {
                const totals = { done: 0, incomplete: 0, killed: 0 };
                Object.entries(priorities || {}).forEach(([priorityName, counts]) => {
                    const normalized = normalizePriority(priorityName);
                    const weight = priorityWeights[normalized] || 0;
                    totals.done += weight * (counts.done || 0);
                    totals.incomplete += weight * (counts.incomplete || 0);
                    totals.killed += weight * (counts.killed || 0);
                });
                return totals;
            };

            const computeRate = (metrics) => {
                const done = metrics.done || 0;
                const incomplete = metrics.incomplete || 0;
                const denom = done + incomplete;
                return denom > 0 ? done / denom : 0;
            };

            const getRateClass = (rate) => {
                if (rate >= 1) return 'good';
                if (rate >= 0.6 && rate < 0.8) return 'warn';
                if (rate < 0.6) return 'bad';
                return '';
            };

            const normalizeCapacityKey = (name) => {
                if (!name) return '';
                return String(name)
                    .replace(/\u00a0/g, ' ')
                    .replace(/^\[archived\]\s*/i, '')
                    .replace(/^r&d\s+/i, '')
                    .replace(/^(product|tech)\s*-\s*/i, '')
                    .replace(/\s+/g, ' ')
                    .trim()
                    .toLowerCase();
            };

            const toCapacityShortName = (name) => {
                if (!name) return '';
                return String(name)
                    .replace(/\u00a0/g, ' ')
                    .replace(/^\[archived\]\s*/i, '')
                    .replace(/^r&d\s+/i, '')
                    .replace(/^(product|tech)\s*-\s*/i, '')
                    .replace(/\s+/g, ' ')
                    .trim();
            };

            const buildRadarPoints = ({ values, radius, center, maxValue, axes }) => {
                const count = axes.length;
                return axes.map((axis, index) => {
                    const value = Math.max(0, values[axis] || 0);
                    const ratio = maxValue > 0 ? value / maxValue : 0;
                    const angle = (Math.PI * 2 * index) / count - Math.PI / 2;
                    const r = ratio * radius;
                    const x = center + r * Math.cos(angle);
                    const y = center + r * Math.sin(angle);
                    return `${x.toFixed(2)},${y.toFixed(2)}`;
                }).join(' ');
            };

            const buildLocalStatsFromTasks = (taskList, excludedSet) => {
                const teams = {};
                const projectsSummary = {
                    product: { done: 0, incomplete: 0, killed: 0, priorities: {} },
                    tech: { done: 0, incomplete: 0, killed: 0, priorities: {} }
                };
                const totals = { done: 0, incomplete: 0, killed: 0 };
                const storyPointsTotals = { total: 0, done: 0, incomplete: 0, killed: 0 };

                const bumpPriority = (target, priorityName, bucket) => {
                    if (!target.priorities) target.priorities = {};
                    if (!target.priorities[priorityName]) {
                        target.priorities[priorityName] = { done: 0, incomplete: 0, killed: 0 };
                    }
                    target.priorities[priorityName][bucket] += 1;
                };

                const bumpPriorityPoints = (target, priorityName, points) => {
                    if (!target.priorityPoints) target.priorityPoints = {};
                    if (!target.priorityPoints[priorityName]) {
                        target.priorityPoints[priorityName] = 0;
                    }
                    target.priorityPoints[priorityName] += points;
                };

                (taskList || []).forEach(task => {
                    const epicKey = task.fields?.epicKey || 'NO_EPIC';
                    if (excludedSet?.has(epicKey)) {
                        return;
                    }
                    const status = normalizeStatus(task.fields?.status?.name);
                    const isKilled = status === 'killed';
                    const isDone = status === 'done';
                    const priorityName = task.fields?.priority?.name || 'Unspecified';
                    const pointsRaw = task.fields?.customfield_10004;
                    const pointsValue = Number(pointsRaw);
                    const storyPoints = Number.isFinite(pointsValue) ? pointsValue : 0;
                    storyPointsTotals.total += storyPoints;
                    const teamInfo = getTeamInfo(task);
                    const teamKey = teamInfo.id || teamInfo.name || 'unknown';
                    const projectBucket = String(task.key || '').startsWith('TECH-') ? 'tech' : 'product';

                    if (!teams[teamKey]) {
                        teams[teamKey] = {
                            id: teamInfo.id || teamKey,
                            name: teamInfo.name || teamKey,
                            done: 0,
                            incomplete: 0,
                            killed: 0,
                            priorities: {},
                            priorityPoints: {},
                            projects: {
                                product: { done: 0, incomplete: 0, killed: 0, priorities: {} },
                                tech: { done: 0, incomplete: 0, killed: 0, priorities: {} }
                            }
                        };
                    }

                    const teamEntry = teams[teamKey];
                    if (isKilled) {
                        teamEntry.killed += 1;
                        teamEntry.projects[projectBucket].killed += 1;
                        projectsSummary[projectBucket].killed += 1;
                        totals.killed += 1;
                        storyPointsTotals.killed += storyPoints;
                        bumpPriority(teamEntry, priorityName, 'killed');
                        bumpPriority(teamEntry.projects[projectBucket], priorityName, 'killed');
                        bumpPriority(projectsSummary[projectBucket], priorityName, 'killed');
                        return;
                    }

                    bumpPriorityPoints(teamEntry, priorityName, storyPoints);
                    if (isDone) {
                        teamEntry.done += 1;
                        teamEntry.projects[projectBucket].done += 1;
                        projectsSummary[projectBucket].done += 1;
                        totals.done += 1;
                        storyPointsTotals.done += storyPoints;
                        bumpPriority(teamEntry, priorityName, 'done');
                        bumpPriority(teamEntry.projects[projectBucket], priorityName, 'done');
                        bumpPriority(projectsSummary[projectBucket], priorityName, 'done');
                        return;
                    }

                    teamEntry.incomplete += 1;
                    teamEntry.projects[projectBucket].incomplete += 1;
                    projectsSummary[projectBucket].incomplete += 1;
                    totals.incomplete += 1;
                    storyPointsTotals.incomplete += storyPoints;
                    bumpPriority(teamEntry, priorityName, 'incomplete');
                    bumpPriority(teamEntry.projects[projectBucket], priorityName, 'incomplete');
                    bumpPriority(projectsSummary[projectBucket], priorityName, 'incomplete');
                });

                const sortedTeams = Object.values(teams).sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                return {
                    sprint: selectedSprintInfo?.name || '',
                    totals,
                    storyPoints: storyPointsTotals,
                    projects: projectsSummary,
                    teams: sortedTeams
                };
            };

	            const tasks = React.useMemo(
	                () => showTech ? [...productTasks, ...techTasks] : [...productTasks],
	                [showTech, productTasks, techTasks]
	            );
	            const capacityTasks = React.useMemo(
	                () => [...productTasks, ...techTasks],
	                [productTasks, techTasks]
	            );
	            const readyToCloseTasks = React.useMemo(
	                () => [...readyToCloseProductTasks, ...readyToCloseTechTasks],
	                [readyToCloseProductTasks, readyToCloseTechTasks]
	            );
	            const epicsInScope = React.useMemo(() => {
	                const seen = new Set();
	                const merged = [...productEpicsInScope, ...techEpicsInScope].filter(epic => {
	                    if (!epic?.key) return false;
	                    if (seen.has(epic.key)) return false;
	                    seen.add(epic.key);
	                    return true;
	                });
	                return merged;
	            }, [productEpicsInScope, techEpicsInScope]);
	            const readyToCloseEpicsInScope = React.useMemo(() => {
	                const seen = new Set();
	                const merged = [...readyToCloseProductEpicsInScope, ...readyToCloseTechEpicsInScope].filter(epic => {
	                    if (!epic?.key) return false;
	                    if (seen.has(epic.key)) return false;
	                    seen.add(epic.key);
	                    return true;
	                });
	                return merged;
	            }, [readyToCloseProductEpicsInScope, readyToCloseTechEpicsInScope]);
            const killedTasks = React.useMemo(
                () => tasks.filter(t => t.fields.status?.name === 'Killed'),
                [tasks]
            );
            const doneTasks = React.useMemo(
                () => tasks.filter(t => t.fields.status?.name === 'Done'),
                [tasks]
            );
            const techTasksCount = techTasks.length;
            const productTasksCount = productTasks.length;

            const teamOptions = React.useMemo(() => {
                const base = ['all', ...new Set(capacityTasks.map(t => getTeamInfo(t).id || 'unknown'))]
                    .map(id => ({
                        id,
                        name: id === 'all' ? 'All Teams' : getTeamInfo(capacityTasks.find(t => getTeamInfo(t).id === id) || {}).name
                    }))
                    .filter((team, index, arr) => arr.findIndex(t => t.id === team.id) === index);
                if (!activeGroupTeamIds.length) {
                    return base.length ? base : [{ id: 'all', name: 'All Teams' }];
                }
                return base.filter(team => team.id === 'all' || activeGroupTeamSet.has(team.id));
            }, [capacityTasks, activeGroupTeamIds, activeGroupTeamSet]);
            const teamNameById = React.useMemo(() => {
                const map = new Map();
                teamOptions.forEach(team => {
                    if (team.id && team.id !== 'all') {
                        map.set(team.id, team.name);
                    }
                });
                return map;
            }, [teamOptions]);

            const selectedSprintInfo = React.useMemo(() => {
                if (!selectedSprint) return null;
                return (availableSprints || []).find(sprint => String(sprint.id) === String(selectedSprint)) || null;
            }, [availableSprints, selectedSprint]);

            const filteredSprints = React.useMemo(() => {
                if (!sprintSearch.trim()) return availableSprints;
                const query = sprintSearch.trim().toLowerCase();
                return (availableSprints || []).filter(sprint => {
                    const nameMatch = String(sprint.name || '').toLowerCase().includes(query);
                    const state = (sprint.state || '').toLowerCase();
                    const stateLabel = state === 'closed' ? 'c' : state === 'active' ? 'a' : state === 'future' ? 'f' : '';
                    return nameMatch || stateLabel === query;
                });
            }, [availableSprints, sprintSearch]);
            const firstFutureSprintId = React.useMemo(() => {
                const future = (availableSprints || []).filter(sprint => (sprint.state || '').toLowerCase() === 'future');
                if (!future.length) return null;
                const ordered = [...future].sort((a, b) => {
                    const aTime = Date.parse(a.startDate || '');
                    const bTime = Date.parse(b.startDate || '');
                    if (!Number.isNaN(aTime) && !Number.isNaN(bTime)) {
                        return aTime - bTime;
                    }
                    return String(a.name || '').localeCompare(String(b.name || ''));
                });
                return ordered[0]?.id ?? null;
            }, [availableSprints]);
            const selectedSprintState = (selectedSprintInfo?.state || '').toLowerCase();
            const isCompletedSprintSelected = selectedSprintState === 'closed';
            const isFutureSprintSelected = selectedSprintState === 'future';
            const isFirstFutureSprintSelected = firstFutureSprintId
                && selectedSprint !== null
                && String(firstFutureSprintId) === String(selectedSprint);
            const selectedTeamSet = React.useMemo(() => new Set(selectedTeams.filter(id => id !== 'all')), [selectedTeams]);
            const isAllTeamsSelected = selectedTeams.includes('all') || selectedTeamSet.size === 0;

            useEffect(() => {
                if (!activeGroupId) return;
                if (!activeGroupTeamIds.length) {
                    if (!selectedTeams.includes('all')) {
                        setSelectedTeams(['all']);
                    }
                    return;
                }
                setSelectedTeams(prev => {
                    const normalized = normalizeSelectedTeams(prev);
                    if (normalized.includes('all')) return ['all'];
                    const filtered = normalized.filter(id => activeGroupTeamSet.has(id));
                    if (!filtered.length) return ['all'];
                    if (filtered.length === normalized.length && filtered.every((id, idx) => id === normalized[idx])) {
                        return prev;
                    }
                    return filtered;
                });
            }, [activeGroupId, activeGroupTeamIds.join('|')]);

            const selectedTeamsLabel = React.useMemo(() => {
                if (isAllTeamsSelected) return 'All Teams';
                if (selectedTeamSet.size === 1) {
                    const id = Array.from(selectedTeamSet)[0];
                    return teamNameById.get(id) || '1 Team';
                }
                return `${selectedTeamSet.size} Teams`;
            }, [isAllTeamsSelected, selectedTeamSet, teamNameById]);

            const scenarioTeamIds = React.useMemo(() => {
                if (isAllTeamsSelected) {
                    return teamOptions.filter(team => team.id !== 'all').map(team => team.id);
                }
                return Array.from(selectedTeamSet);
            }, [isAllTeamsSelected, selectedTeamSet, teamOptions]);


            const toggleTeamSelection = (teamId) => {
                if (teamId === 'all') {
                    setSelectedTeams(['all']);
                    return;
                }
                setSelectedTeams((prev) => {
                    const next = new Set((prev || []).filter(id => id !== 'all'));
                    if (next.has(teamId)) {
                        next.delete(teamId);
                    } else {
                        next.add(teamId);
                    }
                    return next.size ? Array.from(next) : ['all'];
                });
            };

            const excludedEpicSet = React.useMemo(() => new Set(excludedStatsEpics || []), [excludedStatsEpics]);
            const statsTaskList = React.useMemo(() => {
                if (!capacityTasks.length) return [];
                if (!hideExcludedStats) return capacityTasks;
                return capacityTasks.filter(task => {
                    const epicKey = task.fields?.epicKey || 'NO_EPIC';
                    return !excludedEpicSet.has(epicKey);
                });
            }, [capacityTasks, hideExcludedStats, excludedEpicSet]);
            const localStatsData = React.useMemo(() => {
                if (!showStats) return null;
                if (!statsTaskList.length) return null;
                if (perfEnabled) {
                    perfCountersRef.current.statsBuild = (perfCountersRef.current.statsBuild || 0) + 1;
                    performance.mark('localStatsBuild:start');
                }
                const result = buildLocalStatsFromTasks(statsTaskList, new Set());
                if (perfEnabled) {
                    performance.mark('localStatsBuild:end');
                    performance.measure('localStatsBuild', 'localStatsBuild:start', 'localStatsBuild:end');
                    performance.clearMarks('localStatsBuild:start');
                    performance.clearMarks('localStatsBuild:end');
                    performance.clearMeasures('localStatsBuild');
                }
                return result;
            }, [statsTaskList, selectedSprintInfo?.name, showStats, perfEnabled]);

            const effectiveStatsData = localStatsData;
            const scenarioIssues = scenarioData?.issues || EMPTY_ARRAY;
            const scenarioConfig = scenarioData?.config || EMPTY_OBJECT;
            const scenarioSummary = scenarioData?.summary || EMPTY_OBJECT;
            const scenarioBaseUrl = scenarioData?.jira_base_url || jiraUrl || '';
            const scenarioDependencies = scenarioData?.dependencies || EMPTY_ARRAY;
            const scenarioSearchQuery = React.useMemo(
                () => (searchQuery || '').trim().toLowerCase(),
                [searchQuery]
            );
            const scenarioSearchMatchSet = React.useMemo(() => {
                const matches = new Set();
                if (!scenarioSearchQuery) return matches;
                scenarioIssues.forEach(issue => {
                    if (issue?.key && matchesScenarioSearch(issue, scenarioSearchQuery)) {
                        matches.add(issue.key);
                    }
                });
                return matches;
            }, [scenarioIssues, scenarioSearchQuery]);
            const scenarioFilteredIssues = React.useMemo(() => {
                if (!scenarioSearchQuery) return scenarioIssues;
                return scenarioIssues.filter(issue => scenarioSearchMatchSet.has(issue.key));
            }, [scenarioIssues, scenarioSearchQuery, scenarioSearchMatchSet]);
            const scenarioExcludedIssueKeys = React.useMemo(() => {
                const keys = new Set();
                scenarioIssues.forEach(issue => {
                    if (excludedEpicSet.has(issue?.epicKey || '')) {
                        keys.add(issue.key);
                    }
                });
                return keys;
            }, [scenarioIssues, excludedEpicSet]);
            const scenarioFocusKeys = scenarioData?.focus_set?.focused_issue_keys || EMPTY_ARRAY;
            const scenarioContextKeys = scenarioData?.focus_set?.context_issue_keys || EMPTY_ARRAY;
            const scenarioFocusSet = React.useMemo(
                () => new Set(scenarioFocusKeys),
                [scenarioFocusKeys]
            );
            const scenarioContextSet = React.useMemo(
                () => new Set(scenarioContextKeys),
                [scenarioContextKeys]
            );
            const scenarioCapacityByTeam = scenarioData?.capacity_by_team || EMPTY_OBJECT;
            const scenarioIssueByKey = React.useMemo(() => {
                const map = new Map();
                scenarioIssues.forEach(issue => {
                    if (issue?.key) {
                        map.set(issue.key, issue);
                    }
                });
                return map;
            }, [scenarioIssues]);
            const scenarioBaseStart = parseScenarioDate(scenarioConfig.start_date);
            const scenarioDeadline = parseScenarioDate(scenarioConfig.quarter_end_date);
            const scenarioBaseEnd = React.useMemo(() => {
                if (!scenarioDeadline) return null;
                let latest = scenarioDeadline;
                scenarioIssues.forEach(issue => {
                    if (!issue.end) return;
                    const end = parseScenarioDate(issue.end);
                    if (end && end > latest) {
                        latest = end;
                    }
                });
                return latest;
            }, [scenarioDeadline, scenarioIssues]);
            const scenarioViewStart = scenarioRangeOverride?.start || scenarioBaseStart;
            const scenarioViewEnd = scenarioRangeOverride?.end || scenarioBaseEnd;
            const scenarioFocusEpicKey = scenarioEpicFocus?.key || null;
            const scenarioFocusIssueKeys = React.useMemo(() => {
                const keys = new Set();
                if (!scenarioFocusEpicKey) return keys;
                scenarioIssues.forEach(issue => {
                    if (issue.epicKey === scenarioFocusEpicKey && issue.key) {
                        keys.add(issue.key);
                    }
                });
                return keys;
            }, [scenarioIssues, scenarioFocusEpicKey]);
            const scenarioFocusContextKeys = React.useMemo(() => {
                const keys = new Set();
                if (!scenarioFocusEpicKey) return keys;
                (scenarioDependencies || []).forEach(edge => {
                    if (!edge?.from || !edge?.to) return;
                    const fromInFocus = scenarioFocusIssueKeys.has(edge.from);
                    const toInFocus = scenarioFocusIssueKeys.has(edge.to);
                    if (fromInFocus && !toInFocus) {
                        keys.add(edge.to);
                    } else if (toInFocus && !fromInFocus) {
                        keys.add(edge.from);
                    }
                });
                return keys;
            }, [scenarioDependencies, scenarioFocusIssueKeys, scenarioFocusEpicKey]);
            const scenarioTimelineIssues = React.useMemo(() => {
                const source = scenarioEpicFocus ? scenarioIssues : scenarioFilteredIssues;
                if (!scenarioEpicFocus) return source;
                return source.filter(issue =>
                    scenarioFocusIssueKeys.has(issue.key) || scenarioFocusContextKeys.has(issue.key)
                );
            }, [scenarioIssues, scenarioFilteredIssues, scenarioEpicFocus, scenarioFocusIssueKeys, scenarioFocusContextKeys]);
            const scenarioTimelineIssueKeys = React.useMemo(() => {
                return new Set(scenarioTimelineIssues.map(issue => issue.key));
            }, [scenarioTimelineIssues]);
            const scenarioLaneForIssue = (issue) => {
                if (scenarioEpicFocus?.key) {
                    return scenarioEpicFocus.key;
                }
                if (scenarioLaneMode === 'epic') {
                    return issue.epicKey || 'No Epic';
                }
                if (scenarioLaneMode === 'assignee') {
                    return issue.assignee || 'Unassigned';
                }
                return issue.team || 'Unassigned';
            };
            const scenarioLaneInfo = React.useMemo(() => {
                const info = new Map();
                scenarioTimelineIssues.forEach(issue => {
                    const lane = scenarioLaneForIssue(issue);
                    const current = info.get(lane) || {
                        label: lane,
                        key: lane,
                        totalSp: 0,
                        lateCount: 0,
                        unschedulableCount: 0,
                        capacity: null
                    };
                    const countIssue = !scenarioEpicFocus || scenarioFocusIssueKeys.has(issue.key);
                    const isExcluded = scenarioExcludedIssueKeys.has(issue.key);
                    if (countIssue) {
                        current.totalSp += Number(issue.sp || 0);
                        if (!isExcluded && (!issue.start || !issue.end)) {
                            current.unschedulableCount += 1;
                        }
                        if (!isExcluded && issue.isLate) {
                            current.lateCount += 1;
                        }
                    }
                    if (scenarioLaneMode === 'epic') {
                        current.key = issue.epicKey || 'No Epic';
                        current.label = issue.epicSummary || issue.epicKey || 'No Epic';
                    }
                    if (scenarioLaneMode === 'team') {
                        const capacity = scenarioCapacityByTeam[issue.team || '']?.size;
                        current.capacity = capacity ?? current.capacity;
                    }
                    info.set(lane, current);
                });
                if (scenarioEpicFocus?.key) {
                    const existing = info.get(scenarioEpicFocus.key) || {
                        label: scenarioEpicFocus.key,
                        key: scenarioEpicFocus.key,
                        totalSp: 0,
                        lateCount: 0,
                        unschedulableCount: 0,
                        capacity: null
                    };
                    existing.label = scenarioEpicFocus.summary || scenarioEpicFocus.key;
                    existing.key = scenarioEpicFocus.key;
                    info.set(scenarioEpicFocus.key, existing);
                }
                return info;
            }, [scenarioTimelineIssues, scenarioLaneMode, scenarioCapacityByTeam, scenarioEpicFocus, scenarioFocusIssueKeys, scenarioExcludedIssueKeys]);
            const scenarioSearchFilterEnabled = Boolean(scenarioSearchQuery && !scenarioEpicFocus);
            const scenarioLateItems = React.useMemo(() => {
                return (scenarioSummary.late_items || []).filter(key => (
                    !scenarioExcludedIssueKeys.has(key)
                    && (!scenarioSearchFilterEnabled || scenarioSearchMatchSet.has(key))
                ));
            }, [scenarioSummary, scenarioExcludedIssueKeys, scenarioSearchFilterEnabled, scenarioSearchMatchSet]);
            const scenarioDeadlineAtRisk = scenarioLateItems.length > 0;
            const scenarioCriticalPathItems = React.useMemo(() => {
                return (scenarioSummary.critical_path || []).filter(key => (
                    !scenarioExcludedIssueKeys.has(key)
                    && (!scenarioSearchFilterEnabled || scenarioSearchMatchSet.has(key))
                ));
            }, [scenarioSummary, scenarioExcludedIssueKeys, scenarioSearchFilterEnabled, scenarioSearchMatchSet]);
            const scenarioUnschedulableItems = React.useMemo(() => {
                return (scenarioSummary.unschedulable || []).filter(key => (
                    !scenarioExcludedIssueKeys.has(key)
                    && (!scenarioSearchFilterEnabled || scenarioSearchMatchSet.has(key))
                ));
            }, [scenarioSummary, scenarioExcludedIssueKeys, scenarioSearchFilterEnabled, scenarioSearchMatchSet]);
            const scenarioBottleneckLanes = React.useMemo(() => {
                const lanes = scenarioSummary.bottleneck_lanes || [];
                return lanes.filter(lane => {
                    const laneInfo = scenarioLaneInfo.get(lane);
                    if (!laneInfo) return true;
                    return (laneInfo.lateCount || laneInfo.unschedulableCount);
                });
            }, [scenarioSummary, scenarioLaneInfo]);
            const scenarioLanes = React.useMemo(() => {
                const lanes = Array.from(scenarioLaneInfo.keys());
                return lanes.sort((a, b) => a.localeCompare(b));
            }, [scenarioLaneInfo]);
            const scenarioIssuesByLane = React.useMemo(() => {
                const groups = new Map();
                scenarioTimelineIssues.forEach(issue => {
                    const lane = scenarioLaneForIssue(issue);
                    if (!groups.has(lane)) {
                        groups.set(lane, []);
                    }
                    groups.get(lane).push(issue);
                });
                groups.forEach(list => {
                    list.sort((a, b) => (a.start || '').localeCompare(b.start || ''));
                });
                return groups;
            }, [scenarioTimelineIssues, scenarioLaneMode, scenarioEpicFocus]);
            const scenarioHasAssignees = React.useMemo(() => {
                return scenarioIssues.some(issue => issue.assignee);
            }, [scenarioIssues]);
            const scenarioUnschedulable = React.useMemo(() => {
                return scenarioIssues.filter(issue => !issue.start || !issue.end);
            }, [scenarioIssues]);
            const scenarioTicks = React.useMemo(() => {
                if (!scenarioViewStart || !scenarioViewEnd) return [];
                const totalMs = Math.max(1, scenarioViewEnd - scenarioViewStart);
                const steps = 4;
                return Array.from({ length: steps + 1 }, (_, idx) => {
                    const ratio = idx / steps;
                    const date = new Date(scenarioViewStart.getTime() + totalMs * ratio);
                    return {
                        label: date.toLocaleDateString('en-CA', { month: 'short', day: 'numeric' }),
                        ratio
                    };
                });
            }, [scenarioViewStart, scenarioViewEnd]);
            const scenarioQuarterMarkers = React.useMemo(() => {
                if (!scenarioViewStart || !scenarioViewEnd) return [];
                const markers = [];
                const start = new Date(scenarioViewStart.getTime());
                const end = new Date(scenarioViewEnd.getTime());
                const startQuarter = Math.floor(start.getMonth() / 3);
                let quarterStart = new Date(start.getFullYear(), startQuarter * 3, 1);
                if (quarterStart < start) {
                    const nextQuarter = startQuarter + 1;
                    const year = start.getFullYear() + Math.floor(nextQuarter / 4);
                    const month = (nextQuarter % 4) * 3;
                    quarterStart = new Date(year, month, 1);
                }
                let cursor = quarterStart;
                while (cursor <= end) {
                    const ratio = (cursor - scenarioViewStart) / Math.max(1, scenarioViewEnd - scenarioViewStart);
                    if (ratio >= 0 && ratio <= 1) {
                        markers.push({
                            date: new Date(cursor.getTime()),
                            ratio
                        });
                    }
                    const nextMonth = cursor.getMonth() + 3;
                    cursor = new Date(cursor.getFullYear() + Math.floor(nextMonth / 12), nextMonth % 12, 1);
                }
                return markers;
            }, [scenarioViewStart, scenarioViewEnd]);
            const SCENARIO_LANE_HEIGHT = 52;
            const SCENARIO_BAR_HEIGHT = 32;
            const SCENARIO_BAR_GAP = 10;
            const SCENARIO_COLLAPSED_ROWS = 2;
            const SCENARIO_TEAM_LEAD_ROWS = 1;
            const scenarioBarGap = scenarioEpicFocus ? 16 : SCENARIO_BAR_GAP;
            const scenarioLaneStacking = React.useMemo(() => {
                if (perfEnabled) {
                    perfCountersRef.current.laneStacking += 1;
                    performance.mark('scenarioLaneStacking:start');
                }
                const rowIndexByKey = new Map();
                const laneRowCounts = new Map();
                const laneVisibleRows = new Map();
                const laneHiddenCounts = new Map();
                const fallbackStart = scenarioViewStart || new Date(0);
                const DAY_MS = 24 * 60 * 60 * 1000;
                const assignRows = (issueList, rowEnds, baseOffset) => {
                    issueList.forEach((issue) => {
                        if (!issue?.key) return;
                        const isUnscheduled = !issue.start || !issue.end;
                        const start = parseScenarioDate(issue.start) || fallbackStart;
                        const end = parseScenarioDate(issue.end) || start;
                        const normalizedEnd = end < start
                            ? start
                            : (isUnscheduled ? new Date(start.getTime() + DAY_MS) : end);
                        let rowIndex = rowEnds.findIndex(rowEnd => (
                            isUnscheduled ? start > rowEnd : start >= rowEnd
                        ));
                        if (rowIndex === -1) {
                            rowIndex = rowEnds.length;
                            rowEnds.push(normalizedEnd);
                        } else {
                            rowEnds[rowIndex] = normalizedEnd;
                        }
                        rowIndexByKey.set(issue.key, baseOffset + rowIndex);
                    });
                };
                scenarioLanes.forEach((lane) => {
                    const issues = scenarioIssuesByLane.get(lane) || [];
                    const rowEnds = [];
                    const capacitySize = scenarioLaneMode === 'team'
                        ? Number(scenarioCapacityByTeam[lane || '']?.size)
                        : null;
                    const capacityRows = Number.isFinite(capacitySize) && capacitySize > 0
                        ? Math.max(1, Math.round(capacitySize) + SCENARIO_TEAM_LEAD_ROWS)
                        : null;
                    const regularIssues = [];
                    const excludedIssues = [];
                    issues.forEach((issue) => {
                        if (!issue?.key) return;
                        if (scenarioExcludedIssueKeys.has(issue.key)) {
                            excludedIssues.push(issue);
                        } else {
                            regularIssues.push(issue);
                        }
                    });
                    assignRows(regularIssues, rowEnds, 0);
                    const excludedRowEnds = [];
                    assignRows(excludedIssues, excludedRowEnds, rowEnds.length);
                    const totalRows = Math.max(1, rowEnds.length + excludedRowEnds.length, capacityRows || 0);
                    const isCollapsed = scenarioEpicFocus ? false : Boolean(scenarioCollapsedLanes[lane]);
                    const collapsedRows = scenarioLaneMode === 'epic'
                        ? 1
                        : (scenarioLaneMode === 'team' && capacityRows
                            ? Math.max(SCENARIO_COLLAPSED_ROWS, capacityRows)
                            : SCENARIO_COLLAPSED_ROWS);
                    const visibleRows = isCollapsed
                        ? Math.min(collapsedRows, totalRows)
                        : totalRows;
                    laneRowCounts.set(lane, totalRows);
                    laneVisibleRows.set(lane, Math.max(1, visibleRows));
                    laneHiddenCounts.set(lane, Math.max(0, totalRows - visibleRows));
                });
                if (perfEnabled) {
                    performance.mark('scenarioLaneStacking:end');
                    performance.measure(
                        'scenarioLaneStacking',
                        'scenarioLaneStacking:start',
                        'scenarioLaneStacking:end'
                    );
                    performance.clearMarks('scenarioLaneStacking:start');
                    performance.clearMarks('scenarioLaneStacking:end');
                    performance.clearMeasures('scenarioLaneStacking');
                }
                return { rowIndexByKey, laneRowCounts, laneVisibleRows, laneHiddenCounts };
            }, [
                scenarioLanes,
                scenarioIssuesByLane,
                scenarioViewStart,
                scenarioCollapsedLanes,
                scenarioLaneMode,
                scenarioCapacityByTeam,
                scenarioExcludedIssueKeys,
                isAllTeamsSelected,
                scenarioEpicFocus,
                perfEnabled
            ]);
            const scenarioLaneMeta = React.useMemo(() => {
                const meta = new Map();
                let offset = 0;
                scenarioLanes.forEach((lane) => {
                    const totalRows = scenarioLaneStacking.laneRowCounts.get(lane) || 1;
                    const visibleRows = scenarioLaneStacking.laneVisibleRows.get(lane) || 1;
                    const hiddenCount = scenarioLaneStacking.laneHiddenCounts.get(lane) || 0;
                    const shouldCollapse = Boolean(scenarioCollapsedLanes[lane]);
                    const isCollapsed = scenarioEpicFocus?.key === lane ? false : shouldCollapse;
                    const rowCount = Math.max(1, visibleRows);
                    const height = rowCount * (SCENARIO_BAR_HEIGHT + scenarioBarGap) + scenarioBarGap;
                    meta.set(lane, { offset, height, rowCount, collapsed: isCollapsed, hiddenCount, totalRows });
                    offset += height;
                });
                return { meta, totalHeight: offset };
            }, [scenarioLanes, scenarioLaneStacking, scenarioCollapsedLanes, scenarioEpicFocus, scenarioBarGap]);
            const areScenarioCollapsedLanesEqual = (a, b) => {
                if (a === b) return true;
                const aKeys = Object.keys(a || {});
                const bKeys = Object.keys(b || {});
                if (aKeys.length !== bKeys.length) return false;
                for (let i = 0; i < aKeys.length; i += 1) {
                    const key = aKeys[i];
                    if (a[key] !== b[key]) return false;
                }
                return true;
            };

            useEffect(() => {
                if (!showScenario) return;
                if (!scenarioIssues.length && !scenarioLanes.length) return;
                if (scenarioSkipAutoCollapseRef.current) {
                    scenarioSkipAutoCollapseRef.current = false;
                    return;
                }
                if (scenarioLaneMode === 'team' && isAllTeamsSelected) {
                    if (!scenarioTeamCollapseInitRef.current) {
                        const next = {};
                        scenarioLanes.forEach(lane => {
                            next[lane] = true;
                        });
                        setScenarioCollapsedLanes(prev => (areScenarioCollapsedLanesEqual(prev, next) ? prev : next));
                        scenarioTeamCollapseInitRef.current = true;
                    }
                    return;
                }
                scenarioTeamCollapseInitRef.current = false;
                if (scenarioLaneMode !== 'epic') {
                    setScenarioCollapsedLanes(prev => (Object.keys(prev || {}).length ? {} : prev));
                    return;
                }
                const next = {};
                scenarioLanes.forEach(lane => {
                    next[lane] = true;
                });
                scenarioIssues.forEach(issue => {
                    if (scenarioFocusSet.size === 0 || scenarioFocusSet.has(issue.key) || scenarioContextSet.has(issue.key)) {
                        next[scenarioLaneForIssue(issue)] = false;
                    }
                });
                setScenarioCollapsedLanes(prev => (areScenarioCollapsedLanesEqual(prev, next) ? prev : next));
            }, [
                showScenario,
                scenarioLaneMode,
                scenarioLanes,
                scenarioIssues,
                scenarioFocusSet,
                scenarioContextSet,
                isAllTeamsSelected
            ]);

            useEffect(() => {
                scenarioTeamCollapseInitRef.current = false;
            }, [scenarioData]);

            useEffect(() => {
                if (!showScenario || !scenarioTimelineRef.current) return;
                const container = scenarioTimelineRef.current;
                const readLayout = () => {
                    if (perfEnabled) {
                        perfCountersRef.current.layoutReads += 1;
                    }
                    const track = container.querySelector('.scenario-lane-track');
                    const labelWidth = 190;
                    const trackWidth = track ? track.clientWidth : Math.max(0, container.clientWidth - labelWidth);
                    let height = scenarioLaneMeta.totalHeight || scenarioLanes.length * SCENARIO_LANE_HEIGHT;
                    setScenarioLayout(prev => {
                        if (prev.width === trackWidth && prev.height === height && prev.labelWidth === labelWidth) {
                            return prev;
                        }
                        return {
                            width: trackWidth,
                            height,
                            labelWidth
                        };
                    });
                    scheduleScenarioEdgeUpdate();
                };
                const readScroll = () => {
                    if (perfEnabled) {
                        perfCountersRef.current.scrollReads += 1;
                    }
                    const nextTop = container.scrollTop || 0;
                    const nextHeight = container.clientHeight || 0;
                    setScenarioScrollTop(prev => (prev === nextTop ? prev : nextTop));
                    setScenarioViewportHeight(prev => (prev === nextHeight ? prev : nextHeight));
                    scheduleScenarioEdgeUpdate();
                };
                const scheduleLayout = () => {
                    if (scenarioResizeFrameRef.current) return;
                    scenarioResizeFrameRef.current = window.requestAnimationFrame(() => {
                        scenarioResizeFrameRef.current = null;
                        if (!scenarioTimelineRef.current) return;
                        readLayout();
                    });
                };
                const scheduleScroll = () => {
                    if (scenarioScrollFrameRef.current) return;
                    scenarioScrollFrameRef.current = window.requestAnimationFrame(() => {
                        scenarioScrollFrameRef.current = null;
                        if (!scenarioTimelineRef.current) return;
                        readScroll();
                    });
                };
                scheduleLayout();
                scheduleScroll();
                container.addEventListener('scroll', scheduleScroll, { passive: true });
                window.addEventListener('resize', scheduleLayout);
                window.addEventListener('resize', scheduleScroll);
                return () => {
                    container.removeEventListener('scroll', scheduleScroll);
                    window.removeEventListener('resize', scheduleLayout);
                    window.removeEventListener('resize', scheduleScroll);
                    if (scenarioScrollFrameRef.current) {
                        window.cancelAnimationFrame(scenarioScrollFrameRef.current);
                        scenarioScrollFrameRef.current = null;
                    }
                    if (scenarioResizeFrameRef.current) {
                        window.cancelAnimationFrame(scenarioResizeFrameRef.current);
                        scenarioResizeFrameRef.current = null;
                    }
                };
            }, [showScenario, scenarioLanes.length, scenarioData, scenarioLaneMode, scenarioIssuesByLane, scenarioLaneMeta, scheduleScenarioEdgeUpdate, perfEnabled]);

            useEffect(() => {
                scheduleScenarioEdgeUpdate();
            }, [
                scenarioLaneMode,
                scenarioCollapsedLanes,
                scenarioRangeOverride,
                scenarioEpicFocus,
                scenarioLayout.width,
                scenarioLayout.height,
                scenarioLaneStacking,
                scheduleScenarioEdgeUpdate
            ]);

            useEffect(() => {
                if (!showScenario) return;
                scheduleScenarioEdgeUpdate();
            }, [showScenario, scenarioPositions, scenarioVisibleLanes, scheduleScenarioEdgeUpdate]);

            useEffect(() => {
                scheduleScenarioEdgeUpdate();
            }, [
                scenarioHoverKey,
                scenarioBaselineEdges,
                scenarioFocusEdges,
                scenarioActiveEdges,
                scenarioTimelineIssueKeys,
                scheduleScenarioEdgeUpdate
            ]);

            const scenarioPositions = React.useMemo(() => {
                if (!scenarioViewStart || !scenarioViewEnd) return {};
                if (!scenarioLayout.width) return {};
                const totalMs = Math.max(1, scenarioViewEnd - scenarioViewStart);
                const positions = {};
                scenarioTimelineIssues.forEach((issue) => {
                    const lane = scenarioLaneForIssue(issue);
                    const laneMeta = scenarioLaneMeta.meta.get(lane);
                    if (!laneMeta) return;
                    const rowIndex = scenarioLaneStacking.rowIndexByKey.get(issue.key) ?? 0;
                    const visibleRows = scenarioLaneStacking.laneVisibleRows.get(lane) || 1;
                    if (rowIndex >= visibleRows) return;
                    const y = laneMeta.offset + scenarioBarGap + rowIndex * (SCENARIO_BAR_HEIGHT + scenarioBarGap);
                    if (!issue.start || !issue.end) {
                        const width = Math.min(80, scenarioLayout.width * 0.12);
                        positions[issue.key] = {
                            xStart: 0,
                            xEnd: width,
                            y,
                            height: SCENARIO_BAR_HEIGHT,
                            lane
                        };
                        return;
                    }
                    const start = parseScenarioDate(issue.start);
                    const end = parseScenarioDate(issue.end);
                    if (!start || !end) return;
                    const startRatio = Math.max(0, (start - scenarioViewStart) / totalMs);
                    const endRatio = Math.min(1, (end - scenarioViewStart) / totalMs);
                    const xStart = startRatio * scenarioLayout.width;
                    const xEnd = Math.max(xStart + 6, endRatio * scenarioLayout.width);
                    positions[issue.key] = {
                        xStart,
                        xEnd,
                        y,
                        height: SCENARIO_BAR_HEIGHT,
                        lane
                    };
                });
                return positions;
            }, [
                scenarioTimelineIssues,
                scenarioViewStart,
                scenarioViewEnd,
                scenarioLayout,
                scenarioLanes,
                scenarioLaneMeta,
                scenarioBarGap,
                scenarioLaneStacking
            ]);

            const scenarioEdgeCandidates = React.useMemo(() => {
                return (scenarioDependencies || []).filter(edge =>
                    edge?.from &&
                    edge?.to &&
                    scenarioTimelineIssueKeys.has(edge.from) &&
                    scenarioTimelineIssueKeys.has(edge.to)
                );
            }, [scenarioDependencies, scenarioTimelineIssueKeys]);

            const scenarioEdgeIndex = React.useMemo(() => {
                const incoming = new Map();
                const outgoing = new Map();
                scenarioEdgeCandidates.forEach(edge => {
                    if (!incoming.has(edge.to)) {
                        incoming.set(edge.to, new Set());
                    }
                    if (!outgoing.has(edge.from)) {
                        outgoing.set(edge.from, new Set());
                    }
                    incoming.get(edge.to).add(edge.from);
                    outgoing.get(edge.from).add(edge.to);
                });
                return { incoming, outgoing };
            }, [scenarioEdgeCandidates]);

            const scenarioEpicBars = React.useMemo(() => {
                if (scenarioLaneMode !== 'epic') return [];
                if (!scenarioViewStart || !scenarioViewEnd) return [];
                const bars = [];
                const totalMs = Math.max(1, scenarioViewEnd - scenarioViewStart);
                scenarioLanes.forEach((lane) => {
                    const laneIssues = scenarioIssuesByLane.get(lane) || [];
                    const epicGroups = new Map();
                    laneIssues.forEach((issue) => {
                        const epicKey = issue.epicKey;
                        if (!epicKey) return;
                        if (!epicGroups.has(epicKey)) {
                            epicGroups.set(epicKey, []);
                        }
                        epicGroups.get(epicKey).push(issue);
                    });
                    epicGroups.forEach((issues, epicKey) => {
                        if (scenarioEpicFocus?.key && epicKey !== scenarioEpicFocus.key) return;
                        let start = null;
                        let end = null;
                        let storyPoints = 0;
                        issues.forEach((issue) => {
                            const startDate = parseScenarioDate(issue.start);
                            const endDate = parseScenarioDate(issue.end);
                            if (!startDate || !endDate) return;
                            if (!start || startDate < start) start = startDate;
                            if (!end || endDate > end) end = endDate;
                            if (Number.isFinite(issue.sp)) {
                                storyPoints += Number(issue.sp);
                            }
                        });
                        if (!start || !end) return;
                        const startRatio = Math.max(0, (start - scenarioViewStart) / totalMs);
                        const endRatio = Math.min(1, (end - scenarioViewStart) / totalMs);
                        const xStart = startRatio * scenarioLayout.width;
                        const xEnd = Math.max(xStart + 6, endRatio * scenarioLayout.width);
                        const laneMeta = scenarioLaneMeta.meta.get(lane) || { offset: 0, height: SCENARIO_LANE_HEIGHT };
                        bars.push({
                            lane,
                            epicKey,
                            epicSummary: scenarioIssueByKey.get(issues[0].key)?.epicSummary,
                            storyPoints,
                            xStart,
                            xEnd,
                            y: laneMeta.offset + 3,
                            height: laneMeta.height - 6,
                            isExcluded: excludedEpicSet.has(epicKey)
                        });
                    });
                });
                return bars;
            }, [scenarioIssuesByLane, scenarioLanes, scenarioLaneMode, scenarioViewStart, scenarioViewEnd, scenarioLayout, scenarioLaneMeta, scenarioIssueByKey, scenarioEpicFocus, excludedEpicSet]);

            const scenarioEpicEdges = React.useMemo(() => {
                if (scenarioLaneMode !== 'epic' || scenarioEpicFocus) return [];
                const grouped = new Map();
                (scenarioDependencies || []).forEach(edge => {
                    const fromIssue = scenarioIssueByKey.get(edge.from);
                    const toIssue = scenarioIssueByKey.get(edge.to);
                    if (!fromIssue || !toIssue) return;
                    const fromEpic = fromIssue.epicKey || 'No Epic';
                    const toEpic = toIssue.epicKey || 'No Epic';
                    if (fromEpic === toEpic) return;
                    const key = `${fromEpic}::${toEpic}`;
                    const current = grouped.get(key) || { fromEpic, toEpic, count: 0 };
                    current.count += 1;
                    grouped.set(key, current);
                });
                const edges = [];
                grouped.forEach((entry) => {
                    const fromMeta = scenarioLaneMeta.meta.get(entry.fromEpic);
                    const toMeta = scenarioLaneMeta.meta.get(entry.toEpic);
                    if (!fromMeta || !toMeta) return;
                    edges.push({
                        fromEpic: entry.fromEpic,
                        toEpic: entry.toEpic,
                        count: entry.count,
                        y1: fromMeta.offset + fromMeta.height / 2,
                        y2: toMeta.offset + toMeta.height / 2,
                    });
                });
                return edges;
            }, [scenarioDependencies, scenarioLaneMeta, scenarioLaneMode, scenarioIssueByKey]);

            const scenarioDeadlineLeft = React.useMemo(() => {
                if (!scenarioViewStart || !scenarioViewEnd || !scenarioDeadline) return 0;
                if (!scenarioLayout.width) return 0;
                const totalMs = Math.max(1, scenarioViewEnd - scenarioViewStart);
                const ratio = Math.max(0, Math.min(1, (scenarioDeadline - scenarioViewStart) / totalMs));
                return scenarioLayout.labelWidth + scenarioLayout.width * ratio;
            }, [scenarioViewStart, scenarioViewEnd, scenarioDeadline, scenarioLayout]);

            const scenarioVisibleLanes = React.useMemo(() => {
                if (!scenarioViewportHeight) return scenarioLanes;
                const buffer = 80;
                const start = scenarioScrollTop - buffer;
                const end = scenarioScrollTop + scenarioViewportHeight + buffer;
                return scenarioLanes.filter(lane => {
                    const meta = scenarioLaneMeta.meta.get(lane);
                    if (!meta) return false;
                    return meta.offset + meta.height >= start && meta.offset <= end;
                });
            }, [scenarioLanes, scenarioLaneMeta, scenarioScrollTop, scenarioViewportHeight]);

            const scenarioActiveEdges = React.useMemo(() => {
                if (!scenarioHoverKey) return [];
                return scenarioEdgeCandidates.filter(edge => edge.from === scenarioHoverKey || edge.to === scenarioHoverKey);
            }, [scenarioEdgeCandidates, scenarioHoverKey]);

            const scenarioUpstreamSet = React.useMemo(() => {
                if (!scenarioHoverKey) return new Set();
                return new Set(scenarioEdgeIndex.incoming.get(scenarioHoverKey) || []);
            }, [scenarioHoverKey, scenarioEdgeIndex]);

            const scenarioDownstreamSet = React.useMemo(() => {
                if (!scenarioHoverKey) return new Set();
                return new Set(scenarioEdgeIndex.outgoing.get(scenarioHoverKey) || []);
            }, [scenarioHoverKey, scenarioEdgeIndex]);

            const scenarioBlockedSet = React.useMemo(() => {
                const blocked = new Set();
                (scenarioDependencies || []).forEach(edge => {
                    if (edge.type === 'block' && edge.to) {
                        blocked.add(edge.to);
                    }
                });
                return blocked;
            }, [scenarioDependencies]);

            const scenarioIsSingleTeamFocus = !isAllTeamsSelected && selectedTeamSet.size === 1;
            const scenarioBaselineEdges = React.useMemo(() => {
                const focusKeys = scenarioFocusSet.size ? scenarioFocusSet : new Set(scenarioTimelineIssues.map(issue => issue.key));
                if (!scenarioIsSingleTeamFocus && focusKeys.size > 10) return [];
                return scenarioEdgeCandidates.filter(edge => focusKeys.has(edge.from) || focusKeys.has(edge.to));
            }, [scenarioFocusSet, scenarioEdgeCandidates, scenarioTimelineIssues, scenarioIsSingleTeamFocus]);

            const scenarioFocusEdges = React.useMemo(() => {
                if (!scenarioEpicFocus) return [];
                const inside = [];
                const context = [];
                scenarioEdgeCandidates.forEach(edge => {
                    const fromIn = scenarioFocusIssueKeys.has(edge.from);
                    const toIn = scenarioFocusIssueKeys.has(edge.to);
                    if (fromIn && toIn) {
                        inside.push(edge);
                        return;
                    }
                    const fromContext = scenarioFocusContextKeys.has(edge.from);
                    const toContext = scenarioFocusContextKeys.has(edge.to);
                    if ((fromIn && toContext) || (toIn && fromContext)) {
                        context.push(edge);
                    }
                });
                return [...context, ...inside];
            }, [scenarioEpicFocus, scenarioEdgeCandidates, scenarioFocusIssueKeys, scenarioFocusContextKeys]);


            const toggleScenarioLane = (lane) => {
                setScenarioCollapsedLanes(prev => ({
                    ...prev,
                    [lane]: !prev?.[lane]
                }));
            };

            const buildScenarioTooltipPayload = (summary, key, sp, isExcluded = false) => {
                const cleanedSummary = normalizeScenarioSummary(summary) || key || '';
                const hasSp = sp !== null && sp !== undefined && sp !== '';
                const spValue = hasSp ? Number(sp) : null;
                return {
                    summary: cleanedSummary,
                    key: key || '',
                    sp: Number.isFinite(spValue) ? spValue : null,
                    note: isExcluded ? 'Excluded (capacity noise)' : ''
                };
            };

            const areScenarioEdgeRendersEqual = (prev, next) => {
                if (prev.width !== next.width || prev.height !== next.height) return false;
                if (prev.paths.length !== next.paths.length) return false;
                for (let i = 0; i < prev.paths.length; i += 1) {
                    const a = prev.paths[i];
                    const b = next.paths[i];
                    if (a.id !== b.id) return false;
                    if (a.d !== b.d) return false;
                    if (a.isActive !== b.isActive) return false;
                    if (a.isFaded !== b.isFaded) return false;
                    if (a.isContextEdge !== b.isContextEdge) return false;
                    if (a.type !== b.type) return false;
                }
                return true;
            };

            const computeScenarioTooltipPosition = (anchor) => {
                const fallback = { width: 240, height: 56 };
                const tooltipNode = scenarioTooltipRef.current;
                const measured = tooltipNode?.getBoundingClientRect?.();
                const tooltipWidth = measured?.width || fallback.width;
                const tooltipHeight = measured?.height || fallback.height;
                const rect = anchor?.getBoundingClientRect ? anchor.getBoundingClientRect() : anchor;
                if (!rect) {
                    return { x: 0, y: 0 };
                }
                const padding = 12;
                const offset = 10;
                let x = rect.right + offset;
                let y = rect.top - tooltipHeight - offset;
                if (y < padding) {
                    y = rect.bottom + offset;
                }
                if (x + tooltipWidth > window.innerWidth - padding) {
                    x = rect.left - tooltipWidth - offset;
                }
                if (x < padding) {
                    x = padding;
                }
                if (y + tooltipHeight > window.innerHeight - padding) {
                    y = Math.max(padding, window.innerHeight - padding - tooltipHeight);
                }
                return { x, y };
            };

            const showScenarioTooltip = (event, payload) => {
                if (!payload) return;
                const anchor = event?.currentTarget;
                scenarioTooltipAnchorRef.current = anchor || null;
                const anchorRect = anchor?.getBoundingClientRect ? anchor.getBoundingClientRect() : null;
                const position = computeScenarioTooltipPosition(anchorRect || {
                    left: event.clientX,
                    right: event.clientX,
                    top: event.clientY,
                    bottom: event.clientY,
                    width: 0,
                    height: 0
                });
                setScenarioTooltip({
                    ...payload,
                    visible: true,
                    x: position.x,
                    y: position.y
                });
            };

            const showScenarioTooltipFromElement = (element, payload) => {
                if (!element || !payload) return;
                scenarioTooltipAnchorRef.current = element;
                const rect = element.getBoundingClientRect();
                const position = computeScenarioTooltipPosition(rect);
                setScenarioTooltip({
                    ...payload,
                    visible: true,
                    x: position.x,
                    y: position.y
                });
            };

            const moveScenarioTooltip = () => {
                const anchor = scenarioTooltipAnchorRef.current;
                if (!anchor) return;
                setScenarioTooltip(prev => {
                    if (!prev.visible) return prev;
                    const position = computeScenarioTooltipPosition(anchor);
                    if (position.x === prev.x && position.y === prev.y) return prev;
                    return {
                        ...prev,
                        x: position.x,
                        y: position.y
                    };
                });
            };

            const hideScenarioTooltip = () => {
                scenarioTooltipAnchorRef.current = null;
                setScenarioTooltip(prev => (prev.visible ? { ...prev, visible: false } : prev));
            };

            const computeScenarioEdgePaths = React.useCallback(() => {
                if (perfEnabled) {
                    perfCountersRef.current.edgeComputes += 1;
                    performance.mark('scenarioEdgeCompute:start');
                }
                const container = scenarioTimelineRef.current;
                if (!container) {
                    return { width: 0, height: 0, paths: [] };
                }
                const containerRect = container.getBoundingClientRect();
                const scrollLeft = container.scrollLeft || 0;
                const scrollTop = container.scrollTop || 0;
                const visibleRects = new Map();
                const visibleKeys = new Set();
                scenarioIssueRefMap.current.forEach((node, key) => {
                    if (!node || !node.getBoundingClientRect) return;
                    const rect = node.getBoundingClientRect();
                    visibleRects.set(key, {
                        x: rect.left - containerRect.left + scrollLeft,
                        y: rect.top - containerRect.top + scrollTop,
                        width: rect.width,
                        height: rect.height
                    });
                    visibleKeys.add(key);
                });

                const lanes = container.querySelector('.scenario-lanes');
                const track = container.querySelector('.scenario-lane-track');
                const lanesRect = lanes ? lanes.getBoundingClientRect() : null;
                const trackRect = track ? track.getBoundingClientRect() : null;
                const lanesTop = lanesRect ? lanesRect.top - containerRect.top + scrollTop : 0;
                const trackLeft = trackRect ? trackRect.left - containerRect.left + scrollLeft : (scenarioLayout.labelWidth || 0);

                const getFallbackRect = (issueKey) => {
                    const pos = scenarioPositions[issueKey];
                    if (!pos) return null;
                    return {
                        x: trackLeft + pos.xStart,
                        y: lanesTop + pos.y,
                        width: Math.max(2, pos.xEnd - pos.xStart),
                        height: pos.height
                    };
                };

                const baseEdges = scenarioHoverKey
                    ? (scenarioEpicFocus ? scenarioFocusEdges : scenarioEdgeCandidates)
                    : (scenarioEpicFocus ? scenarioFocusEdges : scenarioBaselineEdges);
                const edgeMap = new Map();
                baseEdges.forEach(edge => {
                    edgeMap.set(`${edge.from}-${edge.to}-${edge.type || 'link'}`, edge);
                });
                if (scenarioHoverKey) {
                    scenarioActiveEdges.forEach(edge => {
                        edgeMap.set(`${edge.from}-${edge.to}-${edge.type || 'link'}`, edge);
                    });
                }

                const paths = [];
                edgeMap.forEach((edge) => {
                    const fromVisible = visibleKeys.has(edge.from);
                    const toVisible = visibleKeys.has(edge.to);
                    if (!fromVisible && !toVisible) return;
                    const fromRect = visibleRects.get(edge.from) || getFallbackRect(edge.from);
                    const toRect = visibleRects.get(edge.to) || getFallbackRect(edge.to);
                    if (!fromRect || !toRect) return;
                    const fromInFocus = scenarioEpicFocus && scenarioFocusIssueKeys.has(edge.from);
                    const toInFocus = scenarioEpicFocus && scenarioFocusIssueKeys.has(edge.to);
                    if (scenarioEpicFocus && !fromInFocus && !toInFocus) {
                        return;
                    }
                    const startX = fromRect.x + fromRect.width;
                    const endX = toRect.x;
                    const startY = fromRect.y + fromRect.height / 2;
                    const endY = toRect.y + toRect.height / 2;
                    const dx = endX - startX;
                    let c1x;
                    let c2x;
                    if (dx >= 0) {
                        const curve = Math.min(140, Math.max(20, dx * 0.5));
                        const safeCurve = Math.min(curve, Math.max(10, dx));
                        c1x = startX + safeCurve;
                        c2x = endX - safeCurve;
                    } else {
                        const overlap = Math.abs(dx);
                        const curve = Math.min(200, Math.max(60, overlap * 0.8));
                        const midX = Math.min(container.scrollWidth || container.clientWidth, startX + curve);
                        c1x = midX;
                        c2x = midX;
                    }
                    const isActive = scenarioHoverKey && (edge.from === scenarioHoverKey || edge.to === scenarioHoverKey);
                    const isFaded = scenarioHoverKey && !isActive;
                    const isContextEdge = !isActive && scenarioEpicFocus && ((fromInFocus && !toInFocus) || (!fromInFocus && toInFocus));
                    paths.push({
                        id: `${edge.from}-${edge.to}-${edge.type || 'link'}`,
                        d: `M ${startX} ${startY} C ${c1x} ${startY}, ${c2x} ${endY}, ${endX} ${endY}`,
                        type: edge.type,
                        isActive,
                        isFaded,
                        isContextEdge
                    });
                });
                const result = {
                    width: container.scrollWidth || container.clientWidth,
                    height: container.scrollHeight || container.clientHeight,
                    paths
                };
                if (perfEnabled) {
                    performance.mark('scenarioEdgeCompute:end');
                    performance.measure(
                        'scenarioEdgeCompute',
                        'scenarioEdgeCompute:start',
                        'scenarioEdgeCompute:end'
                    );
                    performance.clearMarks('scenarioEdgeCompute:start');
                    performance.clearMarks('scenarioEdgeCompute:end');
                    performance.clearMeasures('scenarioEdgeCompute');
                }
                return result;
            }, [
                scenarioTimelineIssueKeys,
                scenarioEpicFocus,
                scenarioEdgeCandidates,
                scenarioFocusEdges,
                scenarioBaselineEdges,
                scenarioActiveEdges,
                scenarioHoverKey,
                scenarioFocusIssueKeys,
                scenarioPositions,
                scenarioLayout.labelWidth,
                perfEnabled
            ]);

            const clearScenarioEpicFocus = () => {
                if (!scenarioEpicFocus) return;
                const restore = scenarioFocusRestoreRef.current;
                setScenarioEpicFocus(null);
                hideScenarioTooltip();
                setScenarioRangeOverride(restore?.rangeOverride || null);
                if (restore?.laneMode === 'epic') {
                    scenarioSkipAutoCollapseRef.current = true;
                }
                if (restore?.laneMode && restore.laneMode !== scenarioLaneMode) {
                    setScenarioLaneMode(restore.laneMode);
                }
                if (restore?.collapsedLanes) {
                    setScenarioCollapsedLanes(restore.collapsedLanes);
                }
                if (scenarioTimelineRef.current && typeof restore?.scrollTop === 'number') {
                    scenarioTimelineRef.current.scrollTo({ top: restore.scrollTop, behavior: 'auto' });
                }
                scenarioFocusRestoreRef.current = null;
            };

            const focusScenarioEpic = (epicKey, epicSummary) => {
                if (!epicKey) return;
                if (scenarioEpicFocus?.key === epicKey) {
                    clearScenarioEpicFocus();
                    return;
                }
                if (!scenarioEpicFocus) {
                    scenarioFocusRestoreRef.current = {
                        laneMode: scenarioLaneMode,
                        collapsedLanes: { ...scenarioCollapsedLanes },
                        scrollTop: scenarioTimelineRef.current?.scrollTop || 0,
                        rangeOverride: scenarioRangeOverride
                    };
                }
                const cleanedSummary = normalizeScenarioSummary(epicSummary) || epicKey;
                setScenarioEpicFocus({ key: epicKey, summary: cleanedSummary });
                if (scenarioLaneMode !== 'epic') {
                    setScenarioLaneMode('epic');
                }
                const DAY_MS = 24 * 60 * 60 * 1000;
                let minStart = null;
                let maxEnd = null;
                scenarioIssues.forEach(issue => {
                    if (issue.epicKey !== epicKey) return;
                    const start = parseScenarioDate(issue.start);
                    const end = parseScenarioDate(issue.end);
                    if (!start || !end) return;
                    if (!minStart || start < minStart) minStart = start;
                    if (!maxEnd || end > maxEnd) maxEnd = end;
                });
                if (minStart && maxEnd) {
                    const span = Math.max(1, maxEnd - minStart);
                    const padding = Math.max(DAY_MS * 2, span * 0.06);
                    setScenarioRangeOverride({
                        start: new Date(minStart.getTime() - padding),
                        end: new Date(maxEnd.getTime() + padding)
                    });
                } else {
                    setScenarioRangeOverride(null);
                }
            };

            const scheduleScenarioEdgeUpdate = React.useCallback(() => {
                if (!showScenario) return;
                if (document.hidden) return;
                if (perfEnabled) {
                    perfCountersRef.current.edgeRequests += 1;
                }
                if (scenarioEdgeFrameRef.current) return;
                if (scenarioEdgeUpdatePendingRef.current) return;
                scenarioEdgeUpdatePendingRef.current = true;
                scenarioEdgeFrameRef.current = window.requestAnimationFrame(() => {
                    scenarioEdgeFrameRef.current = null;
                    scenarioEdgeUpdatePendingRef.current = false;
                    if (perfEnabled) {
                        perfCountersRef.current.edgeFrames += 1;
                    }
                    const nextRender = computeScenarioEdgePaths();
                    setScenarioEdgeRender(prev => (areScenarioEdgeRendersEqual(prev, nextRender) ? prev : nextRender));
                });
            }, [computeScenarioEdgePaths, showScenario, perfEnabled]);

            const scrollToScenarioIssue = (issueKey) => {
                if (scenarioEpicFocus) {
                    scenarioPendingScrollRef.current = issueKey;
                    clearScenarioEpicFocus();
                    return;
                }
                const issue = scenarioIssueByKey.get(issueKey);
                if (!issue || !scenarioTimelineRef.current) return;
                const lane = scenarioLaneForIssue(issue);
                if (scenarioLaneMode === 'epic') {
                    setScenarioCollapsedLanes(prev => ({ ...prev, [lane]: false }));
                }
                const position = scenarioPositions[issueKey];
                if (!position) return;
                const container = scenarioTimelineRef.current;
                const axis = container.querySelector('.scenario-axis');
                const axisOffset = axis ? axis.offsetHeight : 0;
                const targetTop = Math.max(0, position.y + axisOffset - container.clientHeight / 2);
                container.scrollTo({ top: targetTop, behavior: 'smooth' });
                setScenarioFlashKey(issueKey);
                window.setTimeout(() => {
                    setScenarioFlashKey(current => (current === issueKey ? null : current));
                }, 1400);
            };

            useEffect(() => {
                if (scenarioEpicFocus) return;
                const pendingKey = scenarioPendingScrollRef.current;
                if (!pendingKey) return;
                if (!scenarioPositions[pendingKey]) return;
                scenarioPendingScrollRef.current = null;
                scrollToScenarioIssue(pendingKey);
            }, [scenarioEpicFocus, scenarioPositions]);

            useEffect(() => {
                if (!scenarioEpicFocus || !scenarioTimelineRef.current) return;
                const laneMeta = scenarioLaneMeta.meta.get(scenarioEpicFocus.key);
                if (!laneMeta) return;
                const container = scenarioTimelineRef.current;
                const axis = container.querySelector('.scenario-axis');
                const axisOffset = axis ? axis.offsetHeight : 0;
                const targetTop = Math.max(0, laneMeta.offset - axisOffset);
                container.scrollTo({ top: targetTop, behavior: 'auto' });
            }, [scenarioEpicFocus, scenarioLaneMeta]);

            useEffect(() => {
                if (!scenarioEpicFocus) return;
                const handleKey = (event) => {
                    if (event.key === 'Escape') {
                        clearScenarioEpicFocus();
                    }
                };
                window.addEventListener('keydown', handleKey);
                return () => {
                    window.removeEventListener('keydown', handleKey);
                };
            }, [scenarioEpicFocus]);

            useEffect(() => {
                if (isCompletedSprintSelected && showPlanning) {
                    setShowPlanning(false);
                }
            }, [isCompletedSprintSelected, showPlanning]);

            useEffect(() => {
                if (isFutureSprintSelected && showStats) {
                    setShowStats(false);
                }
            }, [isFutureSprintSelected, showStats]);

            const baseFilteredTasks = React.useMemo(() => {
                const query = searchQuery.trim().toLowerCase();
                return tasks.filter(task => {
                    // Filter by search query
                    if (query !== '') {
	                    const summary = task.fields.summary?.toLowerCase() || '';
	                    const key = String(task.key || '').toLowerCase();
	                    const assignee = task.fields.assignee?.displayName?.toLowerCase() || '';
                        const epicKey = String(task.fields.epicKey || '').toLowerCase();
                        const epicSummary = task.fields.epicKey ? (epicDetails[task.fields.epicKey]?.summary?.toLowerCase() || '') : '';
                        const epicAssignee = task.fields.epicKey ? (epicDetails[task.fields.epicKey]?.assignee?.displayName?.toLowerCase() || '') : '';

                        if (!summary.includes(query) && !key.includes(query) && !assignee.includes(query) &&
                            !epicAssignee.includes(query) && !epicKey.includes(query) && !epicSummary.includes(query)) {
                            return false;
                        }
                    }

                    // Filter by Team
                    if (!isAllTeamsSelected) {
                        const teamInfo = getTeamInfo(task);
                        if (!selectedTeamSet.has(teamInfo.id)) {
                            return false;
                        }
                    }

                    // Filter by Killed status
                    if (!showKilled && task.fields.status?.name === 'Killed') {
                        return false;
                    }

                    // Filter by Done status
                    if (!showDone && task.fields.status?.name === 'Done') {
                        return false;
                    }

                    // Filter by task type
                    const isTech = task.key.startsWith('TECH-');
                    if (isTech && !showTech) {
                        return false;
                    }
                    if (!isTech && !showProduct) {
                        return false;
                    }
                    return true;
                });
            }, [
                tasks,
                searchQuery,
                epicDetails,
                isAllTeamsSelected,
                selectedTeamSet,
                showKilled,
                showDone,
                showTech,
                showProduct
            ]);

            const selectionTasks = baseFilteredTasks;

            const visibleTasks = React.useMemo(() => {
                return baseFilteredTasks.filter(task => {
                    // Filter by status (from clickable elements)
                    if (statusFilter === 'in-progress') {
                        return task.fields.status?.name === 'In Progress';
                    }
                    if (statusFilter === 'todo-accepted') {
                        const status = task.fields.status?.name;
                        return status === 'To Do' || status === 'Pending' || status === 'Accepted';
                    }
                    if (statusFilter === 'done') {
                        return task.fields.status?.name === 'Done';
                    }
                    if (statusFilter === 'high-priority') {
                        const priority = task.fields.priority?.name;
                        return priority === 'Blocker' || priority === 'Highest' ||
                               priority === 'Critical' || priority === 'High';
                    }
                    if (statusFilter === 'minor-priority') {
                        const priority = task.fields.priority?.name;
                        return priority === 'Minor' || priority === 'Low' ||
                               priority === 'Trivial' || priority === 'Lowest';
                    }
                    return true;
                });
            }, [baseFilteredTasks, statusFilter]);
            const visibleTaskKeySet = React.useMemo(() => {
                const keys = new Set();
                visibleTasks.forEach(task => {
                    if (task?.key) {
                        keys.add(task.key);
                    }
                });
                return keys;
            }, [visibleTasks]);

            const statsTeams = effectiveStatsData?.teams || [];
            const allowedStatsTeamIds = React.useMemo(() => {
                if (!isAllTeamsSelected) {
                    return new Set(Array.from(selectedTeamSet));
                }
                return null;
            }, [isAllTeamsSelected, selectedTeamSet]);

            const filteredStatsTeams = statsTeams.filter(team => {
                if (!allowedStatsTeamIds) return true;
                const id = team.id || team.name || 'unknown';
                return allowedStatsTeamIds.has(id);
            });

            const priorityTeamIds = React.useMemo(() => {
                if (!isAllTeamsSelected) {
                    return Array.from(selectedTeamSet);
                }
                return teamOptions
                    .map(team => team.id)
                    .filter(id => id && id !== 'all');
            }, [isAllTeamsSelected, selectedTeamSet, teamOptions]);

            const getStatsTeamLabel = (team) => {
                if (!team) return 'Unknown Team';
                if (!isAllTeamsSelected && team.id && teamNameById.has(team.id)) {
                    return teamNameById.get(team.id);
                }
                return team.name || team.id || 'Unknown Team';
            };

            const priorityRows = React.useMemo(() => {
                const totals = {};
                const pointsTotals = {};
                (filteredStatsTeams || []).forEach(team => {
                    Object.entries(team.priorities || {}).forEach(([priorityName, counts]) => {
                        const label = getPriorityLabel(priorityName);
                        if (!totals[label]) {
                            totals[label] = { done: 0, incomplete: 0, killed: 0 };
                        }
                        totals[label].done += counts.done || 0;
                        totals[label].incomplete += counts.incomplete || 0;
                        totals[label].killed += counts.killed || 0;
                    });
                    Object.entries(team.priorityPoints || {}).forEach(([priorityName, points]) => {
                        const label = getPriorityLabel(priorityName);
                        pointsTotals[label] = (pointsTotals[label] || 0) + (points || 0);
                    });
                });
                return Object.entries(totals)
                    .map(([name, counts]) => ({
                        name,
                        done: counts.done,
                        incomplete: counts.incomplete,
                        killed: counts.killed,
                        rate: computeRate(counts),
                        points: pointsTotals[name] || 0
                    }))
                    .sort((a, b) => {
                        const orderA = priorityOrder[a.name] || 999;
                        const orderB = priorityOrder[b.name] || 999;
                        if (orderA !== orderB) return orderA - orderB;
                        return String(a.name || '').localeCompare(String(b.name || ''));
                    });
            }, [filteredStatsTeams, priorityOrder]);

            const priorityRadar = React.useMemo(() => {
                const series = (filteredStatsTeams || []).map(team => {
                    const pointsByPriority = {};
                    Object.entries(team.priorityPoints || {}).forEach(([priorityName, points]) => {
                        const label = getPriorityLabel(priorityName);
                        pointsByPriority[label] = (pointsByPriority[label] || 0) + (points || 0);
                    });
                    return {
                        id: team.id || team.name || 'unknown',
                        name: getStatsTeamLabel(team),
                        pointsByPriority
                    };
                });
                const maxValue = Math.max(
                    1,
                    ...series.flatMap(item => priorityAxis.map(axis => item.pointsByPriority[axis] || 0))
                );
                return { series, maxValue };
            }, [filteredStatsTeams, getStatsTeamLabel, priorityAxis]);

            const getTeamScopedMetrics = (team, projectKey = 'all') => {
                if (!team) {
                    return { done: 0, incomplete: 0, killed: 0, priorities: {} };
                }
                if (projectKey === 'all') {
                    return {
                        done: team.done || 0,
                        incomplete: team.incomplete || 0,
                        killed: team.killed || 0,
                        priorities: team.priorities || {}
                    };
                }
                const projectScope = team.projects?.[projectKey];
                return {
                    done: projectScope?.done || 0,
                    incomplete: projectScope?.incomplete || 0,
                    killed: projectScope?.killed || 0,
                    priorities: projectScope?.priorities || {}
                };
            };

            const statsTeamRows = filteredStatsTeams.map(team => {
                const scoped = getTeamScopedMetrics(team);
                const scopedProduct = getTeamScopedMetrics(team, 'product');
                const scopedTech = getTeamScopedMetrics(team, 'tech');
                const weighted = computePriorityWeighted(scoped.priorities);
                const weightedProduct = computePriorityWeighted(scopedProduct.priorities);
                const weightedTech = computePriorityWeighted(scopedTech.priorities);
                const straightRate = computeRate(scoped);
                const weightedRate = computeRate(weighted);
                return {
                    id: team.id || team.name || 'unknown',
                    name: getStatsTeamLabel(team),
                    straight: scoped,
                    product: scopedProduct,
                    tech: scopedTech,
                    weighted,
                    weightedProduct,
                    weightedTech,
                    straightRate,
                    weightedRate,
                    priorityPoints: team.priorityPoints || {}
                };
            });

            const statsTotals = statsTeamRows.reduce((acc, row) => {
                acc.straight.done += row.straight.done;
                acc.straight.incomplete += row.straight.incomplete;
                acc.straight.killed += row.straight.killed;
                acc.product.done += row.product.done;
                acc.product.incomplete += row.product.incomplete;
                acc.product.killed += row.product.killed;
                acc.tech.done += row.tech.done;
                acc.tech.incomplete += row.tech.incomplete;
                acc.tech.killed += row.tech.killed;
                acc.weighted.done += row.weighted.done;
                acc.weighted.incomplete += row.weighted.incomplete;
                acc.weighted.killed += row.weighted.killed;
                acc.weightedProduct.done += row.weightedProduct.done;
                acc.weightedProduct.incomplete += row.weightedProduct.incomplete;
                acc.weightedProduct.killed += row.weightedProduct.killed;
                acc.weightedTech.done += row.weightedTech.done;
                acc.weightedTech.incomplete += row.weightedTech.incomplete;
                acc.weightedTech.killed += row.weightedTech.killed;
                return acc;
            }, {
                straight: { done: 0, incomplete: 0, killed: 0 },
                product: { done: 0, incomplete: 0, killed: 0 },
                tech: { done: 0, incomplete: 0, killed: 0 },
                weighted: { done: 0, incomplete: 0, killed: 0 },
                weightedProduct: { done: 0, incomplete: 0, killed: 0 },
                weightedTech: { done: 0, incomplete: 0, killed: 0 }
            });
            const groupTasksByEpic = (taskList) => {
                const grouped = {};
                taskList.forEach(task => {
                    const epicKey = task.fields.epicKey || 'NO_EPIC';
                    if (!grouped[epicKey]) {
                        if (epicOrderRef.current[epicKey] === undefined) {
                            epicOrderRef.current[epicKey] = epicOrderCounterRef.current++;
                        }
                        grouped[epicKey] = {
                            epic: epicDetails[epicKey] || null,
                            key: epicKey,
                            tasks: [],
                            storyPoints: 0,
                            parentSummary: task.fields.parentSummary || null
                        };
                    }

                    grouped[epicKey].tasks.push(task);
                    const sp = parseFloat(task.fields.customfield_10004 || 0);
                    if (!Number.isNaN(sp)) {
                        grouped[epicKey].storyPoints += sp;
                    }
                    if (!grouped[epicKey].parentSummary && task.fields.parentSummary) {
                        grouped[epicKey].parentSummary = task.fields.parentSummary;
                    }
                });
                return grouped;
            };

            const epicGroups = React.useMemo(() => {
                return Object.values(groupTasksByEpic(visibleTasks))
                    .sort((a, b) => (epicOrderRef.current[a.key] ?? 999999) - (epicOrderRef.current[b.key] ?? 999999));
            }, [visibleTasks, epicDetails]);

            const dependencyTasks = React.useMemo(
                () => [...loadedProductTasks, ...loadedTechTasks],
                [loadedProductTasks, loadedTechTasks]
            );
            const dependencyKeySignature = React.useMemo(() => {
                const keys = Array.from(new Set(dependencyTasks.map(task => task.key).filter(Boolean)));
                return keys.sort().join('|');
            }, [dependencyTasks]);

            useEffect(() => {
                if (!showDependencies && !showBlockedAlert) {
                    setDependencyData({});
                    return;
                }
                if (!dependencyKeySignature) {
                    setDependencyData({});
                    return;
                }
                const keys = dependencyKeySignature.split('|').filter(Boolean);
                fetchDependencies(keys);
            }, [showDependencies, showBlockedAlert, dependencyKeySignature]);

            useEffect(() => {
                if (!showDependencies) {
                    setDependencyFocus(null);
                }
            }, [showDependencies]);

            const issueByKey = React.useMemo(() => {
                const map = new Map();
                dependencyTasks.forEach(task => {
                    if (task.key) {
                        map.set(task.key, task);
                    }
                });
                return map;
            }, [dependencyTasks]);

            const focusRelatedSet = React.useMemo(() => {
                return new Set(dependencyFocus?.relatedKeys || []);
            }, [dependencyFocus]);

            const summaryStats = React.useMemo(() => {
                const counts = {
                    highPriority: 0,
                    minorPriority: 0,
                    done: 0,
                    inProgress: 0,
                    todoAccepted: 0
                };
                const points = {
                    total: 0,
                    done: 0,
                    highPriority: 0,
                    minorPriority: 0,
                    inProgress: 0,
                    todoAccepted: 0
                };
                baseFilteredTasks.forEach(task => {
                    const priority = task.fields.priority?.name;
                    const status = task.fields.status?.name;
                    const sp = parseFloat(task.fields.customfield_10004 || 0);
                    const storyPoints = Number.isNaN(sp) ? 0 : sp;
                    points.total += storyPoints;

                    const isHigh = priority === 'Blocker' || priority === 'Highest' ||
                        priority === 'Critical' || priority === 'High';
                    const isMinor = priority === 'Minor' || priority === 'Low' ||
                        priority === 'Trivial' || priority === 'Lowest';
                    if (isHigh) {
                        counts.highPriority += 1;
                        points.highPriority += storyPoints;
                    }
                    if (isMinor) {
                        counts.minorPriority += 1;
                        points.minorPriority += storyPoints;
                    }
                    if (status === 'Done') {
                        counts.done += 1;
                        points.done += storyPoints;
                    }
                    if (status === 'In Progress') {
                        counts.inProgress += 1;
                        points.inProgress += storyPoints;
                    }
                    if (status === 'To Do' || status === 'Pending' || status === 'Accepted') {
                        counts.todoAccepted += 1;
                        points.todoAccepted += storyPoints;
                    }
                });
                return { counts, points };
            }, [baseFilteredTasks]);

            const highPriorityCount = summaryStats.counts.highPriority;
            const minorPriorityCount = summaryStats.counts.minorPriority;
            const doneTasksCount = summaryStats.counts.done;
            const inProgressTasksCount = summaryStats.counts.inProgress;
            const todoAcceptedTasksCount = summaryStats.counts.todoAccepted;
            const totalStoryPoints = summaryStats.points.total;
            const doneStoryPoints = summaryStats.points.done;
            const highPriorityStoryPoints = summaryStats.points.highPriority;
            const minorPriorityStoryPoints = summaryStats.points.minorPriority;
            const inProgressStoryPoints = summaryStats.points.inProgress;
            const todoAcceptedStoryPoints = summaryStats.points.todoAccepted;

            const removeTask = (task) => {
                const taskKey = task?.key;
                if (!taskKey) return;
                setProductTasks(prev => prev.filter(t => t.key !== taskKey));
                setTechTasks(prev => prev.filter(t => t.key !== taskKey));
            };

            const prefersReducedMotion = () => (
                window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches
            );

            const highlightTaskItem = (element) => {
                if (!element) return;
                if (alertHighlightRef.current && alertHighlightRef.current !== element) {
                    alertHighlightRef.current.classList.remove('task-highlight');
                }
                alertHighlightRef.current = element;
                element.classList.add('task-highlight');
                if (alertHighlightTimeoutRef.current) {
                    window.clearTimeout(alertHighlightTimeoutRef.current);
                }
                alertHighlightTimeoutRef.current = window.setTimeout(() => {
                    element.classList.remove('task-highlight');
                }, 2200);
            };

            const scrollToTaskItem = (taskKey) => {
                if (!taskKey) return false;
                const element = document.querySelector(`[data-issue-key="${taskKey}"]`);
                if (!element) return false;
                element.scrollIntoView({
                    behavior: prefersReducedMotion() ? 'auto' : 'smooth',
                    block: 'center'
                });
                highlightTaskItem(element);
                return true;
            };

            const handleAlertStoryClick = (taskKey) => {
                if (!scrollToTaskItem(taskKey) && jiraUrl) {
                    window.open(`${jiraUrl}/browse/${taskKey}`, '_blank', 'noopener,noreferrer');
                }
            };

            const dismissAlertItem = (taskKey) => {
                if (!taskKey) return;
                alertDismissedRef.current = true;
                setDismissedAlertKeys(prev => (prev.includes(taskKey) ? prev : [...prev, taskKey]));
            };

            const getDependencyKeys = React.useCallback((taskKey, action) => {
                if (!taskKey) return [];
                const entries = (dependencyData[taskKey] || [])
                    .filter(dep => dep.key && dep.category === 'dependency');
                const direction = action === 'dependents' ? 'inward' : 'outward';
                const seen = new Set();
                return entries
                    .filter(dep => dep.direction === direction)
                    .filter(dep => {
                        const key = `${dep.key}-${dep.direction}`;
                        if (seen.has(key)) return false;
                        seen.add(key);
                        return true;
                    })
                    .map(dep => dep.key)
                    .filter(Boolean);
            }, [dependencyData]);

            const getBlockLinkBuckets = (entries, taskKey) => {
                const blockedBy = [];
                const blocks = [];
                (entries || []).forEach(dep => {
                    if (!dep?.key || !taskKey) return;
                    const otherKey = dep.key !== taskKey
                        ? dep.key
                        : (dep.prereqKey === taskKey ? dep.dependentKey : dep.prereqKey);
                    if (!otherKey) return;
                    if (dep.dependentKey === taskKey) {
                        blockedBy.push(otherKey);
                        return;
                    }
                    if (dep.prereqKey === taskKey) {
                        blocks.push(otherKey);
                        return;
                    }
                    if (dep.direction === 'inward') {
                        blockedBy.push(otherKey);
                        return;
                    }
                    if (dep.direction === 'outward') {
                        blocks.push(otherKey);
                    }
                });
                return {
                    blockedBy: Array.from(new Set(blockedBy)),
                    blocks: Array.from(new Set(blocks))
                };
            };

            const getBlockKeys = React.useCallback((taskKey, action) => {
                if (!taskKey) return [];
                const entries = (dependencyData[taskKey] || [])
                    .filter(dep => dep.key && dep.category === 'block');
                const { blockedBy, blocks } = getBlockLinkBuckets(entries, taskKey);
                return action === 'blocks' ? blocks : blockedBy;
            }, [dependencyData]);

            const getFocusKeys = React.useCallback((taskKey, action) => {
                if (action === 'blocked-by' || action === 'blocks') {
                    return getBlockKeys(taskKey, action);
                }
                return getDependencyKeys(taskKey, action);
            }, [getBlockKeys, getDependencyKeys]);

            const handleDependencyFocusClick = (event) => {
                const button = event.target.closest('button[data-dep-chip]');
                if (button) {
                    event.preventDefault();
                    const taskKey = button.getAttribute('data-task-key');
                    const action = button.getAttribute('data-dep-chip');
                    if (!taskKey || !action) return;
                    if (dependencyFocus && dependencyFocus.taskKey === taskKey && dependencyFocus.action === action) {
                        setDependencyFocus(null);
                        return;
                    }
                    const dependencyKeys = getFocusKeys(taskKey, action);
                    const relatedKeys = Array.from(new Set([taskKey, ...dependencyKeys]));
                    const missingKeys = dependencyKeys.filter(key => !issueByKey.has(key));
                    setDependencyFocus({
                        taskKey,
                        action,
                        relatedKeys,
                        dependencyKeys,
                        missingKeys
                    });
                    return;
                }
                if (dependencyFocus && !event.target.closest('.task-item')) {
                    setDependencyFocus(null);
                }
            };

            useEffect(() => {
                if (!dependencyFocus) return;
                const handleKey = (event) => {
                    if (event.key === 'Escape') {
                        setDependencyFocus(null);
                    }
                };
                window.addEventListener('keydown', handleKey);
                return () => window.removeEventListener('keydown', handleKey);
            }, [dependencyFocus]);

            useEffect(() => {
                if (!dependencyFocus) return;
                const missingKeys = (dependencyFocus.missingKeys || []).filter(key => !dependencyLookupCache[key]);
                if (!missingKeys.length) return;
                let isCancelled = false;
                const controller = registerSprintFetch();
                const fetchLookup = async () => {
                    setDependencyLookupLoading(true);
                    try {
                        const response = await fetch(
                            `${BACKEND_URL}/api/issues/lookup?keys=${encodeURIComponent(missingKeys.join(','))}`,
                            { signal: controller.signal }
                        );
                        if (!response.ok) {
                            console.error('Dependency lookup failed:', response.status);
                            return;
                        }
                        const data = await response.json();
                        if (isCancelled) return;
                        const issues = data.issues || [];
                        setDependencyLookupCache(prev => {
                            const next = { ...prev };
                            issues.forEach(issue => {
                                if (issue.key) {
                                    next[issue.key] = issue;
                                }
                            });
                            return next;
                        });
                    } catch (err) {
                        if (err.name === 'AbortError') return;
                        console.error('Dependency lookup error:', err);
                    } finally {
                        if (!isCancelled) {
                            setDependencyLookupLoading(false);
                        }
                        cleanupSprintFetch(controller);
                    }
                };
                fetchLookup();
                return () => {
                    isCancelled = true;
                    try {
                        controller.abort();
                    } catch (err) {
                        // ignore
                    }
                };
            }, [dependencyFocus, dependencyLookupCache]);

            const toggleTaskSelection = (taskKey) => {
                setSelectedTasks(prev => {
                    const newSelected = { ...prev };
                    if (newSelected[taskKey]) {
                        delete newSelected[taskKey];
                    } else {
                        newSelected[taskKey] = true;
                    }
                    return newSelected;
                });
            };

            const clearSelectedTasks = () => {
                setSelectedTasks({});
            };

            const selectPlanningTasksByStatus = (statuses) => {
                const allowed = new Set((statuses || []).map(normalizeStatus));
                setSelectedTasks(() => {
                    const next = {};
                    selectionTasks.forEach(task => {
                        const status = normalizeStatus(task.fields.status?.name);
                        if (allowed.has(status)) {
                            next[task.key] = true;
                        }
                    });
                    return next;
                });
            };

            const includePlanningTasksByStatus = (statuses) => {
                const allowed = new Set((statuses || []).map(normalizeStatus));
                setSelectedTasks(prev => {
                    const next = { ...prev };
                    selectionTasks.forEach(task => {
                        const status = normalizeStatus(task.fields.status?.name);
                        if (allowed.has(status)) {
                            next[task.key] = true;
                        }
                    });
                    return next;
                });
            };

            const toggleIncludeByStatus = (statuses) => {
                const allowed = new Set((statuses || []).map(normalizeStatus));
                setSelectedTasks(prev => {
                    const next = { ...prev };
                    const matching = selectionTasks.filter(task =>
                        allowed.has(normalizeStatus(task.fields.status?.name))
                    );
                    const allSelected = matching.length > 0 && matching.every(task => prev[task.key]);
                    matching.forEach(task => {
                        if (allSelected) {
                            delete next[task.key];
                        } else {
                            next[task.key] = true;
                        }
                    });
                    return next;
                });
            };

            // Calculate sum of Story Points for selected tasks
            const calculateSelectedSP = () => {
                let sum = 0;
                selectionTasks.forEach(task => {
                    if (selectedTasks[task.key]) {
                        const sp = task.fields.customfield_10004;
                        if (sp) {
                            sum += parseFloat(sp);
                        }
                    }
                });
                return sum;
            };

            const selectedTasksList = React.useMemo(() => {
                if (!showPlanning) return [];
                return selectionTasks.filter(task => selectedTasks[task.key]);
            }, [showPlanning, selectionTasks, selectedTasks]);
            const acceptedStatusSet = React.useMemo(() => new Set(['accepted', 'in progress']), []);
            const acceptedTasks = React.useMemo(() => {
                if (!showPlanning) return [];
                return selectionTasks.filter(task =>
                    acceptedStatusSet.has(normalizeStatus(task.fields.status?.name))
                );
            }, [showPlanning, selectionTasks, acceptedStatusSet]);
            const todoPendingTasks = React.useMemo(() => {
                if (!showPlanning) return [];
                return selectionTasks.filter(task => {
                    const status = normalizeStatus(task.fields.status?.name);
                    return status === 'to do' || status === 'pending';
                });
            }, [showPlanning, selectionTasks]);
            const isAcceptedIncluded = acceptedTasks.length > 0 &&
                acceptedTasks.every(task => selectedTasks[task.key]);
            const isTodoIncluded = todoPendingTasks.length > 0 &&
                todoPendingTasks.every(task => selectedTasks[task.key]);

            const selectedPlanningTasksList = React.useMemo(() => {
                if (!showPlanning) return [];
                return selectedTasksList.filter(task => {
                    const epicKey = task.fields?.epicKey || 'NO_EPIC';
                    return !excludedEpicSet.has(epicKey);
                });
            }, [showPlanning, selectedTasksList, excludedEpicSet]);
            const selectedSP = React.useMemo(() => {
                if (!showPlanning) return 0;
                return selectedTasksList.reduce((sum, task) => {
                    const sp = parseFloat(task.fields.customfield_10004 || 0);
                    return sum + (Number.isNaN(sp) ? 0 : sp);
                }, 0);
            }, [showPlanning, selectedTasksList]);
            const selectedCount = showPlanning ? selectedTasksList.length : 0;

            const getCapacityStatus = (selected, capacity) => {
                if (!capacity) {
                    return { label: '', text: '', status: '', title: '' };
                }
                const ratio = capacity > 0 ? selected / capacity : 0;
                const overPercent = Math.max(0, (ratio - 1) * 100);
                const underPercent = Math.max(0, (1 - ratio) * 100);
                const status = ratio > 1.2 ? 'over' : ratio < 0.9 ? 'under' : '';
                const suffix = ratio >= 1
                    ? `${overPercent.toFixed(0)}% over`
                    : `${underPercent.toFixed(0)}% under`;
                const shortLabel = ratio >= 1
                    ? `${overPercent.toFixed(0)}% over`
                    : `${underPercent.toFixed(0)}% under`;
                const minToRemove = ratio > 1.2 ? (ratio - 1.2) * capacity : 0;
                const minToAdd = ratio < 0.9 ? (0.9 - ratio) * capacity : 0;
                const title = ratio > 1.2
                    ? `Please remove at least ${minToRemove.toFixed(1)} SP to reach 120%.`
                    : ratio < 0.9
                        ? `Please add at least ${minToAdd.toFixed(1)} SP to reach 90%.`
                        : '';
                return {
                    label: shortLabel,
                    text: `${selected.toFixed(1)} selected | ${capacity.toFixed(1)} capacity | ${suffix}`,
                    status,
                    title
                };
            };

            const getTeamCapacityMeta = (selected, capacity) => {
                if (!capacity) return { text: '', status: '', title: '' };
                const delta = selected - capacity;
                if (delta <= 0) {
                    return {
                        text: `${Math.abs(delta).toFixed(1)} SP left`,
                        status: '',
                        title: ''
                    };
                }
                const pct = capacity > 0 ? (delta / capacity) * 100 : 0;
                const status = pct >= 20 ? 'over' : '';
                return {
                    text: ` ${delta.toFixed(1)} SP  ${pct.toFixed(0)}%`,
                    status,
                    title: 'Please remove some story points or add capacity.'
                };
            };


            const selectedTeamStats = React.useMemo(() => {
                if (!showPlanning) return {};
                return selectedTasksList.reduce((acc, task) => {
                    const teamInfo = getTeamInfo(task);
                    const sp = parseFloat(task.fields.customfield_10004 || 0);
                    if (!acc[teamInfo.id]) {
                        acc[teamInfo.id] = { name: teamInfo.name, storyPoints: 0 };
                    }
                    acc[teamInfo.id].storyPoints += Number.isNaN(sp) ? 0 : sp;
                    return acc;
                }, {});
            }, [showPlanning, selectedTasksList]);

            const selectedProjectStats = React.useMemo(() => {
                if (!showPlanning) return {};
                return selectedPlanningTasksList.reduce((acc, task) => {
                    const projectKey = task.key.startsWith('TECH-') ? 'TECH' : 'PRODUCT';
                    const sp = parseFloat(task.fields.customfield_10004 || 0);
                    if (!acc[projectKey]) {
                        acc[projectKey] = 0;
                    }
                    acc[projectKey] += Number.isNaN(sp) ? 0 : sp;
                    return acc;
                }, {});
            }, [showPlanning, selectedPlanningTasksList]);

            const selectedTeamProjectStats = React.useMemo(() => {
                if (!showPlanning) return {};
                return selectedPlanningTasksList.reduce((acc, task) => {
                    const teamInfo = getTeamInfo(task);
                    const bucket = task.key.startsWith('TECH-') ? 'tech' : 'product';
                    const sp = parseFloat(task.fields.customfield_10004 || 0);
                    if (!acc[teamInfo.id]) {
                        acc[teamInfo.id] = { product: 0, tech: 0 };
                    }
                    acc[teamInfo.id][bucket] += Number.isNaN(sp) ? 0 : sp;
                    return acc;
                }, {});
            }, [showPlanning, selectedPlanningTasksList]);

            const excludedProjectStats = React.useMemo(() => {
                if (!showPlanning) return {};
                return selectedTasksList.reduce((acc, task) => {
                    const epicKey = task.fields?.epicKey || 'NO_EPIC';
                    if (!excludedEpicSet.has(epicKey)) return acc;
                    const projectKey = task.key.startsWith('TECH-') ? 'TECH' : 'PRODUCT';
                    const sp = parseFloat(task.fields.customfield_10004 || 0);
                    if (!acc[projectKey]) {
                        acc[projectKey] = 0;
                    }
                    acc[projectKey] += Number.isNaN(sp) ? 0 : sp;
                    return acc;
                }, {});
            }, [showPlanning, selectedTasksList, excludedEpicSet]);

            const capacitySplit = React.useMemo(() => ({ product: 0.7, tech: 0.3 }), []);
            const capacityMultiplier = showProduct && showTech
                ? 1
                : showProduct
                    ? capacitySplit.product
                    : showTech
                        ? capacitySplit.tech
                        : 1;

            const teamCapacityStats = React.useMemo(() => {
                if (!showPlanning || !capacityEnabled) return {};
                return capacityTasks.reduce((acc, task) => {
                    const status = normalizeStatus(task.fields.status?.name);
                    const sp = parseFloat(task.fields.customfield_10004 || 0);
                    if (!sp) {
                        return acc;
                    }

                    const teamInfo = getTeamInfo(task);
                    if (!acc[teamInfo.id]) {
                        acc[teamInfo.id] = {
                            name: teamInfo.name,
                            product: { todoPending: 0, accepted: 0, postponed: 0 },
                            tech: { todoPending: 0, accepted: 0, postponed: 0 }
                        };
                    }

                    const bucket = task.key.startsWith('TECH-') ? 'tech' : 'product';
                    if (status === 'to do' || status === 'pending') {
                        acc[teamInfo.id][bucket].todoPending += sp;
                    }
                    if (status === 'accepted') {
                        acc[teamInfo.id][bucket].accepted += sp;
                    }
                    if (status === 'postponed') {
                        acc[teamInfo.id][bucket].postponed += sp;
                    }

                    return acc;
                }, {});
            }, [showPlanning, capacityEnabled, capacityTasks]);

            const teamCapacityEntries = React.useMemo(() => {
                return Object.entries(teamCapacityStats)
                    .map(([id, info]) => ({
                        id,
                        name: info.name,
                        product: info.product,
                        tech: info.tech,
                        total: {
                            todoPending: info.product.todoPending + info.tech.todoPending,
                            accepted: info.product.accepted + info.tech.accepted,
                            postponed: info.product.postponed + info.tech.postponed
                        }
                    }))
                    .sort((a, b) => a.name.localeCompare(b.name));
            }, [teamCapacityStats]);

            const displayedTeamCapacityEntries = React.useMemo(() => {
                return !isAllTeamsSelected
                    ? teamCapacityEntries.filter(entry => selectedTeamSet.has(entry.id))
                    : teamCapacityEntries;
            }, [teamCapacityEntries, isAllTeamsSelected, selectedTeamSet]);

            const displayedTeamOptions = React.useMemo(() => {
                return !isAllTeamsSelected
                    ? teamOptions.filter(team => team.id !== 'all' && selectedTeamSet.has(team.id))
                    : teamOptions.filter(team => team.id !== 'all');
            }, [teamOptions, isAllTeamsSelected, selectedTeamSet]);

            const capacityTeamNames = React.useMemo(() => {
                if (!showPlanning || !capacityEnabled) return [];
                return displayedTeamOptions
                    .map(team => toCapacityShortName(team.name))
                    .filter(Boolean);
            }, [showPlanning, capacityEnabled, displayedTeamOptions]);

            useEffect(() => {
                if (!capacityEnabled) return;
                if (!showPlanning) return;
                if (!selectedSprintInfo?.name) return;
                fetchCapacity(selectedSprintInfo.name);
            }, [capacityEnabled, showPlanning, selectedSprintInfo?.name, capacityTeamNames.join('|')]);

            const capacityTeamIds = React.useMemo(() => {
                return !isAllTeamsSelected
                    ? Array.from(selectedTeamSet)
                    : teamCapacityEntries.map(entry => entry.id);
            }, [isAllTeamsSelected, selectedTeamSet, teamCapacityEntries]);

            const getTeamCapacity = (teamName) => {
                if (!capacityEnabled) return 0;
                const key = normalizeCapacityKey(teamName);
                if (!key) return 0;
                if (capacityByTeam[key]) return capacityByTeam[key];
                const entry = Object.entries(capacityByTeam).find(([capacityKey]) =>
                    capacityKey.includes(key) || key.includes(capacityKey)
                );
                return entry ? entry[1] : 0;
            };

            const excludedCapacityByTeamId = React.useMemo(() => {
                if (!capacityEnabled || !showPlanning) return {};
                return capacityTasks.reduce((acc, task) => {
                    const epicKey = task.fields?.epicKey || 'NO_EPIC';
                    if (!excludedEpicSet.has(epicKey)) return acc;
                    const teamInfo = getTeamInfo(task);
                    const sp = parseFloat(task.fields.customfield_10004 || 0);
                    if (Number.isNaN(sp)) return acc;
                    acc[teamInfo.id] = (acc[teamInfo.id] || 0) + sp;
                    return acc;
                }, {});
            }, [capacityEnabled, showPlanning, capacityTasks, excludedEpicSet]);

            const getTeamNetCapacity = (team) => {
                if (!capacityEnabled) return 0;
                const base = getTeamCapacity(team.name);
                const excluded = excludedCapacityByTeamId[team.id] || 0;
                return Math.max(0, base - excluded);
            };

            const capacityTotalsSummary = React.useMemo(() => {
                const totalCapacityBase = capacityEnabled
                    ? displayedTeamOptions.reduce((sum, team) => sum + getTeamCapacity(team.name), 0)
                    : 0;
                const excludedCapacityTotal = capacityEnabled
                    ? displayedTeamOptions.reduce((sum, team) => sum + (excludedCapacityByTeamId[team.id] || 0), 0)
                    : 0;
                const estimatedCapacityRaw = Math.max(0, totalCapacityBase - excludedCapacityTotal);
                return {
                    totalCapacityBase,
                    excludedCapacityTotal,
                    estimatedCapacityRaw,
                    totalCapacityAdjusted: totalCapacityBase * capacityMultiplier,
                    estimatedCapacityAdjusted: estimatedCapacityRaw * capacityMultiplier,
                    excludedCapacityAdjusted: excludedCapacityTotal * capacityMultiplier
                };
            }, [capacityEnabled, displayedTeamOptions, excludedCapacityByTeamId, capacityMultiplier, capacityByTeam]);
            const totalCapacityBase = capacityTotalsSummary.totalCapacityBase;
            const excludedCapacityTotal = capacityTotalsSummary.excludedCapacityTotal;
            const estimatedCapacityRaw = capacityTotalsSummary.estimatedCapacityRaw;
            const totalCapacityAdjusted = capacityTotalsSummary.totalCapacityAdjusted;
            const estimatedCapacityAdjusted = capacityTotalsSummary.estimatedCapacityAdjusted;
            const excludedCapacityAdjusted = capacityTotalsSummary.excludedCapacityAdjusted;
            const capacitySummary = getCapacityStatus(selectedSP, totalCapacityAdjusted);
            const scrollToFirstExcludedEpic = (projectType = 'any') => {
                const firstExcluded = epicGroups.find((epic) => {
                    if (!excludedEpicSet.has(epic.key)) return false;
                    if (projectType === 'any') return true;
                    const hasTech = (epic.tasks || []).some(task => String(task.key || '').startsWith('TECH-'));
                    const hasProduct = (epic.tasks || []).some(task => !String(task.key || '').startsWith('TECH-'));
                    return projectType === 'tech' ? hasTech : hasProduct;
                });
                if (!firstExcluded) return;
                const node = epicRefMap.current.get(firstExcluded.key);
                if (!node) return;
                node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                node.classList.remove('epic-flash');
                void node.offsetWidth;
                node.classList.add('epic-flash');
            };

            const projectCapacity = React.useMemo(() => {
                if (!showPlanning || !capacityEnabled) {
                    return { PRODUCT: 0, TECH: 0 };
                }
                const totals = displayedTeamOptions.reduce((acc, team) => {
                    const teamPlanningCapacity = getTeamNetCapacity(team);
                    if (!teamPlanningCapacity) return acc;
                    const stats = selectedTeamProjectStats[team.id] || { product: 0, tech: 0 };
                    const totalSelected = stats.product + stats.tech;
                    const techHeavy = totalSelected > 0 ? stats.tech >= stats.product : false;
                    const split = techHeavy ? { product: 0.2, tech: 0.8 } : capacitySplit;
                    acc.PRODUCT += teamPlanningCapacity * split.product;
                    acc.TECH += teamPlanningCapacity * split.tech;
                    return acc;
                }, {
                    PRODUCT: 0,
                    TECH: 0
                });
                if (!showProduct) totals.PRODUCT = 0;
                if (!showTech) totals.TECH = 0;
                return totals;
            }, [
                showPlanning,
                capacityEnabled,
                displayedTeamOptions,
                selectedTeamProjectStats,
                showProduct,
                showTech,
                capacitySplit,
                capacityByTeam,
                excludedCapacityByTeamId
            ]);

            const selectedProjectEntries = React.useMemo(() => {
                if (!showPlanning) return [];
                return Object.entries(selectedProjectStats)
                    .map(([id, storyPoints]) => ({
                        id,
                        name: id,
                        storyPoints,
                        capacity: capacityEnabled ? (projectCapacity[id] || 0) : null
                    }))
                    .sort((a, b) => {
                        const order = (key) => {
                            if (key === 'PRODUCT') return 0;
                            if (key === 'TECH') return 1;
                            return 99;
                        };
                        const diff = order(a.id) - order(b.id);
                        if (diff !== 0) return diff;
                        return a.name.localeCompare(b.name);
                    });
            }, [showPlanning, selectedProjectStats, capacityEnabled, projectCapacity]);

            const selectedTeamEntries = React.useMemo(() => {
                if (!showPlanning) return [];
                return displayedTeamOptions.map((team) => ({
                    id: team.id,
                    name: team.name,
                    storyPoints: selectedTeamStats[team.id]?.storyPoints || 0,
                    teamCapacity: capacityEnabled ? getTeamCapacity(team.name) * capacityMultiplier : null,
                    planningCapacity: capacityEnabled ? getTeamNetCapacity(team) * capacityMultiplier : null
                }));
            }, [
                showPlanning,
                displayedTeamOptions,
                selectedTeamStats,
                capacityEnabled,
                capacityMultiplier,
                capacityByTeam,
                excludedCapacityByTeamId
            ]);

            const capacityTotals = React.useMemo(() => {
                if (!showPlanning || !capacityEnabled) {
                    return {
                        product: { todoPending: 0, accepted: 0, postponed: 0 },
                        tech: { todoPending: 0, accepted: 0, postponed: 0 },
                        total: { todoPending: 0, accepted: 0, postponed: 0 }
                    };
                }
                return displayedTeamCapacityEntries.reduce((acc, info) => {
                    acc.product.todoPending += info.product.todoPending;
                    acc.product.accepted += info.product.accepted;
                    acc.product.postponed += info.product.postponed;
                    acc.tech.todoPending += info.tech.todoPending;
                    acc.tech.accepted += info.tech.accepted;
                    acc.tech.postponed += info.tech.postponed;
                    acc.total.todoPending += info.total.todoPending;
                    acc.total.accepted += info.total.accepted;
                    acc.total.postponed += info.total.postponed;
                    return acc;
                }, {
                    product: { todoPending: 0, accepted: 0, postponed: 0 },
                    tech: { todoPending: 0, accepted: 0, postponed: 0 },
                    total: { todoPending: 0, accepted: 0, postponed: 0 }
                });
            }, [showPlanning, capacityEnabled, displayedTeamCapacityEntries]);

            const showTotalsRow = displayedTeamCapacityEntries.length > 1;

            const formatCapacityValue = (value) => {
                const num = Number(value || 0);
                return num.toFixed(1);
            };

            const getMetricClass = (value, type, acceptedValue) => {
                const num = Number(value || 0);
                if (num === 0) {
                    return 'metric-value metric-muted';
                }
                if (type === 'accepted') {
                    return 'metric-value metric-accepted';
                }
                if (type === 'todo' && acceptedValue !== undefined && acceptedValue < num) {
                    return 'metric-value metric-warn';
                }
                return 'metric-value';
            };

            const buildTeamStatusLink = ({ teamId, teamIds, projectName, projectNames, statuses, excludeStatuses, priorityName, issueType }) => {
                const ids = teamIds || (teamId ? [teamId] : []);
                if (!jiraUrl || !ids.length) return '';
                const clauses = [];
                const projects = projectNames || (projectName ? [projectName] : []);
                if (projects.length === 1) {
                    clauses.push(`project = "${projects[0]}"`);
                } else if (projects.length > 1) {
                    const quoted = projects.map(p => `"${p}"`).join(', ');
                    clauses.push(`project in (${quoted})`);
                }
                if (ids.length === 1) {
                    clauses.push(`"Team[Team]" = "${ids[0]}"`);
                } else {
                    const quotedTeams = ids.map(id => `"${id}"`).join(', ');
                    clauses.push(`"Team[Team]" in (${quotedTeams})`);
                }
                if (selectedSprint) {
                    clauses.push(`Sprint = ${selectedSprint}`);
                }
                if (statuses && statuses.length) {
                    if (statuses.length === 1) {
                        clauses.push(`status = "${statuses[0]}"`);
                    } else {
                        const quoted = statuses.map(s => `"${s}"`).join(', ');
                        clauses.push(`status in (${quoted})`);
                    }
                } else if (excludeStatuses && excludeStatuses.length) {
                    const quoted = excludeStatuses.map(s => `"${s}"`).join(', ');
                    clauses.push(`status not in (${quoted})`);
                }
                if (priorityName) {
                    clauses.push(`priority = "${priorityName}"`);
                }
                if (issueType) {
                    clauses.push(`issuetype = "${issueType}"`);
                }
                const jql = encodeURIComponent(clauses.join(' AND '));
                return `${jiraUrl}/issues/?jql=${jql}`;
            };

            const buildStatLink = (value, options) => {
                const count = Number(value || 0);
                if (!count) return '';
                return buildTeamStatusLink(options);
            };

            const buildPriorityStatusLink = ({ priorityName, statuses, excludeStatuses }) => {
                return buildTeamStatusLink({
                    teamIds: priorityTeamIds,
                    statuses,
                    excludeStatuses,
                    priorityName,
                    issueType: 'Story'
                });
            };

            const buildPriorityStatLink = (value, options) => {
                const count = Number(value || 0);
                if (!count) return '';
                return buildPriorityStatusLink(options);
            };

            const buildPostponedLink = ({ teamId, teamIds, projectName, projectNames }) => {
                return buildTeamStatusLink({ teamId, teamIds, projectName, projectNames, statuses: ['Postponed'] });
            };

            const buildTodoPendingLink = ({ teamId, teamIds, projectName, projectNames }) => {
                return buildTeamStatusLink({ teamId, teamIds, projectName, projectNames, statuses: ['To Do', 'Pending'] });
            };

            const buildAcceptedLink = ({ teamId, teamIds, projectName, projectNames }) => {
                return buildTeamStatusLink({ teamId, teamIds, projectName, projectNames, statuses: ['Accepted'] });
            };

            const buildKeyListLink = (keys, { addSprint } = {}) => {
                if (!jiraUrl) return '';
                const list = (keys || []).filter(Boolean);
                if (!list.length) return '';
                const clauses = [`key in (${list.join(', ')})`];
                if (addSprint && selectedSprint) {
                    clauses.push(`Sprint = ${selectedSprint}`);
                }
                const jql = encodeURIComponent(clauses.join(' AND '));
                return `${jiraUrl}/issues/?jql=${jql}`;
            };

            const hasStoryPoints = (task) => {
                const sp = task.fields.customfield_10004;
                if (sp === null || sp === undefined || sp === '') {
                    return false;
                }
                const numeric = parseFloat(sp);
                return !Number.isNaN(numeric) && numeric > 0;
            };

            const isExcludedStatus = (status) => status === 'killed' || status === 'postponed' || status === 'done';
            const getTaskSprintTokens = (task) => {
                const tokens = [];
                const pushToken = (value) => {
                    if (value === null || value === undefined) return;
                    const str = String(value).trim();
                    if (!str) return;
                    tokens.push(str);
                };
                const sprintField = task?.fields?.customfield_10101;
                if (!sprintField) return tokens;
                if (Array.isArray(sprintField)) {
                    sprintField.forEach((entry) => {
                        if (entry && typeof entry === 'object') {
                            pushToken(entry.id);
                            pushToken(entry.name);
                        } else {
                            pushToken(entry);
                        }
                    });
                } else if (typeof sprintField === 'object') {
                    pushToken(sprintField.id);
                    pushToken(sprintField.name);
                } else if (typeof sprintField === 'string') {
                    pushToken(sprintField);
                    const match = sprintField.match(/id=([0-9]+)/);
                    if (match) {
                        pushToken(match[1]);
                    }
                } else {
                    pushToken(sprintField);
                }
                return tokens;
            };
            const isTaskInSelectedSprint = (task) => {
                if (!selectedSprint) return false;
                const tokens = getTaskSprintTokens(task);
                if (!tokens.length) return false;
                const selectedId = String(selectedSprint);
                const selectedName = selectedSprintInfo?.name ? String(selectedSprintInfo.name) : '';
                if (tokens.includes(selectedId)) return true;
                if (selectedName && tokens.includes(selectedName)) return true;
                return false;
            };
            const resolveDependencyStatus = (dep) => {
                if (!dep?.key) return '';
                const issue = issueByKey.get(dep.key);
                const lookup = dependencyLookupCache[dep.key];
                return normalizeStatus(
                    issue?.fields?.status?.name ||
                    issue?.status?.name ||
                    issue?.status ||
                    lookup?.status ||
                    dep.status
                );
            };
            const getBlockedAlertStatusLabel = (task) => {
                const baseLabel = task.fields.status?.name || 'Blocked';
                const entries = (dependencyData[task.key] || [])
                    .filter(dep => dep.category === 'block' && dep.dependentKey === task.key);
                if (!entries.length) return baseLabel;
                const blockersDone = entries.every(dep => resolveDependencyStatus(dep) === 'done');
                return blockersDone ? 'Unblocked' : baseLabel;
            };
            const dismissedAlertSet = React.useMemo(() => new Set(dismissedAlertKeys || []), [dismissedAlertKeys]);

            const blockedTasks = visibleTasks.filter(task => {
                const status = normalizeStatus(task.fields.status?.name);
                if (!status) return false;
                if (isExcludedStatus(status)) return false;
                if (dismissedAlertSet.has(task.key)) return false;
                return status.includes('blocked');
            });

            const consolidatedMissingStories = React.useMemo(() => {
                const byKey = new Map();
                const shouldIncludeUnknownTeam = (task, missing) => {
                    const teamMissing = !task?.fields?.teamId && !task?.fields?.teamName;
                    if (!teamMissing) return true;
                    return true;
                };

                const shouldIncludeByTeam = (task) => {
                    if (isAllTeamsSelected) return true;
                    const teamId = task?.fields?.teamId;
                    const teamName = task?.fields?.teamName;
                    if (!teamId && !teamName) {
                        return true; // can't filter reliably, keep it visible
                    }
                    return selectedTeamSet.has(getTeamInfo(task).id);
                };

                const excluded = (task) => {
                    if (!task?.key) return true;
                    if (dismissedAlertSet.has(task.key)) return true;
                    const status = normalizeStatus(task.fields.status?.name);
                    return isExcludedStatus(status);
                };

                // Start with server-provided missing info, but only keep items in the selected sprint.
                (missingPlanningInfoTasks || []).forEach((task) => {
                    if (!task?.key || excluded(task) || !shouldIncludeByTeam(task)) return;
                    if (!isTaskInSelectedSprint(task)) return;
                    const missing = new Set(task.fields?.missingFields || []);
                    if (!shouldIncludeUnknownTeam(task, missing)) return;
                    if (missing.size === 0) return;
                    byKey.set(task.key, { task, missing });
                });

                // Merge client-side checks (covers missing Story Points / Epic / Team)
                visibleTasks.forEach((task) => {
                    if (!task?.key || excluded(task) || !shouldIncludeByTeam(task)) return;
                    const current = byKey.get(task.key) || { task, missing: new Set() };

                    if (!hasStoryPoints(task)) current.missing.add('Story Points');
                    if (!task.fields?.epicKey) current.missing.add('Epic');
                    if (!task.fields?.teamId && !task.fields?.teamName) current.missing.add('Team');
                    if (!shouldIncludeUnknownTeam(task, current.missing)) return;

                    if (current.missing.size > 0) {
                        // Prefer the server task object if present (may carry extra fields)
                        current.task = current.task || task;
                        byKey.set(task.key, current);
                    }
                });

                return [...byKey.values()]
                    .map(({ task, missing }) => ({ task, missingFields: [...missing] }))
                    .sort((a, b) => {
                        const diff = b.missingFields.length - a.missingFields.length;
                        if (diff !== 0) return diff;
                        const priorityA = priorityOrder[a.task.fields.priority?.name] || 999;
                        const priorityB = priorityOrder[b.task.fields.priority?.name] || 999;
                        if (priorityA !== priorityB) return priorityA - priorityB;
                        return (a.task.fields.summary || '').localeCompare(b.task.fields.summary || '');
                    });
            }, [
                missingPlanningInfoTasks,
                visibleTasks,
                isAllTeamsSelected,
                selectedTeamSet,
                dismissedAlertKeys,
                selectedSprint,
                selectedSprintInfo?.name
            ]);

            const emptyEpics = epicsInScope
                .filter(epic => {
                    const status = normalizeStatus(epic.status?.name);
                    if (status === 'killed' || status === 'done' || status === 'incomplete' || status === 'in progress') return false;
                    if (!isAllTeamsSelected && epic.teamId && !selectedTeamSet.has(epic.teamId)) return false;
                    return true;
                })
                .filter(epic => typeof epic.totalStories === 'number' && epic.totalStories === 0)
                .filter(epic => !dismissedAlertSet.has(epic.key));

	            const readyToCloseStoryStatuses = new Set(['done', 'killed', 'incomplete']);
	            const doneStoryEpics = readyToCloseEpicsInScope
	                .filter(epic => {
	                    const status = normalizeStatus(epic.status?.name);
	                    if (status === 'killed' || status === 'done' || status === 'incomplete') return false;
	                    if (!isAllTeamsSelected && epic.teamId && !selectedTeamSet.has(epic.teamId)) return false;
	                    return true;
	                })
	                .filter(epic => {
	                    const epicStories = readyToCloseTasks.filter(task => {
	                        if (!task.fields?.epicKey) return false;
	                        if (task.fields.epicKey !== epic.key) return false;
	                        if (!isAllTeamsSelected && !selectedTeamSet.has(getTeamInfo(task).id)) return false;
	                        return true;
	                    });
	                    if (epicStories.length === 0) return false;
	                    return epicStories.every(task => readyToCloseStoryStatuses.has(normalizeStatus(task.fields.status?.name)));
	                })
                    .filter(epic => !dismissedAlertSet.has(epic.key));

            const sortByPriorityThenSummary = (a, b) => {
                const priorityA = priorityOrder[a.fields.priority?.name] || 999;
                const priorityB = priorityOrder[b.fields.priority?.name] || 999;
                if (priorityA !== priorityB) return priorityA - priorityB;
                return (a.fields.summary || '').localeCompare(b.fields.summary || '');
            };

            const groupAlertsByTeam = (items, resolveTeam, sortItems) => {
                const groups = new Map();
                (items || []).forEach(item => {
                    const team = resolveTeam(item) || { id: 'unknown', name: 'Unknown Team' };
                    const id = team.id || team.name || 'unknown';
                    const name = team.name || 'Unknown Team';
                    const entry = groups.get(id) || { id, name, items: [] };
                    entry.items.push(item);
                    groups.set(id, entry);
                });
                const list = Array.from(groups.values());
                list.forEach(group => {
                    if (sortItems) {
                        group.items.sort(sortItems);
                    }
                });
                return list.sort((a, b) => a.name.localeCompare(b.name));
            };

            const missingAlertTeams = groupAlertsByTeam(consolidatedMissingStories, (item) => getTeamInfo(item.task));
            const blockedAlertTeams = groupAlertsByTeam(blockedTasks, (task) => getTeamInfo(task), sortByPriorityThenSummary);
            const emptyEpicTeams = groupAlertsByTeam(emptyEpics, (epic) => getEpicTeamInfo(epic), (a, b) => (a.summary || '').localeCompare(b.summary || ''));
            const doneEpicTeams = groupAlertsByTeam(doneStoryEpics, (epic) => getEpicTeamInfo(epic), (a, b) => (a.summary || '').localeCompare(b.summary || ''));
            const alertItemCount = consolidatedMissingStories.length + blockedTasks.length + emptyEpics.length + doneStoryEpics.length;

            const triggerAlertCelebration = React.useCallback(() => {
                if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    return;
                }
                const colors = ['#f97316', '#f59e0b', '#22c55e', '#0ea5e9', '#a855f7', '#14b8a6'];
                const pieces = Array.from({ length: 26 }).map((_, index) => ({
                    id: `${Date.now()}-${index}`,
                    left: Math.random() * 100,
                    size: 6 + Math.random() * 6,
                    delay: Math.random() * 0.3,
                    color: colors[index % colors.length]
                }));
                setAlertCelebrationPieces(pieces);
                if (alertCelebrationTimeoutRef.current) {
                    window.clearTimeout(alertCelebrationTimeoutRef.current);
                }
                alertCelebrationTimeoutRef.current = window.setTimeout(() => {
                    setAlertCelebrationPieces([]);
                }, 2300);
            }, []);

            useEffect(() => {
                if (!alertDismissedRef.current) {
                    alertPrevCountRef.current = alertItemCount;
                    return;
                }
                if (alertPrevCountRef.current > 0 && alertItemCount === 0) {
                    triggerAlertCelebration();
                    alertDismissedRef.current = false;
                }
                alertPrevCountRef.current = alertItemCount;
            }, [alertItemCount, triggerAlertCelebration]);

            useEffect(() => {
                return () => {
                    if (alertCelebrationTimeoutRef.current) {
                        window.clearTimeout(alertCelebrationTimeoutRef.current);
                    }
                    if (alertHighlightTimeoutRef.current) {
                        window.clearTimeout(alertHighlightTimeoutRef.current);
                    }
                };
            }, []);


            useEffect(() => {
                if (!showPlanning) {
                    return;
                }
                const updateOffset = () => {
                    const height = planningPanelRef.current?.getBoundingClientRect().height || 0;
                    setPlanningOffset(height);
                };
                updateOffset();
                window.addEventListener('resize', updateOffset);
                return () => window.removeEventListener('resize', updateOffset);
            }, [showPlanning, selectedCount, selectedSP, teamCapacityEntries.length]);

            const openSelectedInJira = () => {
                if (!jiraUrl) return;
                const keys = capacityTasks
                    .filter(task => selectedTasks[task.key])
                    .map(task => task.key)
                    .sort();
                if (keys.length === 0) return;
                const jql = encodeURIComponent(`key in (${keys.join(', ')})`);
                window.open(`${jiraUrl}/issues/?jql=${jql}`, '_blank', 'noopener,noreferrer');
            };

            return (
                <div className="container" style={{ '--planning-offset': `${planningOffset}px` }}>
                    <header>
                        <div className="subtitle">
                            <span>
                                Jira Execution Planner
                                <span className="subtitle-secondary">  Product &amp; Tech Projects</span>
                            </span>
                            <div className="header-actions">
                                <button
                                    className="secondary compact"
                                    onClick={() => window.location.reload()}
                                    disabled={sprintsLoading}
                                    title="Refresh sprints list from Jira"
                                >
                                    {sprintsLoading ? 'Loading...' : 'Refresh Sprints'}
                                </button>
                                <button
                                    className="secondary compact"
                                    onClick={() => {
                                        loadProductTasks();
                                        loadTechTasks();
                                        loadReadyToCloseProductTasks();
                                        loadReadyToCloseTechTasks();
                                    }}
                                    disabled={loading || selectedSprint === null}
                                    title="Refresh tasks from Jira"
                                >
                                    {loading ? 'Loading...' : 'Refresh Page'}
                                </button>
                                <div className="search-wrap">
                                    <input
                                        type="text"
                                        className="search-input"
                                        placeholder="Search tickets..."
                                        value={searchInput}
                                        onChange={(e) => setSearchInput(e.target.value)}
                                    />
                                    {searchInput && (
                                        <button
                                            className="search-clear"
                                            onClick={() => setSearchInput('')}
                                            title="Clear search"
                                            aria-label="Clear search"
                                        >
                                            
                                        </button>
                                    )}
                                </div>
                            </div>
                        </div>
                        <div className="view-selector">
                            <div className="view-filters">
                                {((groupsConfig.groups || []).length > 1) && (
                                    <>
                                        <label>Group:</label>
                                        <div className="group-dropdown" ref={groupDropdownRef}>
                                            <div
                                                className={`group-dropdown-toggle ${showGroupDropdown ? 'open' : ''}`}
                                                role="button"
                                                tabIndex={groupsLoading ? -1 : 0}
                                                onClick={() => {
                                                    if (groupsLoading) return;
                                                    setShowGroupDropdown(!showGroupDropdown);
                                                }}
                                                onKeyDown={(event) => {
                                                    if (groupsLoading) return;
                                                    if (event.key === 'Enter' || event.key === ' ') {
                                                        event.preventDefault();
                                                        setShowGroupDropdown(!showGroupDropdown);
                                                    }
                                                }}
                                                aria-disabled={groupsLoading}
                                            >
                                                <span>{activeGroup?.name || (groupsLoading ? 'Loading...' : 'Group')}</span>
                                                <svg viewBox="0 0 12 12" fill="currentColor" aria-hidden="true">
                                                    <path d="M6 9L1 4h10z"/>
                                                </svg>
                                            </div>
                                            {showGroupDropdown && (
                                                <div className="group-dropdown-panel">
                                                    {groupsLoading ? (
                                                        <div className="group-dropdown-option">Loading groups...</div>
                                                    ) : (groupsConfig.groups || []).length === 0 ? (
                                                        <div className="group-dropdown-option">No groups yet</div>
                                                    ) : (
                                                        (groupsConfig.groups || []).map(group => (
                                                            <div
                                                                key={group.id}
                                                                className="group-dropdown-option"
                                                                onClick={() => {
                                                                    setActiveGroupId(group.id);
                                                                    setShowGroupDropdown(false);
                                                                }}
                                                            >
                                                                <span>{group.name}</span>
                                                                <div className="group-option-tags">
                                                                    {groupsConfig.defaultGroupId === group.id && (
                                                                        <span className="group-option-default"> Default</span>
                                                                    )}
                                                                    <span className="group-option-meta">
                                                                        {group.teamIds?.length || 0} teams
                                                                    </span>
                                                                </div>
                                                            </div>
                                                        ))
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    </>
                                )}
                                <button
                                    className="secondary compact group-manage-button"
                                    onClick={openGroupManage}
                                    disabled={groupsLoading}
                                    title="Manage team groups"
                                >
                                    Manage
                                </button>
                                <label>Sprint:</label>
                                <div className="sprint-dropdown" ref={sprintDropdownRef}>
                                    <div
                                        className={`sprint-dropdown-toggle ${showSprintDropdown ? 'open' : ''}`}
                                        role="button"
                                        tabIndex={sprintsLoading || availableSprints.length === 0 ? -1 : 0}
                                        onClick={() => {
                                            if (sprintsLoading || availableSprints.length === 0) return;
                                            setShowSprintDropdown(!showSprintDropdown);
                                        }}
                                        onKeyDown={(event) => {
                                            if (sprintsLoading || availableSprints.length === 0) return;
                                            if (event.key === 'Enter' || event.key === ' ') {
                                                event.preventDefault();
                                                setShowSprintDropdown(!showSprintDropdown);
                                            }
                                        }}
                                        aria-disabled={sprintsLoading || availableSprints.length === 0}
                                    >
                                        <span>{sprintName || 'Sprint'}</span>
                                        <svg viewBox="0 0 12 12" fill="currentColor" aria-hidden="true">
                                            <path d="M6 9L1 4h10z"/>
                                        </svg>
                                    </div>
                                    {showSprintDropdown && (
                                        <div className="sprint-dropdown-panel">
                                            <input
                                                type="text"
                                                className="sprint-dropdown-search"
                                                placeholder="Filter..."
                                                value={sprintSearch}
                                                onChange={(e) => setSprintSearch(e.target.value)}
                                                aria-label="Filter sprints"
                                            />
                                            <div className="sprint-dropdown-list">
                                                {sprintsLoading ? (
                                                    <div className="sprint-dropdown-option">Loading sprints...</div>
                                                ) : filteredSprints.length === 0 ? (
                                                    <div className="sprint-dropdown-option">No sprints available</div>
                                                ) : (
                                                    filteredSprints.map(sprint => {
                                                        const state = (sprint.state || '').toLowerCase();
                                                        const marker = state === 'closed' ? '[C]' : state === 'active' ? '[A]' : '[F]';
                                                        return (
                                                            <div
                                                                key={sprint.id}
                                                                className="sprint-dropdown-option"
                                                                data-sprint-id={sprint.id}
                                                                onClick={() => {
                                                                    setSelectedSprint(sprint.id);
                                                                    setSprintName(sprint.name);
                                                                    setShowSprintDropdown(false);
                                                                }}
                                                            >
                                                                {marker} {sprint.name}
                                                            </div>
                                                        );
                                                    })
                                                )}
                                            </div>
                                        </div>
                                    )}
                                </div>
                                <label>Team:</label>
                                <div className="team-dropdown" ref={teamDropdownRef}>
                                    <div
                                        className={`team-dropdown-toggle ${showTeamDropdown ? 'open' : ''}`}
                                        role="button"
                                        tabIndex={tasks.length === 0 && loading ? -1 : 0}
                                        onClick={() => {
                                            if (tasks.length === 0 && loading) return;
                                            setShowTeamDropdown(!showTeamDropdown);
                                        }}
                                        onKeyDown={(event) => {
                                            if (tasks.length === 0 && loading) return;
                                            if (event.key === 'Enter' || event.key === ' ') {
                                                event.preventDefault();
                                                setShowTeamDropdown(!showTeamDropdown);
                                            }
                                        }}
                                        aria-disabled={tasks.length === 0 && loading}
                                    >
                                        <span>{selectedTeamsLabel}</span>
                                        <svg viewBox="0 0 12 12" fill="currentColor" aria-hidden="true">
                                            <path d="M6 9L1 4h10z"/>
                                        </svg>
                                    </div>
                                    {showTeamDropdown && (
                                        <div className="team-dropdown-panel">
                                            {teamOptions.map(team => (
                                                <label key={team.id} className="team-dropdown-option">
                                                    <input
                                                        type="checkbox"
                                                        checked={team.id === 'all' ? isAllTeamsSelected : selectedTeamSet.has(team.id)}
                                                        onChange={() => toggleTeamSelection(team.id)}
                                                    />
                                                    <span>{team.name}</span>
                                                </label>
                                            ))}
                                        </div>
                                    )}
                                </div>
                                <div className="view-actions">
                                    <button
                                        className={`planning-button ${showPlanning ? 'active' : ''}`}
                                        onClick={() => setShowPlanning(!showPlanning)}
                                        disabled={isCompletedSprintSelected}
                                        title="Toggle sprint planning panel"
                                    >
                                        Planning
                                        <svg viewBox="0 0 12 12" fill="currentColor">
                                            <path d="M6 9L1 4h10z"/>
                                        </svg>
                                    </button>
                                    <button
                                        className={`planning-button ${showStats ? 'active' : ''}`}
                                        onClick={() => setShowStats(!showStats)}
                                        title="Toggle sprint statistics"
                                        disabled={isFutureSprintSelected}
                                    >
                                        Statistics
                                        <svg viewBox="0 0 12 12" fill="currentColor">
                                            <path d="M6 9L1 4h10z"/>
                                        </svg>
                                    </button>
                                    <button
                                        className={`planning-button ${showScenario ? 'active' : ''}`}
                                        onClick={() => setShowScenario(!showScenario)}
                                        title="Toggle scenario planner"
                                        disabled={!selectedSprint}
                                    >
                                        Scenario
                                        <svg viewBox="0 0 12 12" fill="currentColor">
                                            <path d="M6 9L1 4h10z"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </header>

                    {!isCompletedSprintSelected && (
                        <div className={`capacity-panel ${showPlanning ? 'open' : ''}`}>
                            <div className="capacity-header">
                                <div className="capacity-title">Planned Teams Effort (Story Points)</div>
                                <div className="capacity-subtitle">1 SP  2 days of work</div>
                            </div>
                            <div className="capacity-grid-wrapper">
                                <div className="capacity-grid">
                                    <div className="capacity-row capacity-group-row">
                                        <div className="capacity-cell"></div>
                                        <div className="capacity-group-cell product">Product</div>
                                        <div className="capacity-group-cell tech">Tech</div>
                                        <div className="capacity-group-cell total">Total</div>
                                    </div>
                                    <div className="capacity-row capacity-header-row">
                                        <div className="capacity-cell">Team</div>
                                        <div className="capacity-cell metric product-col">To Do / Pending</div>
                                        <div className="capacity-cell metric product-col">Postponed</div>
                                        <div className="capacity-cell metric product-col divider-right">Accepted</div>
                                        <div className="capacity-cell metric tech-col">To Do / Pending</div>
                                        <div className="capacity-cell metric tech-col">Postponed</div>
                                        <div className="capacity-cell metric tech-col divider-right">Accepted</div>
                                        <div className="capacity-cell metric total-col">To Do / Pending</div>
                                        <div className="capacity-cell metric total-col">Postponed</div>
                                        <div className="capacity-cell metric total-col divider-right">Accepted</div>
                                    </div>
                                    {displayedTeamCapacityEntries.map((info) => (
                                        <div key={info.id} className="capacity-row capacity-divider">
                                            <div className="capacity-cell capacity-team">{info.name}</div>
                                            <div className="capacity-cell metric product-col">
                                                <div className="postponed-cell">
                                                    <span className={getMetricClass(info.product.todoPending, 'todo', info.product.accepted)}>
                                                        {formatCapacityValue(info.product.todoPending)}
                                                    </span>
                                                    {buildTodoPendingLink({ teamId: info.id, projectName: 'PRODUCT ROADMAPS' }) && (
                                                        <a
                                                            className="todo-link"
                                                            href={buildTodoPendingLink({ teamId: info.id, projectName: 'PRODUCT ROADMAPS' })}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            title="View To Do / Pending tasks for this team in Jira"
                                                            aria-label="Open To Do / Pending tasks in Jira"
                                                        >
                                                            
                                                        </a>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="capacity-cell metric product-col">
                                                <div className="postponed-cell">
                                                    <span className="metric-value">
                                                        {formatCapacityValue(info.product.postponed)}
                                                    </span>
                                                    {buildPostponedLink({ teamId: info.id, projectName: 'PRODUCT ROADMAPS' }) && (
                                                        <a
                                                            className="postponed-link"
                                                            href={buildPostponedLink({ teamId: info.id, projectName: 'PRODUCT ROADMAPS' })}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            title="View postponed tasks for this team in Jira"
                                                            aria-label="Open postponed tasks in Jira"
                                                        >
                                                            
                                                        </a>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="capacity-cell metric product-col divider-right">
                                                <div className="postponed-cell">
                                                    <span className={getMetricClass(info.product.accepted, 'accepted')}>
                                                        {formatCapacityValue(info.product.accepted)}
                                                    </span>
                                                    {buildAcceptedLink({ teamId: info.id, projectName: 'PRODUCT ROADMAPS' }) && (
                                                        <a
                                                            className="accepted-link"
                                                            href={buildAcceptedLink({ teamId: info.id, projectName: 'PRODUCT ROADMAPS' })}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            title="View accepted tasks for this team in Jira"
                                                            aria-label="Open accepted tasks in Jira"
                                                        >
                                                            
                                                        </a>
                                                    )}
                                                </div>
                                            </div>

                                            <div className="capacity-cell metric tech-col">
                                                <div className="postponed-cell">
                                                    <span className={getMetricClass(info.tech.todoPending, 'todo', info.tech.accepted)}>
                                                        {formatCapacityValue(info.tech.todoPending)}
                                                    </span>
                                                    {buildTodoPendingLink({ teamId: info.id, projectName: 'TECHNICAL ROADMAP' }) && (
                                                        <a
                                                            className="todo-link"
                                                            href={buildTodoPendingLink({ teamId: info.id, projectName: 'TECHNICAL ROADMAP' })}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            title="View To Do / Pending tasks for this team in Jira"
                                                            aria-label="Open To Do / Pending tasks in Jira"
                                                        >
                                                            
                                                        </a>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="capacity-cell metric tech-col">
                                                <div className="postponed-cell">
                                                    <span className="metric-value">
                                                        {formatCapacityValue(info.tech.postponed)}
                                                    </span>
                                                    {buildPostponedLink({ teamId: info.id, projectName: 'TECHNICAL ROADMAP' }) && (
                                                        <a
                                                            className="postponed-link"
                                                            href={buildPostponedLink({ teamId: info.id, projectName: 'TECHNICAL ROADMAP' })}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            title="View postponed tasks for this team in Jira"
                                                            aria-label="Open postponed tasks in Jira"
                                                        >
                                                            
                                                        </a>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="capacity-cell metric tech-col divider-right">
                                                <div className="postponed-cell">
                                                    <span className={getMetricClass(info.tech.accepted, 'accepted')}>
                                                        {formatCapacityValue(info.tech.accepted)}
                                                    </span>
                                                    {buildAcceptedLink({ teamId: info.id, projectName: 'TECHNICAL ROADMAP' }) && (
                                                        <a
                                                            className="accepted-link"
                                                            href={buildAcceptedLink({ teamId: info.id, projectName: 'TECHNICAL ROADMAP' })}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            title="View accepted tasks for this team in Jira"
                                                            aria-label="Open accepted tasks in Jira"
                                                        >
                                                            
                                                        </a>
                                                    )}
                                                </div>
                                            </div>

                                            <div className="capacity-cell metric total-col">
                                                <div className="postponed-cell">
                                                    <span className={getMetricClass(info.total.todoPending, 'todo', info.total.accepted)}>
                                                        {formatCapacityValue(info.total.todoPending)}
                                                    </span>
                                                    {buildTodoPendingLink({ teamId: info.id, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] }) && (
                                                        <a
                                                            className="todo-link"
                                                            href={buildTodoPendingLink({ teamId: info.id, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] })}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            title="View To Do / Pending tasks for this team in Jira"
                                                            aria-label="Open To Do / Pending tasks in Jira"
                                                        >
                                                            
                                                        </a>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="capacity-cell metric total-col">
                                                <div className="postponed-cell">
                                                    <span className="metric-value">
                                                        {formatCapacityValue(info.total.postponed)}
                                                    </span>
                                                    {buildPostponedLink({ teamId: info.id, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] }) && (
                                                        <a
                                                            className="postponed-link"
                                                            href={buildPostponedLink({ teamId: info.id, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] })}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            title="View postponed tasks for this team in Jira"
                                                            aria-label="Open postponed tasks in Jira"
                                                        >
                                                            
                                                        </a>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="capacity-cell metric total-col divider-right">
                                                <div className="postponed-cell">
                                                    <span className={getMetricClass(info.total.accepted, 'accepted')}>
                                                        {formatCapacityValue(info.total.accepted)}
                                                    </span>
                                                    {buildAcceptedLink({ teamId: info.id, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] }) && (
                                                        <a
                                                            className="accepted-link"
                                                            href={buildAcceptedLink({ teamId: info.id, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] })}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            title="View accepted tasks for this team in Jira"
                                                            aria-label="Open accepted tasks in Jira"
                                                        >
                                                            
                                                        </a>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                    {showTotalsRow && displayedTeamCapacityEntries.length > 0 && (
                                        <div className="capacity-row capacity-divider">
                                            <div className="capacity-cell capacity-team capacity-total">Total</div>
                                        <div className="capacity-cell metric product-col capacity-total">
                                            <div className="postponed-cell">
                                                <span className={getMetricClass(capacityTotals.product.todoPending, 'todo', capacityTotals.product.accepted)}>
                                                    {formatCapacityValue(capacityTotals.product.todoPending)}
                                                </span>
                                                {buildTodoPendingLink({ teamIds: capacityTeamIds, projectName: 'PRODUCT ROADMAPS' }) && (
                                                    <a
                                                        className="todo-link"
                                                        href={buildTodoPendingLink({ teamIds: capacityTeamIds, projectName: 'PRODUCT ROADMAPS' })}
                                                        target="_blank"
                                                        rel="noopener noreferrer"
                                                        title="View To Do / Pending tasks for selected teams in Jira"
                                                        aria-label="Open To Do / Pending tasks in Jira"
                                                    >
                                                        
                                                    </a>
                                                )}
                                            </div>
                                        </div>
                                        <div className="capacity-cell metric product-col capacity-total">
                                            <div className="postponed-cell">
                                                <span className="metric-value">
                                                    {formatCapacityValue(capacityTotals.product.postponed)}
                                                </span>
                                                {buildPostponedLink({ teamIds: capacityTeamIds, projectName: 'PRODUCT ROADMAPS' }) && (
                                                    <a
                                                        className="postponed-link"
                                                        href={buildPostponedLink({ teamIds: capacityTeamIds, projectName: 'PRODUCT ROADMAPS' })}
                                                        target="_blank"
                                                        rel="noopener noreferrer"
                                                        title="View postponed tasks for selected teams in Jira"
                                                        aria-label="Open postponed tasks in Jira"
                                                    >
                                                        
                                                    </a>
                                                )}
                                            </div>
                                        </div>
                                        <div className="capacity-cell metric product-col divider-right capacity-total">
                                            <div className="postponed-cell">
                                                <span className={getMetricClass(capacityTotals.product.accepted, 'accepted')}>
                                                    {formatCapacityValue(capacityTotals.product.accepted)}
                                                </span>
                                                {buildAcceptedLink({ teamIds: capacityTeamIds, projectName: 'PRODUCT ROADMAPS' }) && (
                                                    <a
                                                        className="accepted-link"
                                                        href={buildAcceptedLink({ teamIds: capacityTeamIds, projectName: 'PRODUCT ROADMAPS' })}
                                                        target="_blank"
                                                        rel="noopener noreferrer"
                                                        title="View accepted tasks for selected teams in Jira"
                                                        aria-label="Open accepted tasks in Jira"
                                                    >
                                                        
                                                    </a>
                                                )}
                                            </div>
                                            </div>

                                        <div className="capacity-cell metric tech-col capacity-total">
                                            <div className="postponed-cell">
                                                <span className={getMetricClass(capacityTotals.tech.todoPending, 'todo', capacityTotals.tech.accepted)}>
                                                    {formatCapacityValue(capacityTotals.tech.todoPending)}
                                                </span>
                                                {buildTodoPendingLink({ teamIds: capacityTeamIds, projectName: 'TECHNICAL ROADMAP' }) && (
                                                    <a
                                                        className="todo-link"
                                                        href={buildTodoPendingLink({ teamIds: capacityTeamIds, projectName: 'TECHNICAL ROADMAP' })}
                                                        target="_blank"
                                                        rel="noopener noreferrer"
                                                        title="View To Do / Pending tasks for selected teams in Jira"
                                                        aria-label="Open To Do / Pending tasks in Jira"
                                                    >
                                                        
                                                    </a>
                                                )}
                                            </div>
                                        </div>
                                        <div className="capacity-cell metric tech-col capacity-total">
                                            <div className="postponed-cell">
                                                <span className="metric-value">
                                                    {formatCapacityValue(capacityTotals.tech.postponed)}
                                                </span>
                                                {buildPostponedLink({ teamIds: capacityTeamIds, projectName: 'TECHNICAL ROADMAP' }) && (
                                                    <a
                                                        className="postponed-link"
                                                        href={buildPostponedLink({ teamIds: capacityTeamIds, projectName: 'TECHNICAL ROADMAP' })}
                                                        target="_blank"
                                                        rel="noopener noreferrer"
                                                        title="View postponed tasks for selected teams in Jira"
                                                        aria-label="Open postponed tasks in Jira"
                                                    >
                                                        
                                                    </a>
                                                )}
                                            </div>
                                        </div>
                                        <div className="capacity-cell metric tech-col divider-right capacity-total">
                                            <div className="postponed-cell">
                                                <span className={getMetricClass(capacityTotals.tech.accepted, 'accepted')}>
                                                    {formatCapacityValue(capacityTotals.tech.accepted)}
                                                </span>
                                                {buildAcceptedLink({ teamIds: capacityTeamIds, projectName: 'TECHNICAL ROADMAP' }) && (
                                                    <a
                                                        className="accepted-link"
                                                        href={buildAcceptedLink({ teamIds: capacityTeamIds, projectName: 'TECHNICAL ROADMAP' })}
                                                        target="_blank"
                                                        rel="noopener noreferrer"
                                                        title="View accepted tasks for selected teams in Jira"
                                                        aria-label="Open accepted tasks in Jira"
                                                    >
                                                        
                                                    </a>
                                                )}
                                            </div>
                                            </div>

                                        <div className="capacity-cell metric total-col capacity-total">
                                            <div className="postponed-cell">
                                                <span className={getMetricClass(capacityTotals.total.todoPending, 'todo', capacityTotals.total.accepted)}>
                                                    {formatCapacityValue(capacityTotals.total.todoPending)}
                                                </span>
                                                {buildTodoPendingLink({ teamIds: capacityTeamIds, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] }) && (
                                                    <a
                                                        className="todo-link"
                                                        href={buildTodoPendingLink({ teamIds: capacityTeamIds, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] })}
                                                        target="_blank"
                                                        rel="noopener noreferrer"
                                                        title="View To Do / Pending tasks for selected teams in Jira"
                                                        aria-label="Open To Do / Pending tasks in Jira"
                                                    >
                                                        
                                                    </a>
                                                )}
                                            </div>
                                        </div>
                                        <div className="capacity-cell metric total-col capacity-total">
                                            <div className="postponed-cell">
                                                <span className="metric-value">
                                                    {formatCapacityValue(capacityTotals.total.postponed)}
                                                </span>
                                                {buildPostponedLink({ teamIds: capacityTeamIds, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] }) && (
                                                    <a
                                                        className="postponed-link"
                                                        href={buildPostponedLink({ teamIds: capacityTeamIds, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] })}
                                                        target="_blank"
                                                        rel="noopener noreferrer"
                                                        title="View postponed tasks for selected teams in Jira"
                                                        aria-label="Open postponed tasks in Jira"
                                                    >
                                                        
                                                    </a>
                                                )}
                                            </div>
                                        </div>
                                            <div className="capacity-cell metric total-col divider-right capacity-total">
                                                <div className="postponed-cell">
                                                    <span className={getMetricClass(capacityTotals.total.accepted, 'accepted')}>
                                                        {formatCapacityValue(capacityTotals.total.accepted)}
                                                    </span>
                                                    {buildAcceptedLink({ teamIds: capacityTeamIds, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] }) && (
                                                        <a
                                                            className="accepted-link"
                                                            href={buildAcceptedLink({ teamIds: capacityTeamIds, projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'] })}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            title="View accepted tasks for selected teams in Jira"
                                                            aria-label="Open accepted tasks in Jira"
                                                        >
                                                            
                                                        </a>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    {displayedTeamCapacityEntries.length === 0 && (
                                        <div className="capacity-empty">No capacity data for current filters.</div>
                                    )}
                                </div>
                                {displayedTeamCapacityEntries.length > 5 && (
                                    <div className="capacity-scroll-hint">Scroll for more teams</div>
                                )}
                            </div>
                        </div>
                    )}

                    <div className={`stats-panel ${showStats ? 'open' : ''}`}>
                        <div className="stats-controls">
                            <div className="stats-control-group">
                                <label>Selected Sprint</label>
                                <div className="stats-note">
                                    {selectedSprintInfo?.name || 'Sprint'}
                                </div>
                            </div>
                            <div className="stats-control-group">
                                <label>Excluded Epics</label>
                                <button
                                    className={`stats-toggle ${hideExcludedStats ? 'active' : ''}`}
                                    onClick={() => setHideExcludedStats(prev => !prev)}
                                >
                                    {hideExcludedStats ? 'Hide excluded' : 'Show excluded'}
                                </button>
                            </div>
                        </div>

                        {showStats && !effectiveStatsData && (
                            <div className="stats-note">Load stats for the selected sprint.</div>
                        )}

                        {effectiveStatsData && (
                            <>
                                <div className="stats-summary">
                                    <div
                                        className={`stats-card selectable ${statsGraphMode === 'absolute' ? 'active' : ''}`}
                                        role="button"
                                        tabIndex={0}
                                        onClick={() => setStatsGraphMode('absolute')}
                                        onKeyDown={(event) => {
                                            if (event.key === 'Enter' || event.key === ' ') {
                                                event.preventDefault();
                                                setStatsGraphMode('absolute');
                                            }
                                        }}
                                        aria-pressed={statsGraphMode === 'absolute'}
                                    >
                                        <h4>Delivery Rate</h4>
                                        <div className="stat-value">
                                            {formatPercent(computeRate(statsTotals.straight))}
                                        </div>
                                        <div className="stats-note">Absolute rate</div>
                                    </div>
                                    <div
                                        className={`stats-card selectable ${statsGraphMode === 'weighted' ? 'active' : ''}`}
                                        role="button"
                                        tabIndex={0}
                                        onClick={() => setStatsGraphMode('weighted')}
                                        onKeyDown={(event) => {
                                            if (event.key === 'Enter' || event.key === ' ') {
                                                event.preventDefault();
                                                setStatsGraphMode('weighted');
                                            }
                                        }}
                                        aria-pressed={statsGraphMode === 'weighted'}
                                    >
                                        <h4>Weighted Rate</h4>
                                        <div className="stat-value">
                                            {formatPercent(computeRate(statsTotals.weighted))}
                                        </div>
                                        <div className="stats-note">Priority-weighted</div>
                                    </div>
                                    <div className="stats-card">
                                        <h4>Totals</h4>
                                        <div className="stat-value">{statsTotals.straight.done + statsTotals.straight.incomplete + statsTotals.straight.killed}</div>
                                        <div className="stats-note">
                                            {statsTotals.straight.done} done  {statsTotals.straight.incomplete} incomplete  {statsTotals.straight.killed} killed
                                        </div>
                                    </div>
                                    <div className="stats-card">
                                        <h4>Source</h4>
                                        <div className="stat-value">Sprint tasks</div>
                                        <div className="stats-note">Derived from the loaded sprint list</div>
                                    </div>
                                </div>

                                <div className="stats-view-toggle">
                                    <button
                                        className={`stats-toggle ${statsView === 'teams' ? 'active' : ''}`}
                                        onClick={() => setStatsView('teams')}
                                    >
                                        Teams
                                    </button>
                                    <button
                                        className={`stats-toggle ${statsView === 'priority' ? 'active' : ''}`}
                                        onClick={() => setStatsView('priority')}
                                    >
                                        Priority
                                    </button>
                                </div>

                                <div className={`stats-view ${statsView === 'teams' ? 'open' : ''}`}>
                                    <div className="stats-bars">
                                        {statsTeamRows.map(team => {
                                            const graphRate = statsGraphMode === 'weighted' ? team.weightedRate : team.straightRate;
                                            return (
                                                <div key={team.id} className="stats-bar">
                                                    <div className="stats-bar-value">{formatPercent(graphRate)}</div>
                                                    <div className="stats-bar-track">
                                                        <div
                                                            className={`stats-bar-fill ${getRateClass(graphRate)}`}
                                                            style={{ height: `${Math.min(100, graphRate * 100)}%` }}
                                                        />
                                                    </div>
                                                    <div className="stats-bar-label">{team.name}</div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                    <table className="stats-table">
                                        <thead>
                                            <tr className="stats-group-row">
                                                <th className="dimension"></th>
                                                <th className="stats-col total" colSpan="4">Total</th>
                                                <th className="stats-col product" colSpan="4">Product</th>
                                                <th className="stats-col tech" colSpan="4">Tech</th>
                                            </tr>
                                            <tr>
                                                <th className="dimension">Team</th>
                                                <th className="metric stats-col total">Done</th>
                                                <th className="metric stats-col total">Incomplete</th>
                                                <th className="metric stats-col total">Absolute</th>
                                                <th className="metric stats-col total">Weighted</th>
                                                <th className="metric stats-col product">Done</th>
                                                <th className="metric stats-col product">Incomplete</th>
                                                <th className="metric stats-col product">Absolute</th>
                                                <th className="metric stats-col product">Weighted</th>
                                                <th className="metric stats-col tech">Done</th>
                                                <th className="metric stats-col tech">Incomplete</th>
                                                <th className="metric stats-col tech">Absolute</th>
                                                <th className="metric stats-col tech">Weighted</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {statsTeamRows.map(team => {
                                                const totalDoneLink = buildStatLink(team.straight.done, {
                                                    teamId: team.id,
                                                    projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'],
                                                    statuses: ['Done'],
                                                    issueType: 'Story'
                                                });
                                                const totalIncompleteLink = buildStatLink(team.straight.incomplete, {
                                                    teamId: team.id,
                                                    projectNames: ['PRODUCT ROADMAPS', 'TECHNICAL ROADMAP'],
                                                    excludeStatuses: ['Done', 'Killed'],
                                                    issueType: 'Story'
                                                });
                                                const productDoneLink = buildStatLink(team.product.done, {
                                                    teamId: team.id,
                                                    projectName: 'PRODUCT ROADMAPS',
                                                    statuses: ['Done'],
                                                    issueType: 'Story'
                                                });
                                                const productIncompleteLink = buildStatLink(team.product.incomplete, {
                                                    teamId: team.id,
                                                    projectName: 'PRODUCT ROADMAPS',
                                                    excludeStatuses: ['Done', 'Killed'],
                                                    issueType: 'Story'
                                                });
                                                const techDoneLink = buildStatLink(team.tech.done, {
                                                    teamId: team.id,
                                                    projectName: 'TECHNICAL ROADMAP',
                                                    statuses: ['Done'],
                                                    issueType: 'Story'
                                                });
                                                const techIncompleteLink = buildStatLink(team.tech.incomplete, {
                                                    teamId: team.id,
                                                    projectName: 'TECHNICAL ROADMAP',
                                                    excludeStatuses: ['Done', 'Killed'],
                                                    issueType: 'Story'
                                                });

                                                return (
                                                <tr key={team.id}>
                                                    <td className="dimension">{team.name}</td>
                                                    <td className="metric stats-col total">
                                                        <div className="postponed-cell">
                                                            <span>{team.straight.done}</span>
                                                            {totalDoneLink && (
                                                                <a
                                                                    className="stats-link"
                                                                    href={totalDoneLink}
                                                                    target="_blank"
                                                                    rel="noopener noreferrer"
                                                                    title="View done stories for this team in Jira"
                                                                    aria-label="Open done stories in Jira"
                                                                >
                                                                    
                                                                </a>
                                                            )}
                                                        </div>
                                                    </td>
                                                    <td className="metric stats-col total">
                                                        <div className="postponed-cell">
                                                            <span>{team.straight.incomplete}</span>
                                                            {totalIncompleteLink && (
                                                                <a
                                                                    className="stats-link"
                                                                    href={totalIncompleteLink}
                                                                    target="_blank"
                                                                    rel="noopener noreferrer"
                                                                    title="View incomplete stories for this team in Jira"
                                                                    aria-label="Open incomplete stories in Jira"
                                                                >
                                                                    
                                                                </a>
                                                            )}
                                                        </div>
                                                    </td>
                                                    <td className="metric stats-col total">{formatPercent(team.straightRate)}</td>
                                                    <td className="metric stats-col total">{formatPercent(team.weightedRate)}</td>
                                                    <td className="metric stats-col product">
                                                        <div className="postponed-cell">
                                                            <span>{team.product.done}</span>
                                                            {productDoneLink && (
                                                                <a
                                                                    className="stats-link"
                                                                    href={productDoneLink}
                                                                    target="_blank"
                                                                    rel="noopener noreferrer"
                                                                    title="View done product stories for this team in Jira"
                                                                    aria-label="Open done product stories in Jira"
                                                                >
                                                                    
                                                                </a>
                                                            )}
                                                        </div>
                                                    </td>
                                                    <td className="metric stats-col product">
                                                        <div className="postponed-cell">
                                                            <span>{team.product.incomplete}</span>
                                                            {productIncompleteLink && (
                                                                <a
                                                                    className="stats-link"
                                                                    href={productIncompleteLink}
                                                                    target="_blank"
                                                                    rel="noopener noreferrer"
                                                                    title="View incomplete product stories for this team in Jira"
                                                                    aria-label="Open incomplete product stories in Jira"
                                                                >
                                                                    
                                                                </a>
                                                            )}
                                                        </div>
                                                    </td>
                                                    <td className="metric stats-col product">{formatPercent(computeRate(team.product))}</td>
                                                    <td className="metric stats-col product">{formatPercent(computeRate(team.weightedProduct))}</td>
                                                    <td className="metric stats-col tech">
                                                        <div className="postponed-cell">
                                                            <span>{team.tech.done}</span>
                                                            {techDoneLink && (
                                                                <a
                                                                    className="stats-link"
                                                                    href={techDoneLink}
                                                                    target="_blank"
                                                                    rel="noopener noreferrer"
                                                                    title="View done tech stories for this team in Jira"
                                                                    aria-label="Open done tech stories in Jira"
                                                                >
                                                                    
                                                                </a>
                                                            )}
                                                        </div>
                                                    </td>
                                                    <td className="metric stats-col tech">
                                                        <div className="postponed-cell">
                                                            <span>{team.tech.incomplete}</span>
                                                            {techIncompleteLink && (
                                                                <a
                                                                    className="stats-link"
                                                                    href={techIncompleteLink}
                                                                    target="_blank"
                                                                    rel="noopener noreferrer"
                                                                    title="View incomplete tech stories for this team in Jira"
                                                                    aria-label="Open incomplete tech stories in Jira"
                                                                >
                                                                    
                                                                </a>
                                                            )}
                                                        </div>
                                                    </td>
                                                    <td className="metric stats-col tech">{formatPercent(computeRate(team.tech))}</td>
                                                    <td className="metric stats-col tech">{formatPercent(computeRate(team.weightedTech))}</td>
                                                </tr>
                                                );
                                            })}
                                        </tbody>
                                    </table>
                                </div>

                                <div className={`stats-view ${statsView === 'priority' ? 'open' : ''}`}>
                                    {priorityRadar.series.length > 0 && (
                                        <>
                                            <svg className="priority-radar" viewBox="0 0 360 360" role="img" aria-label="Priority distribution radar chart">
                                                <g transform="translate(180 180)">
                                                    {[0.25, 0.5, 0.75, 1].map((ratio, index) => (
                                                        <polygon
                                                            key={`grid-${index}`}
                                                            points={buildRadarPoints({
                                                                values: Object.fromEntries(priorityAxis.map(axis => [axis, ratio * priorityRadar.maxValue])),
                                                                radius: 120,
                                                                center: 0,
                                                                maxValue: priorityRadar.maxValue,
                                                                axes: priorityAxis
                                                            })}
                                                            fill="none"
                                                            stroke="#d9d9d9"
                                                            strokeWidth="1"
                                                        />
                                                    ))}
                                                    {priorityAxis.map((axis, index) => {
                                                        const angle = (Math.PI * 2 * index) / priorityAxis.length - Math.PI / 2;
                                                        const x = Math.cos(angle) * 120;
                                                        const y = Math.sin(angle) * 120;
                                                        return (
                                                            <line
                                                                key={`axis-${axis}`}
                                                                x1="0"
                                                                y1="0"
                                                                x2={x}
                                                                y2={y}
                                                                stroke="#d9d9d9"
                                                                strokeWidth="1"
                                                            />
                                                        );
                                                    })}
                                                    {priorityRadar.series.map((series, idx) => {
                                                        const color = resolveTeamColor(series.id);
                                                        const isActive = priorityHoverIndex === null || priorityHoverIndex === idx;
                                                        return (
                                                            <polygon
                                                                key={series.id}
                                                                points={buildRadarPoints({
                                                                    values: series.pointsByPriority,
                                                                    radius: 120,
                                                                    center: 0,
                                                                    maxValue: priorityRadar.maxValue,
                                                                    axes: priorityAxis
                                                                })}
                                                                fill={color}
                                                                fillOpacity={isActive ? '0.18' : '0.04'}
                                                                stroke={color}
                                                                strokeWidth={isActive ? '2.5' : '1.2'}
                                                                style={{ transition: 'all 0.2s ease', cursor: 'pointer' }}
                                                                onMouseEnter={() => setPriorityHoverIndex(idx)}
                                                                onMouseLeave={() => setPriorityHoverIndex(null)}
                                                            />
                                                        );
                                                    })}
                                                    {[0.25, 0.5, 0.75, 1].map((ratio, index) => (
                                                        <text
                                                            key={`value-${index}`}
                                                            x="0"
                                                            y={-(120 * ratio) - 6}
                                                            textAnchor="middle"
                                                            dominantBaseline="middle"
                                                            fontSize="8"
                                                            fill="#8c8c8c"
                                                            fontFamily="IBM Plex Mono, monospace"
                                                        >
                                                            {(priorityRadar.maxValue * ratio).toFixed(1)}
                                                        </text>
                                                    ))}
                                                    {priorityAxis.map((axis, index) => {
                                                        const angle = (Math.PI * 2 * index) / priorityAxis.length - Math.PI / 2;
                                                        const x = Math.cos(angle) * 150;
                                                        const y = Math.sin(angle) * 150;
                                                        return (
                                                            <text
                                                                key={`label-${axis}`}
                                                                x={x}
                                                                y={y}
                                                                textAnchor="middle"
                                                                dominantBaseline="middle"
                                                                fontSize="8"
                                                                fill="#555"
                                                                fontFamily="IBM Plex Mono, monospace"
                                                            >
                                                                {axis}
                                                            </text>
                                                        );
                                                    })}
                                                </g>
                                            </svg>
                                            <div className="priority-legend">
                                                {priorityRadar.series.map((series, idx) => {
                                                    const color = resolveTeamColor(series.id);
                                                    const isActive = priorityHoverIndex === null || priorityHoverIndex === idx;
                                                    return (
                                                        <span
                                                            key={series.id}
                                                            style={{ color: isActive ? 'var(--text-primary)' : 'var(--text-secondary)' }}
                                                            onMouseEnter={() => setPriorityHoverIndex(idx)}
                                                            onMouseLeave={() => setPriorityHoverIndex(null)}
                                                        >
                                                            <i style={{ background: color, opacity: isActive ? 0.95 : 0.45 }} />
                                                            {series.name}
                                                        </span>
                                                    );
                                                })}
                                            </div>
                                            <div className="priority-axis-note">Axis values show story points.</div>
                                        </>
                                    )}
                                    <table className="stats-table">
                                        <thead>
                                            <tr>
                                                <th className="dimension">Priority</th>
                                                <th className="metric">Story Points</th>
                                                <th className="metric">Done</th>
                                                <th className="metric">Incomplete</th>
                                                <th className="metric">Rate</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {priorityRows.map(row => {
                                                const pointsLink = buildPriorityStatLink(row.points, {
                                                    priorityName: row.name
                                                });
                                                const doneLink = buildPriorityStatLink(row.done, {
                                                    priorityName: row.name,
                                                    statuses: ['Done']
                                                });
                                                const incompleteLink = buildPriorityStatLink(row.incomplete, {
                                                    priorityName: row.name,
                                                    excludeStatuses: ['Done', 'Killed']
                                                });

                                                return (
                                                    <tr key={row.name}>
                                                        <td className="dimension">{row.name}</td>
                                                        <td className="metric">
                                                            <div className="postponed-cell">
                                                                <span>{row.points.toFixed(1)}</span>
                                                                {pointsLink && (
                                                                    <a
                                                                        className="stats-link"
                                                                        href={pointsLink}
                                                                        target="_blank"
                                                                        rel="noopener noreferrer"
                                                                        title="View stories for this priority in Jira"
                                                                        aria-label="Open stories in Jira"
                                                                    >
                                                                        
                                                                    </a>
                                                                )}
                                                            </div>
                                                        </td>
                                                        <td className="metric">
                                                            <div className="postponed-cell">
                                                                <span>{row.done}</span>
                                                                {doneLink && (
                                                                    <a
                                                                        className="stats-link"
                                                                        href={doneLink}
                                                                        target="_blank"
                                                                        rel="noopener noreferrer"
                                                                        title="View done stories for this priority in Jira"
                                                                        aria-label="Open done stories in Jira"
                                                                    >
                                                                        
                                                                    </a>
                                                                )}
                                                            </div>
                                                        </td>
                                                        <td className="metric">
                                                            <div className="postponed-cell">
                                                                <span>{row.incomplete}</span>
                                                                {incompleteLink && (
                                                                    <a
                                                                        className="stats-link"
                                                                        href={incompleteLink}
                                                                        target="_blank"
                                                                        rel="noopener noreferrer"
                                                                        title="View incomplete stories for this priority in Jira"
                                                                        aria-label="Open incomplete stories in Jira"
                                                                    >
                                                                        
                                                                    </a>
                                                                )}
                                                            </div>
                                                        </td>
                                                        <td className="metric">{formatPercent(row.rate)}</td>
                                                    </tr>
                                                );
                                            })}
                                        </tbody>
                                    </table>
                                </div>
                            </>
                        )}
                    </div>

                    {showScenario && (
                        <div className="scenario-fullbleed">
                            <div className="scenario-panel open">
                                <div className="scenario-inner">
                                    <div className="scenario-header">
                                        <div>
                                            <div className="scenario-title">
                                                Scenario Planner
                                                <span className="scenario-beta">Beta</span>
                                            </div>
                                            <div className="scenario-subtitle">Capacity comes from Jira capacity issues (watchers per team).</div>
                                        </div>
                                        <div className="scenario-controls">
                                            <div className="scenario-control">
                                                <label>Lane Mode</label>
                                                <div className="scenario-toggle-group">
                                                    <button
                                                        className={`scenario-toggle ${scenarioLaneMode === 'team' ? 'active' : ''}`}
                                                        onClick={() => setScenarioLaneMode('team')}
                                                        disabled={scenarioEpicFocus}
                                                    >
                                                        Team
                                                    </button>
                                                    <button
                                                        className={`scenario-toggle ${scenarioLaneMode === 'epic' ? 'active' : ''}`}
                                                        onClick={() => setScenarioLaneMode('epic')}
                                                        disabled={scenarioEpicFocus}
                                                    >
                                                        Epic
                                                    </button>
                                                    <button
                                                        className={`scenario-toggle ${scenarioLaneMode === 'assignee' ? 'active' : ''}`}
                                                        onClick={() => setScenarioLaneMode('assignee')}
                                                        disabled={!scenarioHasAssignees || scenarioEpicFocus}
                                                    >
                                                        Assignee
                                                    </button>
                                                </div>
                                            </div>
                                            <button
                                                className="secondary"
                                                onClick={runScenario}
                                                disabled={scenarioLoading || !selectedSprint}
                                            >
                                                {scenarioLoading ? 'Running...' : 'Run Scenario'}
                                            </button>
                                        </div>
                                    </div>

                                    {scenarioError && <div className="scenario-error">{scenarioError}</div>}
                                    {scenarioLoading && <div className="scenario-loading">Computing scenario timeline...</div>}

                                    {scenarioData && (
                                        <>
                                            <div className="scenario-summary">
                                                <div className="scenario-card">
                                                    <h4>Deadline</h4>
                                                    <div className="scenario-value">
                                                        {scenarioDeadlineAtRisk ? 'At risk' : 'On track'}
                                                    </div>
                                                    <div className="scenario-subtitle">
                                                        {scenarioLateItems.length} finishing after quarter end
                                                    </div>
                                                    <div className="scenario-issues-list">
                                                        {scenarioLateItems.slice(0, 4).map(key => {
                                                            const issue = scenarioIssueByKey.get(key);
                                                            return (
                                                                <button
                                                                    type="button"
                                                                    key={key}
                                                                    className="scenario-link"
                                                                    onClick={() => scrollToScenarioIssue(key)}
                                                                >
                                                                    <span>{issue?.summary || key}</span>
                                                                    <span className="scenario-link-key">{key}</span>
                                                                </button>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                                <div className="scenario-card">
                                                    <h4>Critical Path</h4>
                                                    <div className="scenario-value">
                                                        {scenarioCriticalPathItems.length} items
                                                    </div>
                                                    <div className="scenario-issues-list">
                                                        {scenarioCriticalPathItems.slice(0, 6).map(key => {
                                                            const issue = scenarioIssueByKey.get(key);
                                                            return (
                                                                <button
                                                                    type="button"
                                                                    key={key}
                                                                    className="scenario-link"
                                                                    onClick={() => scrollToScenarioIssue(key)}
                                                                >
                                                                    <span>{issue?.summary || key}</span>
                                                                    <span className="scenario-link-key">{key}</span>
                                                                </button>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                                <div className="scenario-card">
                                                    <h4>Bottlenecks</h4>
                                                    <div className="scenario-value">
                                                        {scenarioBottleneckLanes.slice(0, 2).join(', ') || 'None'}
                                                    </div>
                                                    <div className="scenario-subtitle">
                                                        {scenarioBottleneckLanes.length} lanes flagged
                                                    </div>
                                                </div>
                                                <div className="scenario-card">
                                                    <h4>Unschedulable</h4>
                                                    <div className="scenario-value">{scenarioUnschedulableItems.length}</div>
                                                    <div className="scenario-subtitle">Missing SP or dependencies</div>
                                                    <div className="scenario-issues-list">
                                                        {scenarioUnschedulableItems.slice(0, 4).map(key => {
                                                            const issue = scenarioIssueByKey.get(key);
                                                            const reason = issue?.scheduledReason;
                                                            return (
                                                                <button
                                                                    type="button"
                                                                    key={key}
                                                                    className="scenario-link"
                                                                    onClick={() => scrollToScenarioIssue(key)}
                                                                >
                                                                    <span>{issue?.summary || key}</span>
                                                                    <span className="scenario-link-key">
                                                                        {key}{reason ? `  ${reason}` : ''}
                                                                    </span>
                                                                </button>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            </div>

                                            {scenarioEpicFocus && (
                                                <div className="scenario-focus-indicator">
                                                    <button
                                                        type="button"
                                                        className="scenario-focus-exit"
                                                        onClick={clearScenarioEpicFocus}
                                                    >
                                                        <span>Focused: {scenarioEpicFocus.summary || scenarioEpicFocus.key} (click to exit)</span>
                                                    </button>
                                                </div>
                                            )}
                                            <div className="scenario-timeline" ref={scenarioTimelineRef}>
                                                <div className="scenario-axis">
                                                    {scenarioTicks.map((tick) => (
                                                        <span key={tick.label}>{tick.label}</span>
                                                    ))}
                                                </div>
                                                <div
                                                    className="scenario-lanes"
                                                    style={{ height: `${scenarioLaneMeta.totalHeight}px` }}
                                                >
                                                    {scenarioLayout.width > 0 && scenarioQuarterMarkers.map((marker, index) => {
                                                        const left = scenarioLayout.labelWidth + scenarioLayout.width * marker.ratio;
                                                        return (
                                                            <div
                                                                key={`quarter-${index}-${marker.date.toISOString()}`}
                                                                className="scenario-quarter-line"
                                                                style={{ left: `${left}px` }}
                                                            />
                                                        );
                                                    })}
                                                    {scenarioVisibleLanes.map((lane) => {
                                                        const laneMeta = scenarioLaneMeta.meta.get(lane) || { height: SCENARIO_LANE_HEIGHT };
                                                        const laneHeight = laneMeta.height;
                                                        const laneIssues = scenarioIssuesByLane.get(lane) || [];
                                                        const laneEpicBars = scenarioEpicBars.filter(bar => bar.lane === lane);
                                                        const laneInfo = scenarioLaneInfo.get(lane) || { label: lane, key: lane };
                                                        const isCollapsed = laneMeta.collapsed;
                                                        return (
                                                        <div
                                                            key={lane}
                                                            className="scenario-lane"
                                                            style={{ top: `${laneMeta.offset}px` }}
                                                        >
                                                            <button
                                                                className="scenario-lane-label"
                                                                type="button"
                                                                disabled={scenarioEpicFocus}
                                                                onClick={() => !scenarioEpicFocus && toggleScenarioLane(lane)}
                                                                aria-expanded={!isCollapsed}
                                                            >
                                                                <div className="scenario-lane-title">
                                                                    <span className="scenario-lane-title-text">
                                                                        {normalizeScenarioSummary(laneInfo.label) || laneInfo.label}
                                                                    </span>
                                                                    {scenarioLaneMode !== 'epic' && laneInfo.key && laneInfo.key !== laneInfo.label && (
                                                                        <span className="scenario-lane-key">{laneInfo.key}</span>
                                                                    )}
                                                                </div>
                                                                <div className="scenario-lane-meta">
                                                                    {Number.isFinite(laneInfo.totalSp) && laneInfo.totalSp > 0 && (
                                                                        <div className="scenario-lane-sp">Allocated: {laneInfo.totalSp.toFixed(1)} SP.</div>
                                                                    )}
                                                                    {scenarioLaneMode === 'team' && laneInfo.capacity != null && (
                                                                        <div className="scenario-lane-capacity">Team Size: {laneInfo.capacity} </div>
                                                                    )}
                                                                    {scenarioLaneMode === 'team' && (
                                                                        <div className={`scenario-lane-status ${(laneInfo.lateCount || laneInfo.unschedulableCount) ? 'risk' : 'ok'}`}>
                                                                            Status: {(laneInfo.lateCount || laneInfo.unschedulableCount) ? 'At risk' : 'OK'}
                                                                        </div>
                                                                    )}
                                                                    {laneMeta.hiddenCount > 0 && (
                                                                        <div className="scenario-lane-more">+{laneMeta.hiddenCount} more</div>
                                                                    )}
                                                                </div>
                                                            </button>
                                                            <div className="scenario-lane-track" style={{ height: `${laneHeight}px` }}>
                                                                {laneEpicBars.map(bar => {
                                                                    const left = `${(bar.xStart / scenarioLayout.width) * 100}%`;
                                                                    const width = `${Math.max(2, ((bar.xEnd - bar.xStart) / scenarioLayout.width) * 100)}%`;
                                                                    const top = `${Math.max(2, bar.y - (scenarioLaneMeta.meta.get(lane)?.offset || 0))}px`;
                                                                    const height = `${Math.max(10, bar.height)}px`;
                                                                    const epicTooltip = buildScenarioTooltipPayload(
                                                                        bar.epicSummary || bar.epicKey,
                                                                        bar.epicKey,
                                                                        bar.storyPoints,
                                                                        bar.isExcluded
                                                                    );
                                                                    return (
                                                                        <div
                                                                            key={`${bar.lane}-${bar.epicKey}`}
                                                                            className={`scenario-epic-bar ${bar.isExcluded ? 'excluded' : ''}`}
                                                                            style={{ left, width, top, height }}
                                                                            role="button"
                                                                            tabIndex={0}
                                                                            onClick={() => focusScenarioEpic(bar.epicKey, bar.epicSummary)}
                                                                            onKeyDown={(event) => {
                                                                                if (event.key === 'Enter' || event.key === ' ') {
                                                                                    event.preventDefault();
                                                                                    focusScenarioEpic(bar.epicKey, bar.epicSummary);
                                                                                }
                                                                            }}
                                                                            onMouseEnter={(event) => showScenarioTooltip(event, epicTooltip)}
                                                                            onMouseMove={moveScenarioTooltip}
                                                                            onMouseLeave={hideScenarioTooltip}
                                                                            onFocus={(event) => showScenarioTooltipFromElement(event.currentTarget, epicTooltip)}
                                                                            onBlur={hideScenarioTooltip}
                                                                        >
                                                                        </div>
                                                                    );
                                                                })}
                                                                {laneIssues.map((issue) => {
                                                                    const position = scenarioPositions[issue.key];
                                                                    if (!position || !scenarioLayout.width) return null;
                                                                    const left = `${(position.xStart / scenarioLayout.width) * 100}%`;
                                                                    const width = `${Math.max(2, ((position.xEnd - position.xStart) / scenarioLayout.width) * 100)}%`;
                                                                    const top = `${position.y - (scenarioLaneMeta.meta.get(lane)?.offset || 0)}px`;
                                                                    const issueUrl = scenarioBaseUrl ? `${scenarioBaseUrl}/browse/${issue.key}` : '';
                                                                    const issueSummary = normalizeScenarioSummary(issue.summary) || issue.key;
                                                                    const isExcluded = excludedEpicSet.has(issue.epicKey || '');
                                                                    const issueTooltip = buildScenarioTooltipPayload(issue.summary || issue.key, issue.key, issue.sp, isExcluded);
                                                                    const isFocused = scenarioHoverKey === issue.key || scenarioFlashKey === issue.key;
                                                                    const isUpstream = scenarioUpstreamSet.has(issue.key);
                                                                    const isDownstream = scenarioDownstreamSet.has(issue.key);
                                                                    const isDimmed = scenarioHoverKey && !isFocused && !isUpstream && !isDownstream;
                                                                    const isUnscheduled = !issue.start || !issue.end;
                                                                    const isFocusContext = scenarioEpicFocus && scenarioFocusContextKeys.has(issue.key) && !scenarioFocusIssueKeys.has(issue.key);
                                                                    const isSearchMatch = scenarioSearchQuery && scenarioSearchMatchSet.has(issue.key);
                                                                    return (
                                                                        <a
                                                                            key={issue.key}
                                                                            className={`scenario-bar ${issue.isCritical ? 'critical' : ''} ${issue.isLate ? 'late' : ''} ${((issue.blockedBy || []).length > 0 || scenarioBlockedSet.has(issue.key)) ? 'blocked' : ''} ${(issue.isContext || isFocusContext) ? 'context' : ''} ${isUnscheduled ? 'unscheduled' : ''} ${isFocused ? 'is-focused' : ''} ${isUpstream ? 'is-upstream' : ''} ${isDownstream ? 'is-downstream' : ''} ${isDimmed ? 'dimmed' : ''} ${scenarioFlashKey === issue.key ? 'flash' : ''} ${isExcluded ? 'excluded' : ''} ${isSearchMatch ? 'search-match' : ''}`}
                                                                            style={{ left, width, height: `${SCENARIO_BAR_HEIGHT}px`, top }}
                                                                            href={issueUrl || '#'}
                                                                            target="_blank"
                                                                            rel="noopener noreferrer"
                                                                            ref={registerScenarioIssueRef(issue.key)}
                                                                            onClick={(event) => {
                                                                                if (!issueUrl) {
                                                                                    event.preventDefault();
                                                                                }
                                                                            }}
                                                                            onMouseEnter={(event) => {
                                                                                setScenarioHoverKey(issue.key);
                                                                                showScenarioTooltip(event, issueTooltip);
                                                                            }}
                                                                            onMouseMove={moveScenarioTooltip}
                                                                            onMouseLeave={() => {
                                                                                setScenarioHoverKey(null);
                                                                                hideScenarioTooltip();
                                                                            }}
                                                                            onFocus={(event) => {
                                                                                setScenarioHoverKey(issue.key);
                                                                                showScenarioTooltipFromElement(event.currentTarget, issueTooltip);
                                                                            }}
                                                                            onBlur={() => {
                                                                                setScenarioHoverKey(null);
                                                                                hideScenarioTooltip();
                                                                            }}
                                                                        >
                                                                            <div className="scenario-bar-inner">
                                                                                <div className="scenario-bar-summary">{issueSummary}</div>
                                                                            </div>
                                                                        </a>
                                                                    );
                                                                })}
                                                            </div>
                                                        </div>
                                                    )})}
                                                </div>
                                                {scenarioEdgeRender.width > 0 && (
                                                    <svg
                                                        className="scenario-deps"
                                                        viewBox={`0 0 ${scenarioEdgeRender.width} ${scenarioEdgeRender.height}`}
                                                        preserveAspectRatio="none"
                                                        style={{ height: `${scenarioEdgeRender.height}px`, width: `${scenarioEdgeRender.width}px` }}
                                                    >
                                                        <defs>
                                                            <marker id="scenario-arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
                                                                <path d="M0,0 L6,3 L0,6 z" fill="#94a3b8" />
                                                            </marker>
                                                            <marker id="scenario-arrow-block" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
                                                                <path d="M0,0 L6,3 L0,6 z" fill="#ef4444" />
                                                            </marker>
                                                        </defs>
                                                        {scenarioLaneMode === 'epic' && scenarioEpicEdges.map((edge, index) => (
                                                            <g key={`epic-edge-${edge.fromEpic}-${edge.toEpic}-${index}`}>
                                                                <path
                                                                    className="scenario-epic-edge"
                                                                    d={`M 8 ${edge.y1} L 8 ${edge.y2}`}
                                                                />
                                                                <text className="scenario-epic-edge-label" x="12" y={(edge.y1 + edge.y2) / 2}>
                                                                    {edge.count}
                                                                </text>
                                                            </g>
                                                        ))}
                                                        {scenarioEdgeRender.paths.map((path) => {
                                                            return (
                                                                <path
                                                                    key={path.id}
                                                                    className={`scenario-edge ${path.isActive ? 'active' : ''} ${path.isFaded ? 'faded' : ''} ${path.isContextEdge ? 'context' : ''} ${path.type === 'block' ? 'block' : ''}`}
                                                                    d={path.d}
                                                                    markerEnd={path.type === 'block' ? 'url(#scenario-arrow-block)' : 'url(#scenario-arrow)'}
                                                                />
                                                            );
                                                        })}
                                                    </svg>
                                                )}
                                                {scenarioLayout.width > 0 && (
                                                    <div
                                                        className="scenario-deadline"
                                                        style={{ left: `${scenarioDeadlineLeft}px` }}
                                                    />
                                                )}
                                                <div
                                                    className={`scenario-tooltip ${scenarioTooltip.visible ? 'visible' : ''}`}
                                                    style={{ left: `${scenarioTooltip.x}px`, top: `${scenarioTooltip.y}px` }}
                                                    ref={scenarioTooltipRef}
                                                >
                                                    <div>{scenarioTooltip.summary}</div>
                                                    {scenarioTooltip.key && <div className="scenario-tooltip-key">{scenarioTooltip.key}</div>}
                                                    {Number.isFinite(scenarioTooltip.sp) && (
                                                        <div className="scenario-tooltip-key">SP: {scenarioTooltip.sp.toFixed(1)}</div>
                                                    )}
                                                    {scenarioTooltip.note && (
                                                        <div className="scenario-tooltip-note">{scenarioTooltip.note}</div>
                                                    )}
                                                </div>
                                            </div>
                                        </>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

	                    <div ref={planningPanelRef} className={`planning-panel ${showPlanning && !isCompletedSprintSelected ? 'open' : ''}`}>
	                        <div className="planning-stats">
	                            <div className="planning-stat">
	                                <span className="planning-stat-label">Selected Tasks:</span>
	                                <span className="planning-stat-value">{selectedCount}</span>
	                            </div>
	                            <div className="planning-stat">
                                    <span
                                        className="planning-stat-label"
                                        data-tooltip="Total selected story points."
                                    >
                                        Selected Effort:
                                    </span>
	                                <span className="planning-stat-value">{selectedSP.toFixed(1)}</span>
	                            </div>
                                {capacityEnabled && totalCapacityAdjusted > 0 && (
                                    <div className="planning-stat">
                                        <span
                                            className="planning-stat-label"
                                            data-tooltip="Estimated team capacity for the quarter (if one team selected, that team's capacity)."
                                        >
                                            Team Capacity:
                                        </span>
                                        <span className="planning-stat-value">
                                            {totalCapacityAdjusted.toFixed(1)} SP
                                        </span>
                                    </div>
                                )}
                                {capacityEnabled && totalCapacityAdjusted > 0 && (
                                    <div className="planning-stat">
                                        <span
                                            className="planning-stat-label"
                                            data-tooltip="Team capacity minus excluded mandatory activities (perf review, dev lead management, etc.)."
                                        >
                                            Planning Capacity:
                                        </span>
                                        <span className="planning-stat-value clickable-number" onClick={() => scrollToFirstExcludedEpic('any')}>
                                            {estimatedCapacityAdjusted.toFixed(1)} SP
                                        </span>
                                    </div>
                                )}
                                {capacityEnabled && excludedCapacityAdjusted > 0 && (
                                    <div className="planning-stat">
                                        <span className="planning-stat-label">Excluded Capacity:</span>
                                        <span className="planning-stat-value clickable-number" onClick={() => scrollToFirstExcludedEpic('any')}>
                                            {excludedCapacityAdjusted.toFixed(1)} SP
                                        </span>
                                    </div>
                                )}
                                {capacityEnabled && totalCapacityAdjusted > 0 && (
                                    <div className="planning-stat">
                                        <span
                                            className="planning-stat-label"
                                            data-tooltip="Plan variance = (selected effort / team capacity - 1). Positive means over planned."
                                        >
                                            Plan Variance:
                                        </span>
                                        <span className={`planning-stat-value ${capacitySummary.status}`}>
                                            {capacitySummary.label || '0%'}
                                        </span>
                                    </div>
                                )}
	                            <div className="planning-actions">
	                                <button
	                                    className={`planning-action-button ${isAcceptedIncluded ? 'active' : ''}`}
	                                    onClick={() => toggleIncludeByStatus(['Accepted', 'In Progress'])}
	                                    disabled={visibleTasks.length === 0}
	                                    title="Include all Accepted and In Progress stories for the current view"
	                                >
	                                    Include Accepted
	                                </button>
	                                <button
	                                    className={`planning-action-button ${isTodoIncluded ? 'active' : ''}`}
	                                    onClick={() => toggleIncludeByStatus(['To Do', 'Pending'])}
	                                    disabled={visibleTasks.length === 0}
	                                    title="Include all To Do / Pending stories for the current view"
	                                >
	                                    Include To Do
	                                </button>
	                                <button
	                                    className="uncheck-button"
	                                    onClick={clearSelectedTasks}
	                                    disabled={selectedCount === 0}
	                                    title="Clear all selected tasks"
	                                >
	                                    Uncheck Selected
	                                </button>
	                                <button
	                                    className="planning-action-button planning-icon-button"
	                                    onClick={openSelectedInJira}
	                                    disabled={selectedCount === 0 || !jiraUrl}
	                                    title="Open selected stories in Jira (tip: bulk move them to Accepted)"
	                                    aria-label="Open selected stories in Jira"
	                                >
	                                    <svg viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
	                                        <path d="M10 2h4v4h-1.5V4.56L8.53 8.53l-1.06-1.06L11.44 3.5H10V2z" />
	                                        <path d="M13 9v4a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h4v1.5H3.5v8h8V9H13z" />
	                                    </svg>
	                                </button>
	                            </div>
	                        </div>
                        {selectedTeamEntries.length > 1 && (
                            <>
                                <div className="planning-stats compact" style={{ marginTop: '0.4rem' }}>
                                    <div className="planning-stat">
                                        <span className="planning-stat-label">Selected SP by Team:</span>
                                    </div>
                                </div>
                                <div className="team-stats-grid">
                                    {selectedTeamEntries.map((info) => (
                                        <div key={info.id} className="team-stat-card team-card">
                                            <div className="team-stat-label">{info.name}</div>
                                            <div className="team-stat-line">
                                                <div className="team-stat-value">{info.storyPoints.toFixed(1)} SP</div>
                                                <div className="team-stat-meta">Selected effort</div>
                                            </div>
                                            {capacityEnabled && info.teamCapacity > 0 && (
                                                <>
                                                    {(() => {
                                                        const capacityMeta = getTeamCapacityMeta(info.storyPoints, info.teamCapacity);
                                                        return (
                                                            <div className="team-stat-line" title={capacityMeta.title}>
                                                                <div className="team-stat-value muted">{info.teamCapacity.toFixed(1)} SP</div>
                                                                <div className={`team-stat-meta ${capacityMeta.status ? `planning-stat-value ${capacityMeta.status}` : ''}`}>
                                                                    {capacityMeta.text}
                                                                </div>
                                                            </div>
                                                        );
                                                    })()}
                                                </>
                                            )}
                                        </div>
                                    ))}
                                    {selectedTeamEntries.length === 0 && (
                                        <div className="planning-stat">
                                            <span className="planning-stat-value">No tasks selected</span>
                                        </div>
                                    )}
                                </div>
                            </>
                        )}
	                        <div className="planning-stats compact" style={{ marginTop: '0.35rem' }}>
                                <div className="planning-stat">
                                    <span className="planning-stat-label">Selected SP by Project:</span>
                                </div>
                                {capacityEnabled && (
                                    <div className="planning-stat-note">
                                        Planning capacity split: 70% Product / 30% Tech (tech-heavy teams may aim for 10% / 90%). Selected effort excludes excluded epics.
                                    </div>
                                )}
	                        </div>
                        <div className="team-stats-grid">
                            {selectedProjectEntries.map((info) => (
                                <div key={info.id} className="team-stat-card project-card">
	                                            <div className="team-stat-label">{info.name}</div>
	                                            <div className="team-stat-line">
	                                                <div className="team-stat-value">
	                                                    {(() => {
	                                                        const total = selectedProjectEntries.reduce((sum, entry) => sum + entry.storyPoints, 0);
	                                                        const pct = total > 0 ? (info.storyPoints / total) * 100 : 0;
	                                                        return `${pct.toFixed(0)}%`;
	                                                    })()}
	                                                </div>
	                                            </div>
	                                            <div className="team-stat-line">
	                                                <div className="team-stat-value muted">{info.storyPoints.toFixed(1)} SP</div>
	                                                <div className="team-stat-meta">Selected effort</div>
	                                            </div>
                                                {excludedProjectStats[info.id] > 0 && (
                                                    <div className="team-stat-line">
                                                        <div
                                                            className="team-stat-value muted clickable-number"
                                                            onClick={() => scrollToFirstExcludedEpic(info.id === 'TECH' ? 'tech' : 'product')}
                                                        >
                                                            {excludedProjectStats[info.id].toFixed(1)} SP
                                                        </div>
                                                        <div className="team-stat-meta">Excluded effort</div>
                                                    </div>
                                                )}
	                                </div>
	                            ))}
                            {selectedProjectEntries.length === 0 && (
                                <div className="planning-stat">
                                    <span className="planning-stat-value">No tasks selected</span>
                                </div>
                            )}
                        </div>
                    </div>
                    {showBackToTop && (
                        <button className="back-to-top" onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}>
                            Back to top
                        </button>
                    )}

                    {loading ? (
                        <div className="loading">Loading tasks...</div>
                    ) : error ? (
                        <div className="error">
                            {error}
                            <div style={{ marginTop: '1rem' }}>
                                <button onClick={fetchTasks}>Retry</button>
                            </div>
                        </div>
                    ) : (
                        <>
                                {alertCelebrationPieces.length > 0 && (
                                    <div className="alert-celebration" aria-hidden="true">
                                        {alertCelebrationPieces.map(piece => (
                                            <span
                                                key={piece.id}
                                                className="alert-confetti"
                                                style={{
                                                    left: `${piece.left}%`,
                                                    width: `${piece.size}px`,
                                                    height: `${piece.size * 0.7}px`,
                                                    background: piece.color,
                                                    animationDelay: `${piece.delay}s`
                                                }}
                                            />
                                        ))}
                                    </div>
                                )}
		                            {alertItemCount > 0 && (
		                                <div className={`alert-panels ${(!showMissingAlert && !showBlockedAlert && !showEmptyEpicAlert && !showDoneEpicAlert) ? 'collapsed' : ''}`}>
		                                    {consolidatedMissingStories.length > 0 && (
		                                        <div className={`alert-card missing ${showMissingAlert ? '' : 'collapsed'}`}>
	                                            <div className="alert-card-header">
	                                                <button
	                                                    className="alert-toggle"
	                                                    onClick={() => setShowMissingAlert(prev => !prev)}
	                                                    title={showMissingAlert ? 'Collapse missing info panel' : 'Expand missing info panel'}
	                                                >
	                                                    <span className="alert-toggle-icon" aria-hidden="true">
	                                                        <svg className={`alert-toggle-chevron ${showMissingAlert ? '' : 'collapsed'}`} viewBox="0 0 12 12">
	                                                            <path d="M2.5 4.5l3.5 3 3.5-3" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
	                                                        </svg>
	                                                    </span>
	                                                    <span className="alert-toggle-label">
	                                                        {showMissingAlert ? 'Hide' : 'Show'}
	                                                    </span>
	                                                </button>
	                                                <div className="alert-title"> Missing Info</div>
	                                                <div className="alert-subtitle">These stories are missing planning essentialsfill the fields so they can be scheduled and estimated.</div>
		                                                <a
		                                                    className="alert-chip"
		                                                    href={buildKeyListLink(consolidatedMissingStories.map(item => item.task.key))}
		                                                    target="_blank"
		                                                    rel="noopener noreferrer"
		                                                    title="Open these stories in Jira"
		                                                >
		                                                    {consolidatedMissingStories.length} {consolidatedMissingStories.length === 1 ? 'story' : 'stories'}
		                                                </a>
		                                            </div>
                                            <div className={`alert-card-body ${showMissingAlert ? '' : 'collapsed'}`}>
                                                    {missingAlertTeams.map(group => {
                                                        const keys = group.items.map(item => item.task.key);
                                                        const teamLink = buildKeyListLink(keys);
                                                        return (
                                                            <div key={group.id} className="alert-team-group">
                                                                <div className="alert-team-header">
                                                                    {teamLink ? (
                                                                        <a
                                                                            className="alert-team-link"
                                                                            href={teamLink}
                                                                            target="_blank"
                                                                            rel="noopener noreferrer"
                                                                        >
                                                                            <span className="alert-pill team">{group.name}</span>
                                                                            <span>{group.items.length} {group.items.length === 1 ? 'story' : 'stories'}</span>
                                                                        </a>
                                                                    ) : (
                                                                        <div className="alert-team-title">
                                                                            <span className="alert-pill team">{group.name}</span>
                                                                            <span>{group.items.length} {group.items.length === 1 ? 'story' : 'stories'}</span>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                                <div className="alert-stories">
                                                                    {group.items.map(({ task, missingFields }) => (
                                                                        <div key={task.key} className="alert-story">
                                                                            <div
                                                                                className="alert-story-main"
                                                                                role="button"
                                                                                tabIndex={0}
                                                                                onClick={() => handleAlertStoryClick(task.key)}
                                                                                onKeyDown={(event) => {
                                                                                    if (event.key === 'Enter' || event.key === ' ') {
                                                                                        event.preventDefault();
                                                                                        handleAlertStoryClick(task.key);
                                                                                    }
                                                                                }}
                                                                            >
                                                                                <a
                                                                                    className="alert-story-link"
                                                                                    href={jiraUrl ? `${jiraUrl}/browse/${task.key}` : '#'}
                                                                                    target="_blank"
                                                                                    rel="noopener noreferrer"
                                                                                    onClick={(event) => {
                                                                                        event.preventDefault();
                                                                                        event.stopPropagation();
                                                                                        handleAlertStoryClick(task.key);
                                                                                    }}
                                                                                >
                                                                                    {task.key}  {task.fields.summary}
                                                                                </a>
                                                                            </div>
                                                                            <span className="alert-pill status">Missing: {missingFields.join(', ')}</span>
                                                                            <a
                                                                                className="alert-action"
                                                                                href={jiraUrl ? `${jiraUrl}/browse/${task.key}` : '#'}
                                                                                target="_blank"
                                                                                rel="noopener noreferrer"
                                                                            >
                                                                                Fix fields 
                                                                            </a>
                                                                            <button
                                                                                className="task-remove alert-remove"
                                                                                onClick={(event) => {
                                                                                    event.stopPropagation();
                                                                                    dismissAlertItem(task.key);
                                                                                }}
                                                                                title="Dismiss from alerts"
                                                                                type="button"
                                                                            >
                                                                                
                                                                            </button>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                            </div>
	                                        </div>
	                                    )}

	                                    {blockedTasks.length > 0 && (
	                                        <div className={`alert-card blocked ${showBlockedAlert ? '' : 'collapsed'}`}>
                                            <div className="alert-card-header">
                                                <button
                                                    className="alert-toggle"
                                                    onClick={() => setShowBlockedAlert(prev => !prev)}
                                                    title={showBlockedAlert ? 'Collapse blocked panel' : 'Expand blocked panel'}
                                                >
                                                    <span className="alert-toggle-icon" aria-hidden="true">
                                                        <svg className={`alert-toggle-chevron ${showBlockedAlert ? '' : 'collapsed'}`} viewBox="0 0 12 12">
                                                            <path d="M2.5 4.5l3.5 3 3.5-3" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
                                                        </svg>
                                                    </span>
                                                    <span className="alert-toggle-label">
                                                        {showBlockedAlert ? 'Hide' : 'Show'}
                                                    </span>
                                                </button>
                                                <div className="alert-title"> Blocked</div>
                                                <div className="alert-subtitle">Lets unblock these fastcall out whats stuck, whos needed, and what done looks like.</div>
	                                                <a
	                                                    className="alert-chip"
	                                                    href={buildKeyListLink(blockedTasks.map(t => t.key), { addSprint: true })}
	                                                    target="_blank"
	                                                    rel="noopener noreferrer"
	                                                    title="Open blocked stories in Jira"
	                                                >
	                                                    {blockedTasks.length} blocked
	                                                </a>
	                                            </div>
                                            <div className={`alert-card-body ${showBlockedAlert ? '' : 'collapsed'}`}>
                                                    {blockedAlertTeams.map(group => {
                                                        const keys = group.items.map(item => item.key);
                                                        const teamLink = buildKeyListLink(keys, { addSprint: true });
                                                        return (
                                                            <div key={group.id} className="alert-team-group">
                                                                <div className="alert-team-header">
                                                                    {teamLink ? (
                                                                        <a
                                                                            className="alert-team-link"
                                                                            href={teamLink}
                                                                            target="_blank"
                                                                            rel="noopener noreferrer"
                                                                        >
                                                                            <span className="alert-pill team">{group.name}</span>
                                                                            <span>{group.items.length} {group.items.length === 1 ? 'story' : 'stories'}</span>
                                                                        </a>
                                                                    ) : (
                                                                        <div className="alert-team-title">
                                                                            <span className="alert-pill team">{group.name}</span>
                                                                            <span>{group.items.length} {group.items.length === 1 ? 'story' : 'stories'}</span>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                                <div className="alert-stories">
                                                                    {group.items.map(task => {
                                                                        const statusLabel = getBlockedAlertStatusLabel(task);
                                                                        return (
                                                                            <div key={task.key} className="alert-story">
                                                                                <div
                                                                                    className="alert-story-main"
                                                                                    role="button"
                                                                                    tabIndex={0}
                                                                                    onClick={() => handleAlertStoryClick(task.key)}
                                                                                    onKeyDown={(event) => {
                                                                                        if (event.key === 'Enter' || event.key === ' ') {
                                                                                            event.preventDefault();
                                                                                            handleAlertStoryClick(task.key);
                                                                                        }
                                                                                    }}
                                                                                >
                                                                                    <a
                                                                                        className="alert-story-link"
                                                                                        href={jiraUrl ? `${jiraUrl}/browse/${task.key}` : '#'}
                                                                                        target="_blank"
                                                                                        rel="noopener noreferrer"
                                                                                        onClick={(event) => {
                                                                                            event.preventDefault();
                                                                                            event.stopPropagation();
                                                                                            handleAlertStoryClick(task.key);
                                                                                        }}
                                                                                    >
                                                                                        {task.key}  {task.fields.summary}
                                                                                    </a>
                                                                                </div>
                                                                                <span className="alert-pill status">{statusLabel}</span>
                                                                                <button
                                                                                    className="task-remove alert-remove"
                                                                                    onClick={(event) => {
                                                                                        event.stopPropagation();
                                                                                        dismissAlertItem(task.key);
                                                                                    }}
                                                                                    title="Dismiss from alerts"
                                                                                    type="button"
                                                                                >
                                                                                    
                                                                                </button>
                                                                            </div>
                                                                        );
                                                                    })}
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                            </div>
	                                        </div>
	                                    )}

	                                    {emptyEpics.length > 0 && (
		                                        <div className={`alert-card empty-epic ${showEmptyEpicAlert ? '' : 'collapsed'}`}>
	                                            <div className="alert-card-header">
	                                                <button
	                                                    className="alert-toggle"
	                                                    onClick={() => setShowEmptyEpicAlert(prev => !prev)}
	                                                    title={showEmptyEpicAlert ? 'Collapse empty epic panel' : 'Expand empty epic panel'}
	                                                >
	                                                    <span className="alert-toggle-icon" aria-hidden="true">
	                                                        <svg className={`alert-toggle-chevron ${showEmptyEpicAlert ? '' : 'collapsed'}`} viewBox="0 0 12 12">
	                                                            <path d="M2.5 4.5l3.5 3 3.5-3" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
	                                                        </svg>
	                                                    </span>
	                                                    <span className="alert-toggle-label">
	                                                        {showEmptyEpicAlert ? 'Hide' : 'Show'}
	                                                    </span>
	                                                </button>
	                                                <div className="alert-title"> Empty Epic</div>
	                                                <div className="alert-subtitle">These epics have zero storiesplease review and create at least one story to make them actionable.</div>
	                                                <a
	                                                    className="alert-chip"
	                                                    href={buildKeyListLink(emptyEpics.map(e => e.key))}
	                                                    target="_blank"
	                                                    rel="noopener noreferrer"
	                                                    title="Open these epics in Jira"
	                                                >
	                                                    {emptyEpics.length} {emptyEpics.length === 1 ? 'epic' : 'epics'}
	                                                </a>
	                                            </div>
                                            <div className={`alert-card-body ${showEmptyEpicAlert ? '' : 'collapsed'}`}>
                                                    {emptyEpicTeams.map(group => {
                                                        const keys = group.items.map(item => item.key);
                                                        const teamLink = buildKeyListLink(keys);
                                                        return (
                                                            <div key={group.id} className="alert-team-group">
                                                                <div className="alert-team-header">
                                                                    {teamLink ? (
                                                                        <a
                                                                            className="alert-team-link"
                                                                            href={teamLink}
                                                                            target="_blank"
                                                                            rel="noopener noreferrer"
                                                                        >
                                                                            <span className="alert-pill team">{group.name}</span>
                                                                            <span>{group.items.length} {group.items.length === 1 ? 'epic' : 'epics'}</span>
                                                                        </a>
                                                                    ) : (
                                                                        <div className="alert-team-title">
                                                                            <span className="alert-pill team">{group.name}</span>
                                                                            <span>{group.items.length} {group.items.length === 1 ? 'epic' : 'epics'}</span>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                                <div className="alert-stories">
                                                                    {group.items.map(epic => (
                                                                        <div key={epic.key} className="alert-story">
                                                                            <div
                                                                                className="alert-story-main"
                                                                                role="button"
                                                                                tabIndex={0}
                                                                                onClick={() => handleAlertStoryClick(epic.key)}
                                                                                onKeyDown={(event) => {
                                                                                    if (event.key === 'Enter' || event.key === ' ') {
                                                                                        event.preventDefault();
                                                                                        handleAlertStoryClick(epic.key);
                                                                                    }
                                                                                }}
                                                                            >
                                                                                <a
                                                                                    className="alert-story-link"
                                                                                    href={jiraUrl ? `${jiraUrl}/browse/${epic.key}` : '#'}
                                                                                    target="_blank"
                                                                                    rel="noopener noreferrer"
                                                                                    onClick={(event) => {
                                                                                        event.preventDefault();
                                                                                        event.stopPropagation();
                                                                                        handleAlertStoryClick(epic.key);
                                                                                    }}
                                                                                >
                                                                                    {epic.key}  {epic.summary}
                                                                                </a>
                                                                            </div>
                                                                            {epic.status?.name && (
                                                                                <span className="alert-pill status">{epic.status.name}</span>
                                                                            )}
                                                                            <a
                                                                                className="alert-action"
                                                                                href={jiraUrl ? `${jiraUrl}/browse/${epic.key}` : '#'}
                                                                                target="_blank"
                                                                                rel="noopener noreferrer"
                                                                            >
                                                                                Create story 
                                                                            </a>
                                                                            <button
                                                                                className="task-remove alert-remove"
                                                                                onClick={(event) => {
                                                                                    event.stopPropagation();
                                                                                    dismissAlertItem(epic.key);
                                                                                }}
                                                                                title="Dismiss from alerts"
                                                                                type="button"
                                                                            >
                                                                                
                                                                            </button>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                            </div>
		                                        </div>
		                                    )}

		                                    {doneStoryEpics.length > 0 && (
		                                        <div className={`alert-card done-epic ${showDoneEpicAlert ? '' : 'collapsed'}`}>
	                                            <div className="alert-card-header">
	                                                <button
	                                                    className="alert-toggle"
	                                                    onClick={() => setShowDoneEpicAlert(prev => !prev)}
	                                                    title={showDoneEpicAlert ? 'Collapse ready-to-close epics panel' : 'Expand ready-to-close epics panel'}
	                                                >
	                                                    <span className="alert-toggle-icon" aria-hidden="true">
	                                                        <svg className={`alert-toggle-chevron ${showDoneEpicAlert ? '' : 'collapsed'}`} viewBox="0 0 12 12">
	                                                            <path d="M2.5 4.5l3.5 3 3.5-3" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" />
	                                                        </svg>
	                                                    </span>
	                                                    <span className="alert-toggle-label">
	                                                        {showDoneEpicAlert ? 'Hide' : 'Show'}
	                                                    </span>
	                                                </button>
	                                                <div className="alert-title"> Epic Ready to Close</div>
	                                                <div className="alert-subtitle">All stories are done, killed, or incomplete, but the epic is still opentime to close the loop.</div>
	                                                <a
	                                                    className="alert-chip"
	                                                    href={buildKeyListLink(doneStoryEpics.map(e => e.key))}
	                                                    target="_blank"
	                                                    rel="noopener noreferrer"
	                                                    title="Open these epics in Jira"
	                                                >
	                                                    {doneStoryEpics.length} {doneStoryEpics.length === 1 ? 'epic' : 'epics'}
	                                                </a>
	                                            </div>
                                            <div className={`alert-card-body ${showDoneEpicAlert ? '' : 'collapsed'}`}>
                                                    {doneEpicTeams.map(group => {
                                                        const keys = group.items.map(item => item.key);
                                                        const teamLink = buildKeyListLink(keys);
                                                        return (
                                                            <div key={group.id} className="alert-team-group">
                                                                <div className="alert-team-header">
                                                                    {teamLink ? (
                                                                        <a
                                                                            className="alert-team-link"
                                                                            href={teamLink}
                                                                            target="_blank"
                                                                            rel="noopener noreferrer"
                                                                        >
                                                                            <span className="alert-pill team">{group.name}</span>
                                                                            <span>{group.items.length} {group.items.length === 1 ? 'epic' : 'epics'}</span>
                                                                        </a>
                                                                    ) : (
                                                                        <div className="alert-team-title">
                                                                            <span className="alert-pill team">{group.name}</span>
                                                                            <span>{group.items.length} {group.items.length === 1 ? 'epic' : 'epics'}</span>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                                <div className="alert-stories">
                                                                    {group.items.map(epic => (
                                                                        <div key={epic.key} className="alert-story">
                                                                            <div
                                                                                className="alert-story-main"
                                                                                role="button"
                                                                                tabIndex={0}
                                                                                onClick={() => handleAlertStoryClick(epic.key)}
                                                                                onKeyDown={(event) => {
                                                                                    if (event.key === 'Enter' || event.key === ' ') {
                                                                                        event.preventDefault();
                                                                                        handleAlertStoryClick(epic.key);
                                                                                    }
                                                                                }}
                                                                            >
                                                                                <a
                                                                                    className="alert-story-link"
                                                                                    href={jiraUrl ? `${jiraUrl}/browse/${epic.key}` : '#'}
                                                                                    target="_blank"
                                                                                    rel="noopener noreferrer"
                                                                                    onClick={(event) => {
                                                                                        event.preventDefault();
                                                                                        event.stopPropagation();
                                                                                        handleAlertStoryClick(epic.key);
                                                                                    }}
                                                                                >
                                                                                    {epic.key}  {epic.summary}
                                                                                </a>
                                                                            </div>
                                                                            {epic.assignee?.displayName && (
                                                                                <span className="alert-pill status">{epic.assignee.displayName}</span>
                                                                            )}
                                                                            <a
                                                                                className="alert-action"
                                                                                href={jiraUrl ? `${jiraUrl}/browse/${epic.key}` : '#'}
                                                                                target="_blank"
                                                                                rel="noopener noreferrer"
                                                                            >
                                                                                Close epic 
                                                                            </a>
                                                                            <button
                                                                                className="task-remove alert-remove"
                                                                                onClick={(event) => {
                                                                                    event.stopPropagation();
                                                                                    dismissAlertItem(epic.key);
                                                                                }}
                                                                                title="Dismiss from alerts"
                                                                                type="button"
                                                                            >
                                                                                
                                                                            </button>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                            </div>
	                                        </div>
	                                    )}

	                                </div>
	                            )}
                            <div className="stats">
                                <div
                                    className={`stat-card total ${statusFilter === null ? 'active' : ''} ${baseFilteredTasks.length === 0 ? 'disabled' : ''}`}
                                    onClick={() => {
                                        if (baseFilteredTasks.length === 0) return;
                                        setStatusFilter(null);
                                    }}
                                >
                                    <div className="stat-value">{baseFilteredTasks.length}</div>
                                    <div className="stat-label">Total Tasks</div>
                                    <div className="stats-note">{totalStoryPoints.toFixed(1)} SP</div>
                                </div>
                                <div
                                    className={`stat-card done ${statusFilter === 'done' ? 'active' : ''} ${doneTasksCount === 0 ? 'disabled' : ''}`}
                                    onClick={() => {
                                        if (doneTasksCount === 0) return;
                                        setStatusFilter(statusFilter === 'done' ? null : 'done');
                                    }}
                                >
                                    <div className="stat-value">{doneTasksCount}</div>
                                    <div className="stat-label">Done Tasks</div>
                                    <div className="stats-note">{doneStoryPoints.toFixed(1)} SP</div>
                                </div>
                                <div
                                    className={`stat-card high-priority ${statusFilter === 'high-priority' ? 'active' : ''} ${highPriorityCount === 0 ? 'disabled' : ''}`}
                                    onClick={() => {
                                        if (highPriorityCount === 0) return;
                                        setStatusFilter(statusFilter === 'high-priority' ? null : 'high-priority');
                                    }}
                                >
                                    <div className="stat-value">{highPriorityCount}</div>
                                    <div className="stat-label">High Priority</div>
                                    <div className="stats-note">{highPriorityStoryPoints.toFixed(1)} SP</div>
                                </div>
                                <div
                                    className={`stat-card minor ${statusFilter === 'minor-priority' ? 'active' : ''} ${minorPriorityCount === 0 ? 'disabled' : ''}`}
                                    onClick={() => {
                                        if (minorPriorityCount === 0) return;
                                        setStatusFilter(statusFilter === 'minor-priority' ? null : 'minor-priority');
                                    }}
                                >
                                    <div className="stat-value">{minorPriorityCount}</div>
                                    <div className="stat-label">Minor + Lower</div>
                                    <div className="stats-note">{minorPriorityStoryPoints.toFixed(1)} SP</div>
                                </div>
                                <div
                                    className={`stat-card in-progress ${statusFilter === 'in-progress' ? 'active' : ''} ${inProgressTasksCount === 0 ? 'disabled' : ''}`}
                                    onClick={() => {
                                        if (inProgressTasksCount === 0) return;
                                        setStatusFilter(statusFilter === 'in-progress' ? null : 'in-progress');
                                    }}
                                >
                                    <div className="stat-value">{inProgressTasksCount}</div>
                                    <div className="stat-label">In Progress</div>
                                    <div className="stats-note">{inProgressStoryPoints.toFixed(1)} SP</div>
                                </div>
                                <div
                                    className={`stat-card todo-accepted ${statusFilter === 'todo-accepted' ? 'active' : ''} ${todoAcceptedTasksCount === 0 ? 'disabled' : ''}`}
                                    onClick={() => {
                                        if (todoAcceptedTasksCount === 0) return;
                                        setStatusFilter(statusFilter === 'todo-accepted' ? null : 'todo-accepted');
                                    }}
                                >
                                    <div className="stat-value">{todoAcceptedTasksCount}</div>
                                    <div className="stat-label">To Do / Pending / Accepted</div>
                                    <div className="stats-note">{todoAcceptedStoryPoints.toFixed(1)} SP</div>
                                </div>
                            </div>

                            <div className="toggle-container">
                                <button
                                    className={`toggle ${showTech ? 'active' : ''}`}
                                    onClick={() => {
                                        setShowTech(!showTech);
                                    }}
                                >
                                    {showTech
                                        ? `Hide Tech Tasks (${techTasksCount})`
                                        : `Show Tech Tasks (${techTasksCount})`}
                                </button>
                                <button
                                    className={`toggle ${showProduct ? 'active' : ''}`}
                                    onClick={() => setShowProduct(!showProduct)}
                                >
                                    {showProduct ? `Hide Product Tasks (${productTasksCount})` : `Show Product Tasks (${productTasksCount})`}
                                </button>
                                <button
                                    className={`toggle ${showDependencies ? 'active' : ''}`}
                                    onClick={() => setShowDependencies(!showDependencies)}
                                >
                                    {showDependencies ? 'Hide Dependencies' : 'Show Dependencies'}
                                </button>
                                {doneTasks.length > 0 && (
                                    <button
                                        className={`toggle ${showDone ? 'active' : ''}`}
                                        onClick={() => setShowDone(!showDone)}
                                    >
                                        {showDone ? `Hide Done Tasks (${doneTasks.length})` : `Show Done Tasks (${doneTasks.length})`}
                                    </button>
                                )}
                                {killedTasks.length > 0 && (
                                    <button
                                        className={`toggle ${showKilled ? 'active' : ''}`}
                                        onClick={() => setShowKilled(!showKilled)}
                                    >
                                        {showKilled ? `Hide Killed Tasks (${killedTasks.length})` : `Show Killed Tasks (${killedTasks.length})`}
                                    </button>
                                )}
                            </div>

                            {visibleTasks.length === 0 ? (
                                <div className="empty-state">
                                    <h2>No tasks found</h2>
                                    <p>There are no tasks matching the current criteria</p>
                                </div>
                            ) : (
                                <div
                                    className={`task-list ${dependencyFocus ? 'focus-mode' : ''}`}
                                    onClick={handleDependencyFocusClick}
                                >
                                    {epicGroups.map(epicGroup => {
                                        const epicInfo = epicGroup.epic;
                                        const epicTitle = epicInfo?.summary || epicGroup.parentSummary ||
                                            (epicGroup.key === 'NO_EPIC' ? 'No Epic Linked' : epicGroup.key);
                                        const epicTotalSp = epicGroup.storyPoints || 0;
                                        return (
                                            <div
                                                key={epicGroup.key}
                                                className={`epic-block ${excludedEpicSet.has(epicGroup.key) ? 'epic-excluded' : ''}`}
                                                ref={(node) => {
                                                    if (!node) return;
                                                    epicRefMap.current.set(epicGroup.key, node);
                                                }}
                                            >
	                                                <div className="epic-header">
                                                        <div className="epic-title">
	                                                        <div className="epic-title-row">
                                                            <span className="epic-icon" aria-hidden="true" title="EPIC">
                                                                <svg viewBox="0 0 24 24" fill="none">
                                                                    <rect x="3" y="3" width="18" height="18" rx="3" stroke="#1D7AFC" strokeWidth="2"/>
                                                                    <path d="M7.5 12.5l3 3 6-6" stroke="#1D7AFC" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                                                                </svg>
                                                            </span>
                                                            {epicGroup.key !== 'NO_EPIC' ? (
                                                                <a
                                                                    className="epic-link"
                                                                    href={jiraUrl ? `${jiraUrl}/browse/${epicGroup.key}` : '#'}
                                                                    target="_blank"
                                                                    rel="noopener noreferrer"
                                                                >
                                                                    <span className="epic-name">{epicTitle}</span>
                                                                    <span className="epic-key">{epicGroup.key}</span>
                                                                </a>
                                                            ) : (
                                                                <>
                                                                    <span className="epic-name">{epicTitle}</span>
                                                                    <span className="epic-key">Unassigned</span>
                                                                </>
                                                            )}
                                                            {(showStats || showPlanning) && (
                                                                <button
                                                                    className={`epic-stat-toggle ${excludedEpicSet.has(epicGroup.key) ? '' : 'active'}`}
                                                                    onClick={() => {
                                                                        const epicKey = epicGroup.key || 'NO_EPIC';
                                                                        setExcludedStatsEpics((prev) => {
                                                                            const set = new Set(prev || []);
                                                                            if (set.has(epicKey)) {
                                                                                set.delete(epicKey);
                                                                            } else {
                                                                                set.add(epicKey);
                                                                            }
                                                                            return Array.from(set);
                                                                        });
                                                                    }}
                                                                    title="Include/exclude epic in sprint stats and planning capacity"
                                                                >
                                                                    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                                                                        <circle cx="12" cy="12" r="9" stroke="currentColor" strokeWidth="2" />
                                                                        <path d="M12 6v6l4 2" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
                                                                    </svg>
                                                                    {excludedEpicSet.has(epicGroup.key) ? 'Excluded' : 'Included'}
                                                                </button>
                                                            )}
                                                        </div>
	                                                    </div>
	                                                    <div className="epic-meta">
	                                                        <span>SP: {epicTotalSp.toFixed(1)}</span>
	                                                        {epicInfo?.assignee?.displayName && (
	                                                            <span className="task-assignee epic-assignee">
	                                                                <span className="task-assignee-icon" aria-hidden="true">
	                                                                    <svg viewBox="0 0 24 24" fill="none">
	                                                                        <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4z" stroke="currentColor" strokeWidth="2" />
	                                                                        <path d="M4 20c0-3.31 3.58-6 8-6s8 2.69 8 6" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
	                                                                    </svg>
	                                                                </span>
	                                                                <span>{epicInfo.assignee.displayName}</span>
	                                                            </span>
	                                                        )}
	                                                    </div>
	                                                </div>
                                                {epicGroup.tasks.map(task => {
                                                    const isKilled = task.fields.status?.name === 'Killed';
                                                    const isDone = task.fields.status?.name === 'Done';
                                                    const teamInfo = getTeamInfo(task);
                                                    const rawDeps = showDependencies
                                                        ? (dependencyData[task.key] || []).filter(dep => dep.key && dep.category === 'dependency')
                                                        : [];
                                                    const rawBlockDeps = showDependencies
                                                        ? (dependencyData[task.key] || []).filter(dep => dep.key && dep.category === 'block')
                                                        : [];
                                                    const uniqueDeps = (() => {
                                                        const seen = new Set();
                                                        return rawDeps.filter(dep => {
                                                            const key = `${dep.key}-${dep.direction}`;
                                                            if (seen.has(key)) return false;
                                                            seen.add(key);
                                                            return true;
                                                        });
                                                    })();
                                                    const dependsOnAll = uniqueDeps.filter(dep => dep.direction === 'outward');
                                                    const dependentsAll = uniqueDeps.filter(dep => dep.direction === 'inward');
                                                    const dependsOnIds = dependsOnAll.map(dep => dep.key).filter(Boolean);
                                                    const dependentIds = dependentsAll.map(dep => dep.key).filter(Boolean);
                                                    const { blockedBy: blockedByIds, blocks: blocksIds } = getBlockLinkBuckets(rawBlockDeps, task.key);
                                                    const hasBlockLinks = blockedByIds.length > 0 || blocksIds.length > 0;
                                                    const hasDependencyLinks = dependsOnIds.length > 0 || dependentIds.length > 0;
                                                    const hasDeps = hasDependencyLinks || hasBlockLinks;
                                                    const hasCycle = dependsOnIds.some(id => dependentIds.includes(id) && issueByKey.has(id));
                                                    const isDependsFocusActive = dependencyFocus &&
                                                        dependencyFocus.taskKey === task.key &&
                                                        dependencyFocus.action === 'depends-on';
                                                    const isDependentsFocusActive = dependencyFocus &&
                                                        dependencyFocus.taskKey === task.key &&
                                                        dependencyFocus.action === 'dependents';
                                                    const isBlockedByFocusActive = dependencyFocus &&
                                                        dependencyFocus.taskKey === task.key &&
                                                        dependencyFocus.action === 'blocked-by';
                                                    const isBlocksFocusActive = dependencyFocus &&
                                                        dependencyFocus.taskKey === task.key &&
                                                        dependencyFocus.action === 'blocks';
                                                    const isFocusActive = !!dependencyFocus;
                                                    const isRelated = !isFocusActive || focusRelatedSet.has(task.key);
                                                    const isFocused = isFocusActive && dependencyFocus.taskKey === task.key;
                                                    const isUpstream = isFocusActive &&
                                                        (dependencyFocus.action === 'depends-on' || dependencyFocus.action === 'blocked-by') &&
                                                        !isFocused &&
                                                        focusRelatedSet.has(task.key);
                                                    const isDownstream = isFocusActive &&
                                                        (dependencyFocus.action === 'dependents' || dependencyFocus.action === 'blocks') &&
                                                        !isFocused &&
                                                        focusRelatedSet.has(task.key);
                                                    const missingKeys = isFocused ? (dependencyFocus?.missingKeys || []) : [];
                                                    const dependencyKeyList = dependencyFocus?.dependencyKeys
                                                        || (dependencyFocus?.relatedKeys || []).filter(key => key !== task.key);
                                                    const hiddenKeys = isFocused
                                                        ? dependencyKeyList.filter(key => issueByKey.has(key) && !visibleTaskKeySet.has(key))
                                                        : [];
                                                    const missingInfoByKey = {};
                                                    uniqueDeps.forEach(dep => {
                                                        if (dep.key) {
                                                            missingInfoByKey[dep.key] = dep;
                                                        }
                                                    });
                                                    const missingLines = missingKeys.map(key => {
                                                        const lookup = dependencyLookupCache[key];
                                                        const info = missingInfoByKey[key] || {};
                                                        const status = lookup?.status || info.status || 'Unknown';
                                                        const summary = lookup?.summary || info.summary || 'Unknown summary';
                                                        const teamName = lookup?.teamName || info.teamName || 'Unknown team';
                                                        const assignee = lookup?.assignee?.displayName || info.assignee || 'Unassigned';
                                                        const isDone = normalizeStatus(status) === 'done';
                                                        return { key, status, summary, teamName, assignee, isDone };
                                                    });
                                                    const hiddenLines = hiddenKeys.map(key => {
                                                        const lookup = issueByKey.get(key);
                                                        const info = missingInfoByKey[key] || {};
                                                        const status = lookup?.fields?.status?.name || lookup?.status?.name || lookup?.status || info.status || 'Unknown';
                                                        const summary = lookup?.fields?.summary || lookup?.summary || info.summary || 'Unknown summary';
                                                        const teamName = lookup?.fields
                                                            ? getTeamInfo(lookup).name
                                                            : (lookup?.teamName || info.teamName || 'Unknown team');
                                                        const assignee = lookup?.fields?.assignee?.displayName || lookup?.assignee?.displayName || info.assignee || 'Unassigned';
                                                        const isDone = normalizeStatus(status) === 'done';
                                                        return { key, status, summary, teamName, assignee, isDone };
                                                    });
                                                    return (
                                                        <div
                                                            key={task.key}
                                                            className={`task-item priority-${task.fields.priority?.name.toLowerCase()} ${isDone ? 'status-done' : ''} ${isKilled ? 'status-killed' : ''} ${isFocusActive && !isRelated ? 'is-dimmed' : ''} ${isFocused ? 'is-focused' : ''} ${isUpstream ? 'is-upstream' : ''} ${isDownstream ? 'is-downstream' : ''}`}
                                                            data-task-key={task.key}
                                                            data-task-id={task.id || task.key}
                                                            data-issue-key={task.key}
                                                        >
                                                            <div className="task-header">
                                                                <button
                                                                    className="task-remove"
                                                                    onClick={() => removeTask(task)}
                                                                    title="Remove task from view"
                                                                >
                                                                    
                                                                </button>
                                                                <div className="task-headline">
                                                                    <span className="story-icon" aria-hidden="true" title="STORY">
                                                                        <svg viewBox="0 0 24 24" fill="none">
                                                                            <path d="M7 4h10a2 2 0 012 2v14l-7-4-7 4V6a2 2 0 012-2z" stroke="#55A630" strokeWidth="2" strokeLinejoin="round"/>
                                                                        </svg>
                                                                    </span>
                                                                    <h3 className="task-title">
                                                                        <a href={jiraUrl ? `${jiraUrl}/browse/${task.key}` : '#'} target="_blank" rel="noopener noreferrer">
                                                                            {task.fields.summary}
                                                                        </a>
                                                                    </h3>
                                                                    <span className="task-inline-meta">
                                                                        <a
                                                                            className="task-key-link"
                                                                            href={jiraUrl ? `${jiraUrl}/browse/${task.key}` : '#'}
                                                                            target="_blank"
                                                                            rel="noopener noreferrer"
                                                                        >
                                                                            {task.key}
                                                                        </a>
                                                                        {task.fields.customfield_10004 && (
                                                                            <span className="task-inline-sp">
                                                                                {task.fields.customfield_10004} SP
                                                                            </span>
                                                                        )}
                                                                    </span>
                                                                    {showPlanning && (
                                                                        <input
                                                                            type="checkbox"
                                                                            className="task-checkbox"
                                                                            checked={!!selectedTasks[task.key]}
                                                                            onChange={() => toggleTaskSelection(task.key)}
                                                                            title="Select for sprint planning"
                                                                        />
                                                                    )}
                                                                </div>
                                                                <div className="task-header-right">
                                                                    <span className={`task-priority ${task.fields.priority?.name.toLowerCase()}`}>
                                                                        {task.fields.priority?.name || 'None'}
                                                                    </span>
                                                                    {showDependencies && hasDependencyLinks && (
                                                                        <div className="dependency-pill-stack">
                                                                            {dependsOnIds.length > 0 && (
                                                                                <span className="dependency-pill blocked"> BLOCKED BY</span>
                                                                            )}
                                                                            {dependentIds.length > 0 && (
                                                                                <span className="dependency-pill blocker">BLOCKS </span>
                                                                            )}
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            </div>
                                                            <div className="task-meta">
                                                                <span className={`task-status ${task.fields.status?.name.toLowerCase().replace(/\s+/g, '-')}`}>
                                                                    {task.fields.status?.name}
                                                                </span>
                                                                <span className="task-team">{teamInfo.name}</span>
                                                                {task.fields.assignee && (
                                                                    <span className="task-assignee">
                                                                        <span className="task-assignee-icon" aria-hidden="true">
                                                                            <svg viewBox="0 0 24 24" fill="none">
                                                                                <path d="M12 12a4.5 4.5 0 1 0-4.5-4.5A4.5 4.5 0 0 0 12 12Z" stroke="currentColor" strokeWidth="1.6"/>
                                                                                <path d="M4 20c1.8-4 6-5.5 8-5.5S18.2 16 20 20" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round"/>
                                                                            </svg>
                                                                        </span>
                                                                        {task.fields.assignee.displayName}
                                                                    </span>
                                                                )}
                                                                {task.fields.updated && (
                                                                    <span className="task-updated">
                                                                        Last Update: {new Date(task.fields.updated).toLocaleDateString('en-CA')}
                                                                    </span>
                                                                )}
                                                            </div>
                                                            {showDependencies && hasDeps && (
                                                                <div className="dependency-strip">
                                                                    {blockedByIds.length > 0 && (
                                                                        <button
                                                                            type="button"
                                                                            className={`dependency-count ${isBlockedByFocusActive ? 'active' : ''}`}
                                                                            data-dep-chip="blocked-by"
                                                                            data-task-id={task.id || task.key}
                                                                            data-task-key={task.key}
                                                                            aria-label={`Blocked by ${blockedByIds.length} tasks`}
                                                                        >
                                                                            BLOCKED BY {blockedByIds.length}
                                                                        </button>
                                                                    )}
                                                                    {blocksIds.length > 0 && (
                                                                        <button
                                                                            type="button"
                                                                            className={`dependency-count ${isBlocksFocusActive ? 'active' : ''}`}
                                                                            data-dep-chip="blocks"
                                                                            data-task-id={task.id || task.key}
                                                                            data-task-key={task.key}
                                                                            aria-label={`Blocks ${blocksIds.length} tasks`}
                                                                        >
                                                                            BLOCKS {blocksIds.length}
                                                                        </button>
                                                                    )}
                                                                    {dependsOnIds.length > 0 && (
                                                                        <button
                                                                            type="button"
                                                                            className={`dependency-count ${isDependsFocusActive ? 'active' : ''}`}
                                                                            data-dep-chip="depends-on"
                                                                            data-task-id={task.id || task.key}
                                                                            data-task-key={task.key}
                                                                            aria-label={`Depends on ${dependsOnIds.length} tasks`}
                                                                        >
                                                                            DEPENDS ON {dependsOnIds.length}
                                                                        </button>
                                                                    )}
                                                                    {dependentIds.length > 0 && (
                                                                        <button
                                                                            type="button"
                                                                            className={`dependency-count ${isDependentsFocusActive ? 'active' : ''}`}
                                                                            data-dep-chip="dependents"
                                                                            data-task-id={task.id || task.key}
                                                                            data-task-key={task.key}
                                                                            aria-label={`Dependents ${dependentIds.length} tasks`}
                                                                        >
                                                                            DEPENDENTS {dependentIds.length}
                                                                        </button>
                                                                    )}
                                                                </div>
                                                            )}
                                                            {showDependencies && isFocused && (missingLines.length > 0 || hiddenLines.length > 0) && (
                                                                <div className="dependency-missing">
                                                                    {hiddenLines.length > 0 && (
                                                                        <>
                                                                            <div className="dependency-missing-label hidden">Hidden by filter</div>
                                                                            {hiddenLines.map(item => (
                                                                                <div className="dependency-missing-item" key={`hidden-${item.key}`}>
                                                                                    <span>{item.teamName}</span>
                                                                                    <span className="dependency-missing-sep"></span>
                                                                                    <span>{item.assignee}</span>
                                                                                    <span className="dependency-missing-sep"></span>
                                                                                    <span>{item.summary}</span>
                                                                                    <span className="dependency-missing-sep"></span>
                                                                                    <span>{item.key}</span>
                                                                                    <span className="dependency-missing-sep"></span>
                                                                                    <span className={`dependency-missing-status ${item.isDone ? 'done' : ''}`}>{item.status}</span>
                                                                                </div>
                                                                            ))}
                                                                        </>
                                                                    )}
                                                                    {missingLines.length > 0 && (
                                                                        <>
                                                                            <div className="dependency-missing-label">Not loaded</div>
                                                                            {missingLines.map(item => (
                                                                                <div className="dependency-missing-item" key={`missing-${item.key}`}>
                                                                                    <span>{item.teamName}</span>
                                                                                    <span className="dependency-missing-sep"></span>
                                                                                    <span>{item.assignee}</span>
                                                                                    <span className="dependency-missing-sep"></span>
                                                                                    <span>{item.summary}</span>
                                                                                    <span className="dependency-missing-sep"></span>
                                                                                    <span>{item.key}</span>
                                                                                    <span className="dependency-missing-sep"></span>
                                                                                    <span className={`dependency-missing-status ${item.isDone ? 'done' : ''}`}>{item.status}</span>
                                                                                </div>
                                                                            ))}
                                                                            {dependencyLookupLoading && (
                                                                                <div className="dependency-missing-item">Loading issue details...</div>
                                                                            )}
                                                                        </>
                                                                    )}
                                                                </div>
                                                            )}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        );
                                    })}
                                </div>
                            )}

                            <div style={{marginTop: '3rem', textAlign: 'center'}}>
                                <button onClick={fetchTasks}>
                                    Refresh
                                </button>
                            </div>
                        </>
                    )}

                    {showGroupManage && (
                        <div
                            className="group-modal-backdrop"
                            role="dialog"
                            aria-modal="true"
                            onClick={closeGroupManage}
                        >
                            <div className="group-modal" onClick={(event) => event.stopPropagation()}>
                                <div className="group-modal-header">
                                    <div>
                                        <div className="group-modal-title">Manage Groups</div>
                                        <div className="group-modal-meta">
                                            {groupConfigSource ? `Source: ${groupConfigSource}` : 'Source: local'}
                                        </div>
                                    </div>
                                    <button className="secondary compact" onClick={closeGroupManage}>
                                        Close
                                    </button>
                                </div>
                                <div className="group-modal-body">
                                    {groupsError && (
                                        <div className="group-modal-warning">{groupsError}</div>
                                    )}
                                    {(groupWarnings || []).length > 0 && (
                                        <div className="group-modal-warning">
                                            {(groupWarnings || []).join(' ')}
                                        </div>
                                    )}
                                    {groupDraftError && (
                                        <div className="group-modal-warning">{groupDraftError}</div>
                                    )}
                                    {(groupDraft?.groups || []).length === 0 && (
                                        <div className="group-modal-meta">No groups yet. Add one below.</div>
                                    )}
                                    {(groupDraft?.groups || []).map(group => (
                                        <div className="group-modal-row" key={group.id}>
                                            <input
                                                type="text"
                                                value={group.name}
                                                onChange={(event) => updateGroupDraftName(group.id, event.target.value)}
                                                placeholder="Group name"
                                            />
                                            <textarea
                                                value={(group.teamIds || []).join(', ')}
                                                onChange={(event) => updateGroupDraftTeams(group.id, event.target.value)}
                                                placeholder="Team IDs (comma separated, max 12)"
                                            />
                                            <div className="group-modal-actions">
                                                <button
                                                    className={`group-star-button ${groupDraft?.defaultGroupId === group.id ? 'active' : ''}`}
                                                    onClick={() => toggleDefaultGroupDraft(group.id)}
                                                    title="Set as default group"
                                                    type="button"
                                                >
                                                    <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                                                        <path d="M12 3.5l2.6 5.3 5.8.8-4.2 4.1 1 5.8-5.2-2.8-5.2 2.8 1-5.8L3.6 9.6l5.8-.8L12 3.5z"/>
                                                    </svg>
                                                </button>
                                                <button
                                                    className="secondary compact"
                                                    onClick={() => removeGroupDraft(group.id)}
                                                    type="button"
                                                >
                                                    Delete
                                                </button>
                                                <span className="group-modal-meta">
                                                    {(group.teamIds || []).length}/12 teams
                                                </span>
                                            </div>
                                        </div>
                                    ))}
                                    <div className="group-modal-meta">Import JSON (overwrites current draft).</div>
                                    <textarea
                                        value={groupImportText}
                                        onChange={(event) => setGroupImportText(event.target.value)}
                                        placeholder='{"version":1,"groups":[...]}'
                                    />
                                    <div className="group-modal-actions">
                                        <button className="secondary compact" onClick={importGroupsConfig} type="button">
                                            Import
                                        </button>
                                    </div>
                                </div>
                                <div className="group-modal-footer">
                                    <div className="group-modal-button-row">
                                        <button className="secondary compact" onClick={addGroupDraftRow} type="button">
                                            Add Group
                                        </button>
                                        <button className="secondary compact" onClick={exportGroupsConfig} type="button">
                                            Export JSON
                                        </button>
                                    </div>
                                    <div className="group-modal-button-row">
                                        <button className="secondary compact" onClick={closeGroupManage} type="button">
                                            Cancel
                                        </button>
                                        <button className="compact" onClick={saveGroupsConfig} disabled={groupSaving} type="button">
                                            {groupSaving ? 'Saving...' : 'Save'}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
